{"mappings":"A;;;;;A;;;;A;;;;;A;;;;;;;;A;;;;;;A;;;;;;;A;;;;;;;A;;;;;;;;A;;;;;;;;;;A;;;;;;;;A;;;;;;;;A;;;;A;;;;;A;;;;;AEqNA;;;;AAGA;;;;;;AAKA;;;;;;AAKA;;;;;;;;A;;;;;A;;;;;A;;;;A;;;;;A;;;;;;;;;A;;;;;;;;A;;;;A;;;;;;;;A;;;;A;;;;;;;A;;;;A;;;;;;A;;;;;;;A;;;;;A;;;;;;;A;;;;A;;;;;;A;;;;;;;A;;;;;A;;;;;;;A;;;;A;;;;;;A;;;;;;;A;;;;;A;;;;;A;;;;;;A;;;;;;;;;;;;A;;;;A;;;;;;;A;;;;;;;A;;;;;A;;;;;;;;A;;;;;;;A;;;;;A;;;;;;;A;;;;;;;A;;;;;A;;;;A;;;;;;A;;;;A;;;;;A;;;;;;;A;;;;;;A;;;;;;A;;;;A;;;;;;A;;;;;;;;;;A;;;;;A;;;;;A;;;;;;;;;A;;;;A;;;;;;A;;;;A;;;;;;A;;;;A;;;;;;;A;;;;;A;;;;;A;;;;A;;;;;;A;;;;;A;;;;;A;;;;;;;A;;;;;;A;;;;A;;;;;;;A;;;;;A;;;;;A;;;;A;;;;;;A;;;;;A;;;;;A;;;;;;;A;;;;;A;;;;;;;;A;;;;;;A;;;;;;;;A;;;;;A;;;;;;;;;A;;;;;;;;;;;A;;;;;A;;;;;;A;;;;A;;;;A;;;;;;A;;;;A;;;;;A;;;;;;;;;;;;;A;;;;A;;;;;;;;;;;;;A;;;;A;;;;A;;;;A;;;;A;;;;;;A;;;;;;;A;;;;;;;A;;;;A;;;;A;;;;A;;;;A;;;;;;;;;;;;;;;A","sources":["node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/addItemsPopover.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/sortable-list.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/createContextDialog.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/createEntityDialog.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/linkerTemplate.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/linkToEntity.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/linkToSpatialEntity.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/linkToContext.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/previewDialog.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/analyticSteps/inputConfiguration.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/cronHelpDialog.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/analyticSteps/triggerConfiguration.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/analyticSteps/algorithmConfiguration.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/analyticSteps/inputSelectionTable.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/analyticSteps/IODependencies.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/components/analyticSteps/summary.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/createAnalyticDialog.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/dialogs/modifyAnalyticDialog.vue","node_modules/spinal-env-viewer-plugin-analysis/src/vues/panels/linkGroupToAnalytics.vue"],"sourcesContent":["<!--\nCopyright 2020 SpinalCom - www.spinalcom.com\n\nThis file is part of SpinalCore.\n\nPlease read all of the following terms and conditions\nof the Free Software license Agreement (\"Agreement\")\ncarefully.\n\nThis Agreement is a legally binding contract between\nthe Licensee (as defined below) and SpinalCom that\nsets forth the terms and conditions that govern your\nuse of the Program. By installing and/or using the\nProgram, you agree to abide by all the terms and\nconditions stated or referenced herein.\n\nIf you do not agree to abide by these terms and\nconditions, do not demonstrate your acceptance and do\nnot install or use the Program.\nYou should have received a copy of the license along\nwith this file. If not, see\n<http://resources.spinalcom.com/licenses.pdf>.\n-->\n\n<template>\n  <v-popover offset=\"16\"\n             :auto-hide=\"false\"\n             :open=\"show\">\n\n    <md-button class=\"tooltip-target md-fab md-mini md-primary\">\n      <md-icon>add</md-icon>\n    </md-button>\n\n    <template slot=\"popover\">\n      <div class=\"popoverContainer\">\n        <div class=\"_popoverContent\">\n          <md-field>\n            <label>Entity name</label>\n            <md-input v-model=\"name\"></md-input>\n          </md-field>\n\n          <md-field>\n            <label>Entity standard name e.g : Room , Floor etc ...</label>\n            <md-input v-model=\"standard_name\"></md-input>\n          </md-field>\n\n\n          <md-field>\n            <label>Entity type</label>\n            <md-select v-model=\"entityType\">\n              <md-option v-for=\"type in Object.keys(ENTITY_TYPES)\"\n                         :key=\"type\"\n                         :value=\"type\">\n                {{type}}\n              </md-option>\n            </md-select>\n          </md-field>\n\n          \n        </div>\n\n        <div class=\"_popoverBtn\">\n          <md-button class=\"btn md-dense md-primary\"\n                     v-close-popover>Close</md-button>\n\n          <md-button class=\"btn md-dense md-primary\"\n                     :disabled=\"disabled()\"\n                     @click=\"addEntity\"\n                     v-close-popover>ADD</md-button>\n\n        </div>\n      </div>\n\n    </template>\n  </v-popover>\n</template>\n\n<script>\n\nimport { ENTITY_TYPES } from \"spinal-model-analysis\";\n\n\nexport default {\n  name: \"addItemsPopover\",\n  components: {\n\n  },\n  data() {\n    return {\n      ENTITY_TYPES : ENTITY_TYPES,\n      name: \"\",\n      standard_name :\"\",\n      entityType: \"\",\n      show: false,\n    };\n  },\n  methods: {\n    OpenAttribute() {\n      this.show = !this.show;\n    },\n    addEntity() {\n      this.$emit(\"addEntity\", { name: this.name, standard_name: this.standard_name, entityType:ENTITY_TYPES[this.entityType]});\n      this.name = \"\";\n      this.standard_name = \"\";\n      this.entityType = \"\";\n    },\n    disabled() {\n      return this.name.trim().length === 0;\n    },\n  },\n};\n</script>\n\n<style scoped>\n.popoverContainer {\n  width: 350px;\n  height: 300px;\n}\n\n.popoverContainer ._popoverContent {\n  height: 250px;\n}\n\n.popoverContainer ._popoverContent .colorPicker {\n  width: 100%;\n  height: 100px;\n}\n\n.popoverContainer ._popoverBtn {\n  width: 100%;\n  height: 40px;\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n}\n\n.popoverContainer ._popoverBtn .btn {\n  font-size: 15px;\n  margin-right: 10px;\n  cursor: pointer;\n}\n</style>","<!--\nCopyright 2020 SpinalCom - www.spinalcom.com\n\nThis file is part of SpinalCore.\n\nPlease read all of the following terms and conditions\nof the Free Software license Agreement (\"Agreement\")\ncarefully.\n\nThis Agreement is a legally binding contract between\nthe Licensee (as defined below) and SpinalCom that\nsets forth the terms and conditions that govern your\nuse of the Program. By installing and/or using the\nProgram, you agree to abide by all the terms and\nconditions stated or referenced herein.\n\nIf you do not agree to abide by these terms and\nconditions, do not demonstrate your acceptance and do\nnot install or use the Program.\nYou should have received a copy of the license along\nwith this file. If not, see\n<http://resources.spinalcom.com/licenses.pdf>.\n-->\n\n<template>\n  <md-content class=\"myContainer md-scrollbar\">\n    <md-button  class=\"md-dense md-primary\"\n                @click=\"addAllStandardEntities()\">\n                Add all standard entities\n    </md-button>\n    <div class=\"myFabs\">\n      <addItemsPopover @addEntity=\"addEntity\"></addItemsPopover>\n    </div>\n\n\n    <draggable v-if=\"itemsSorted.length > 0\"\n               group=\"entities\"\n               @start=\"drag=true\"\n               @end=\"drag=false\"\n               v-model=\"itemsSorted\">\n      <div class=\"listeItemDraggable\"\n           v-for=\"element in itemsSorted\"\n           :key=\"element.order\">\n        <div class=\"left\">\n          <div class=\"name\">\n            {{element.name}}\n          </div>\n        </div>\n\n        <div class=\"right\">\n          <md-button class=\"md-icon-button md-dense md-accent\"\n                     @click=\"deleteItem(element.order)\">\n            <md-icon>delete_forever</md-icon>\n          </md-button>\n        </div>\n\n      </div>\n    </draggable>\n\n    <div v-else\n         class=\"empty\">\n      No entities created\n    </div>\n\n    \n\n  </md-content>\n</template>\n\n<script>\nimport draggable from \"vuedraggable\";\nimport addItemsPopover from \"./addItemsPopover.vue\";\nexport default {\n  name: \"Sortable-List\",\n  components: { addItemsPopover, draggable },\n  props: {\n    items: { default: [] },\n  },\n  data() {\n    return {\n      itemsSorted: [],\n    };\n  },\n  mounted() {\n    this.itemsSorted = this.items;\n  },\n  methods: {\n    addEntity(res) {\n      res[\"order\"] = this.items.length;\n      this.$emit(\"addEntity\", res);\n    },\n    deleteItem(order) {\n      this.$emit(\"delete\", order);\n    },\n    addAllStandardEntities(){\n      this.$emit(\"addAllStandardEntities\");\n    }\n  },\n  watch: {\n    items() {\n      this.itemsSorted = this.items;\n    },\n  },\n};\n</script>\n\n<style scoped>\n.myContainer {\n  width: 100%;\n  height: 100%;\n  overflow: auto;\n  position: relative;\n}\n\n.myContainer .myFabs {\n  width: 50px;\n  position: absolute;\n  top: 0px;\n  right: 10px;\n}\n\n.myContainer .empty {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.listeItemDraggable {\n  width: 100%;\n  height: 50px;\n  /* background: grey; */\n  border: 1px dashed grey;\n  color: #ffffff;\n  margin-bottom: 5px;\n  margin-top: 5px;\n  display: flex;\n}\n\n.listeItemDraggable .left {\n  flex: 1 1 80%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  font-size: 1.5em;\n}\n\n.listeItemDraggable .right {\n  flex: 1 1 20%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n}\n\n.listeItemDraggable .left .name {\n  margin-left: 10px;\n}\n\n.listeItemDraggable .left .color {\n  height: 100%;\n  width: 10px;\n}\n</style>","<!--\nCopyright 2020 SpinalCom - www.spinalcom.com\n\nThis file is part of SpinalCore.\n\nPlease read all of the following terms and conditions\nof the Free Software license Agreement (\"Agreement\")\ncarefully.\n\nThis Agreement is a legally binding contract between\nthe Licensee (as defined below) and SpinalCom that\nsets forth the terms and conditions that govern your\nuse of the Program. By installing and/or using the\nProgram, you agree to abide by all the terms and\nconditions stated or referenced herein.\n\nIf you do not agree to abide by these terms and\nconditions, do not demonstrate your acceptance and do\nnot install or use the Program.\nYou should have received a copy of the license along\nwith this file. If not, see\n<http://resources.spinalcom.com/licenses.pdf>.\n-->\n\n<template>\n  <md-dialog :md-active.sync=\"showDialog\"\n             @md-closed=\"closeDialog(false)\"\n             class=\"mdDialog\">\n    <md-dialog-title class=\"mdDialogTitle\">Create Analytic context\n    </md-dialog-title>\n\n    <md-dialog-content class=\"mdDialogContainer\">\n\n      <md-steppers :md-active-step.sync=\"stepper.active\"\n                   @md-changed=\"changeStep\"\n                   md-linear\n                   class=\"mySteppers\">\n        <md-step class=\"mdStep\"\n                 :id=\"STEPPERS_DATA.context\"\n                 md-label=\"Context\"\n                 :md-done.sync=\"stepper.first\">\n          <md-content class=\"contents\">\n            <md-field>\n              <label>Context name</label>\n              <md-input v-model=\"inputValue\"\n                        ref=\"nameTextField\"></md-input>\n            </md-field>\n          </md-content>\n\n        </md-step>\n\n        <md-step class=\"mdStep\"\n                 :id=\"STEPPERS_DATA.entities\"\n                 md-label=\"Entities\"\n                 :md-done.sync=\"stepper.second\">\n\n          <sortable-list :items=\"entities\"\n                         ref=\"draggableComponent\"\n                         @addEntity=\"addEntity\"\n                         @delete=\"deleteItem\"\n                         @addAllStandardEntities=\"addAllStandardEntities\"></sortable-list>\n\n        </md-step>\n\n      </md-steppers>\n\n    </md-dialog-content>\n\n    <md-dialog-actions>\n      <md-button class=\"md-primary\"\n                 @click=\"closeDialog(false)\">Close</md-button>\n\n      <md-button class=\"md-primary\"\n                 v-if=\"stepper.active === this.STEPPERS_DATA.context\"\n                 :disabled=\"!(inputValue.trim().length > 0)\"\n                 @click=\"PassToSecondStep\">Next</md-button>\n\n      <md-button v-if=\"stepper.active === this.STEPPERS_DATA.entities\"\n                 :disabled=\"disabledButton()\"\n                 class=\"md-primary\"\n                 @click=\"closeDialog(true)\">Save</md-button>\n    </md-dialog-actions>\n\n  </md-dialog>\n</template>\n\n<script>\n\nimport { spinalAnalyticService , ENTITY_TYPES } from \"spinal-model-analysis\";\n\nimport SortableList from \"./components/sortable-list.vue\";\n\nexport default {\n  name: \"createAnalyticContextDialog\",\n  props: [\"onFinised\"],\n  components: {\n    \"sortable-list\": SortableList,\n  },\n  data() {  \n    this.STEPPERS_DATA = {\n      context: \"first\",\n      entities: \"second\",\n    };\n    return {\n      showDialog: true,\n      inputValue: \"\",\n      entities: [], \n      stepper: {\n        active: this.STEPPERS_DATA.context,\n        first: false,\n        second: false,\n      },\n    };\n  },\n  methods: {\n    opened(option) {\n      this.autoFocusNameInput();\n    },\n\n    async removed(res) {\n      if (res.closeResult){\n        const context = await spinalAnalyticService.createContext(res.inputValue.trim());\n        for (const entity of res.entities){\n          console.log(\"entity :\",entity);\n          const newEntity = {\n            name : entity.name,\n            standard_name: entity.standard_name,\n            entityType: entity.entityType,\n            description:\"\"\n          }\n          const entityInfo = await spinalAnalyticService.addEntity(newEntity,context.id.get());\n        }\n      }\n      this.showDialog = false;\n    },\n    closeDialog(closeResult) {\n      if (typeof this.onFinised === \"function\") {\n        const entities = this.getEntities();\n        this.onFinised({\n          closeResult,\n          inputValue: this.inputValue,\n          entities,\n        });\n      }\n    },\n\n    getEntities() {\n      if (this.$refs.draggableComponent) {\n        const entities = this.$refs.draggableComponent.itemsSorted;\n        return entities.map((el, index) => {\n          el.order = index;\n          return el;\n        });\n      }\n    },\n\n    disabledButton() {\n      const contextCondition = this.inputValue.trim().length === 0;\n      const stepsCondition = this.entities.length === 0;\n      return contextCondition || stepsCondition;\n    },\n\n    autoFocusNameInput() {\n      setTimeout(() => {\n        this.$refs[\"nameTextField\"].$el.focus();\n      }, 200);\n    },\n\n    changeStep(stepId) {\n      if (stepId === this.STEPPERS_DATA.context) {\n        this.stepper.active = stepId;\n        this.stepper.first = false;\n      }\n    },\n\n    PassToSecondStep() {\n      this.stepper.first = true;\n      this.stepper.active = this.STEPPERS_DATA.entities;\n    },\n\n    addEntity(res) {\n      this.entities = [...this.entities, res];\n    },\n\n    deleteItem(order) {\n      this.entities = this.entities.filter((el) => el.order !== order);\n    },\n\n    addAllStandardEntities(){\n      this.entities = [];\n      this.entities = [\n        {name: \"Building\", standard_name: \"Building\", entityType: ENTITY_TYPES.BUILDING, description: \"\",order:0},\n        {name: \"Floor\", standard_name: \"Floor\", entityType: ENTITY_TYPES.FLOOR, description: \"\",order:1},\n        {name: \"Room\", standard_name: \"Room\", entityType: ENTITY_TYPES.ROOM, description: \"\",order:2},\n        {name: \"Equipment\", standard_name: \"Equipment\", entityType: ENTITY_TYPES.EQUIPMENT, description: \"\",order:3},\n        {name: \"Floor Group\", standard_name: \"Floor Group\", entityType: ENTITY_TYPES.FLOOR_GROUP, description: \"\",order:4},\n        {name: \"Room Group\", standard_name: \"Room Group\", entityType: ENTITY_TYPES.ROOM_GROUP, description: \"\",order:5},\n        {name: \"Equipment Group\", standard_name: \"Equipment Group\", entityType: ENTITY_TYPES.EQUIPMENT_GROUP, description: \"\",order:6},\n      ]\n    }\n  },\n};\n</script>\n\n<style scoped>\n/* .dialogForm { \n   display: flex; \n  flex-direction: column; \n } */\n\n.mdDialog {\n  width: 500px;\n  height: 550px;\n}\n\n.mdDialog .mdDialogTitle {\n  text-align: center;\n}\n\n.mdDialog .mdDialogContainer {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\n.mdDialog .mdDialogContainer .mdStep {\n  height: 350px;\n  overflow: hidden;\n  padding: 10px 0px;\n}\n\n.mdDialog .mdDialogContainer .mdStep .contents {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  overflow: auto;\n}\n\n/* .mdDialog .mdDialogContainer .contents.contextName {\n  display: flex;\n  align-items: center;\n}\n\n.mdDialog .mdDialogContainer .actions {\n  width: 100%;\n  height: 50px;\n  display: flex;\n  justify-content: flex-end;\n} */\n</style>\n\n<style>\n.mdDialog .mdDialogContainer .mdStep .md-stepper-content.md-active {\n  width: 100%;\n  height: 100%;\n}\n</style>","<!--\nCopyright 2020 SpinalCom - www.spinalcom.com\n\nThis file is part of SpinalCore.\n\nPlease read all of the following terms and conditions\nof the Free Software license Agreement (\"Agreement\")\ncarefully.\n\nThis Agreement is a legally binding contract between\nthe Licensee (as defined below) and SpinalCom that\nsets forth the terms and conditions that govern your\nuse of the Program. By installing and/or using the\nProgram, you agree to abide by all the terms and\nconditions stated or referenced herein.\n\nIf you do not agree to abide by these terms and\nconditions, do not demonstrate your acceptance and do\nnot install or use the Program.\nYou should have received a copy of the license along\nwith this file. If not, see\n<http://resources.spinalcom.com/licenses.pdf>.\n-->\n\n<template>\n\t<md-dialog\n\t\tclass=\"mdDialogContainer\"\n\t\t:md-active.sync=\"showDialog\"\n\t\t@md-closed=\"closeDialog(false)\"\n\t>\n\t\t<md-dialog-title class=\"dialogTitle\">Create Entity </md-dialog-title>\n\t\t<md-dialog-content class=\"content\">\n\t\t\t<md-field>\n\t\t\t\t<label>Name</label>\n\t\t\t\t<md-input v-model=\"entity.name\"></md-input>\n\t\t\t</md-field>\n\n\t\t\t<md-field>\n\t\t\t\t<label>Standard name</label>\n\t\t\t\t<md-input v-model=\"entity.standard_name\"></md-input>\n\t\t\t</md-field>\n\n\t\t\t<md-field>\n\t\t\t\t<label for=\"entityType\">Entity type</label>\n\t\t\t\t<md-select\n\t\t\t\t\tv-model=\"entity.entityType\"\n\t\t\t\t\tname=\"entityType\"\n\t\t\t\t\tid=\"entityType\"\n\t\t\t\t>\n\t\t\t\t\t<md-option\n\t\t\t\t\t\tv-for=\"data of Object.keys(types)\"\n\t\t\t\t\t\t:key=\"data\"\n\t\t\t\t\t\t:value=\"data\"\n\t\t\t\t\t\t>{{ data }}</md-option\n\t\t\t\t\t>\n\t\t\t\t</md-select>\n\t\t\t</md-field>\n\t\t</md-dialog-content>\n\t\t<md-dialog-actions>\n\t\t\t<md-button class=\"md-primary\" @click=\"closeDialog(false)\"\n\t\t\t\t>Close</md-button\n\t\t\t>\n\t\t\t<md-button\n\t\t\t\tclass=\"md-primary\"\n\t\t\t\t:disabled=\"disabled()\"\n\t\t\t\t@click=\"closeDialog(true)\"\n\t\t\t\t>Save</md-button\n\t\t\t>\n\t\t</md-dialog-actions>\n\t</md-dialog>\n</template>\n\n<script>\n\timport {spinalAnalyticService, ENTITY_TYPES } from \"spinal-model-analysis\"\n\n\texport default {\n\t\tname: \"createEntityDialog\",\n\t\tprops: [\"onFinised\"],\n\t\tdata() {\n\t\t\tthis.types = ENTITY_TYPES;\n\t\t\tthis.contextId;\n\t\t\tthis.groupId;\n\n\t\t\treturn {\n\t\t\t\tshowDialog: true,\n\t\t\t\tentity: {\n\t\t\t\t\tname: \"\",\n\t\t\t\t\tstandard_name:\"\",\n\t\t\t\t\tentityType: \"\",\n\t\t\t\t\tdescription: \"\"\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\n\t\tmethods: {\n\t\t\topened(option) {\n\t\t\t\tconsole.log(option);\n\t\t\t\tthis.contextId = option.selectedNode.id.get();\n\t\t\t\tconsole.log(this.contextId);\n\t\t\t},\n\n\t\t\tasync removed(option) {\n\t\t\t\tif (option) {\n\t\t\t\t\tconst newEntity = {\n\t\t\t\t\t\tname: this.entity.name,\n\t\t\t\t\t\tstandard_name: this.entity.standard_name,\n\t\t\t\t\t\tentityType: this.types[this.entity.entityType],\n\t\t\t\t\t\tdescription: \"\"\n\t\t\t\t\t};\n\t\t\t\t\tconst entityInfo = await spinalAnalyticService.addEntity(newEntity,this.contextId);\n\t\t\t\t}\n\t\t\t\tthis.showDialog = false;\n\t\t\t},\n\n\t\t\tcloseDialog(closeResult) {\n\t\t\t\tif (typeof this.onFinised === \"function\") {\n\t\t\t\t\tthis.onFinised(closeResult);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdisabled() {\n\t\t\t\treturn (\n\t\t\t\t\tthis.entity.name.length === 0 ||\n\t\t\t\t\tthis.entity.entityType === \"\"\n\t\t\t\t);\n\t\t\t},\n\t\t},\n\t};\n</script>\n\n<style scoped>\n\t.mdDialogContainer {\n\t\twidth: 300px;\n\t\theight: 450px;\n\t}\n\n\t.mdDialogContainer .dialogTitle {\n\t\ttext-align: center;\n\t}\n\n\t/* .mdIcon {\n  display: flex;\n  align-items: center;\n} */\n</style>\n","<!--\nCopyright 2020 SpinalCom - www.spinalcom.com\nThis file is part of SpinalCore.\nPlease read all of the following terms and conditions\nof the Free Software license Agreement (\"Agreement\")\ncarefully.\nThis Agreement is a legally binding contract between\nthe Licensee (as defined below) and SpinalCom that\nsets forth the terms and conditions that govern your\nuse of the Program. By installing and/or using the\nProgram, you agree to abide by all the terms and\nconditions stated or referenced herein.\nIf you do not agree to abide by these terms and\nconditions, do not demonstrate your acceptance and do\nnot install or use the Program.\nYou should have received a copy of the license along\nwith this file. If not, see\n<http://resources.spinalcom.com/licenses.pdf>.\n-->\n\n\n<template>\n   <div class=\"subContent\">\n      <md-list class=\"title\">\n\n         <!--<md-list-item> \n          <div class=\"md-list-item-text\">\n          <span>{{title}}</span>\n          <span class=\"md-caption\"\n                v-if=\"subTitle\">{{subTitle}}</span>\n        </div>\n\n        <div class=\"md-layout-item md-size-10 mdIcon\">\n          <md-button class=\"md-icon-button\"\n                     @click=\"createEvent\"\n                     v-if=\"showBtn\">\n            <md-icon>control_point</md-icon>\n          </md-button>\n        </div> \n        </md-list-item>-->\n         <md-list-item>\n            <span class=\"md-list-item-text\">{{title}}</span>\n            <md-button\n               class=\"md-icon-button\"\n               @click=\"createEvent\"\n               v-if=\"showBtn\"\n            >\n               <md-icon>control_point</md-icon>\n            </md-button>\n         </md-list-item>\n\n      </md-list>\n\n      <md-content class=\"container md-scrollbar\">\n         <md-list>\n            <md-list-item\n               class=\"list-item\"\n               v-for=\"(item,index) in data\"\n               :key=\"index\"\n               @click=\"selectItem(item.id)\"\n               :class=\"{'selected' : item.id === itemSelected}\"\n               v-tooltip=\"item.name\"\n            >\n\n               <span class=\"md-list-item-text\">{{item.name}}</span>\n\n            </md-list-item>\n         </md-list>\n      </md-content>\n\n   </div>\n</template>\n\n<script>\nexport default {\n   name: \"linkToGroupTemplate\",\n   props: [\"data\", \"title\", \"itemSelected\", \"showBtn\", \"subTitle\"],\n   methods: {\n      createEvent() {\n         this.$emit(\"create\");\n      },\n      selectItem(id) {\n         this.$emit(\"select\", id);\n      },\n   },\n};\n</script>\n\n<style scoped>\n.subContent {\n   width: 100%;\n   height: 100%;\n}\n.subContent .title {\n   width: 100%;\n   display: flex;\n   justify-content: space-between;\n   align-items: center;\n   padding: 0 15px 0 15px;\n   border-bottom: 1px dashed grey;\n}\n.subContent .container {\n   width: 100%;\n   height: calc(100% - 50px);\n   padding: 0px !important;\n   /* border: 1px solid red; */\n   overflow: hidden;\n   overflow-y: auto;\n}\n.subContent .container .list-item {\n   border-bottom: 1px solid grey;\n}\n\n.subContent .container .list-item .md-list-item-text {\n   width: 100%;\n   display: block;\n   overflow: hidden;\n   white-space: nowrap;\n   text-overflow: ellipsis;\n}\n\n.subContent .container .list-item.selected {\n   background-color: #448aff;\n}\n</style>","<template>\n   <md-dialog\n      class=\"mdDialogContainer\"\n      :md-active.sync=\"visible\"\n    >\n      <md-dialog-title class=\"dialogTitle\">Link to Group</md-dialog-title>\n      <md-dialog-content class=\"content\">\n   \n\n         <div class=\"section\">\n            <link-template\n               :title=\"'Contexts'\"\n               :data=\"data\"\n               :itemSelected=\"contextSelected\"\n               @select=\"selectContext\"\n            ></link-template>\n         </div>\n\n         <div class=\"section\">\n            <link-template\n               :title=\"'Categories'\"\n               :data=\"categories\"\n               :itemSelected=\"categorySelected\"\n               @select=\"selectCategory\"\n               :disableBtn=\"!contextSelected\"\n            ></link-template>\n\n         </div>\n\n         <div class=\"section\">\n            <link-template\n               :title=\"'Groups'\"\n               :data=\"groups\"\n               :itemSelected=\"groupSelected\"\n               @select=\"selectGroup\"\n               :disableBtn=\"!categorySelected\"\n            ></link-template>\n         </div>\n      </md-dialog-content>\n      <md-dialog-actions>\n         <md-button\n            class=\"md-primary\"\n            @click=\"closeDialog(false)\"\n         >Close</md-button>\n         <md-button\n            class=\"md-primary\"\n            :disabled=\"disabled()\"\n            @click=\"closeDialog(true)\"\n         >Save</md-button>\n      </md-dialog-actions>\n   </md-dialog>\n\n</template>\n\n<script>\nimport attributeService from \"../../../services/index\";\n\n\nimport { spinalPanelManagerService } from \"spinal-env-viewer-panel-manager-service\";\nimport { SpinalGraphService } from \"spinal-env-viewer-graph-service\";\n\nimport linkToGroupTemplate from \"./linkerTemplate.vue\";\n\nexport default {\n   name: \"dialogComponent\",\n   components: {\n      \"link-template\": linkToGroupTemplate,\n   },\n   props: [\"visible\",\"entityType\"],\n   data() {\n      return {\n         showDialog: true,\n         data: [],\n         groups: [],\n         categories: [],\n         contextSelected: undefined,\n         categorySelected: undefined,\n         groupSelected: undefined,\n         items: [],\n         type: undefined,\n         callback: undefined,\n      };\n   },\n\n   mounted() {\n      this.type = this.entityType + \"Context\";\n      this.getAllData();\n   \n   },\n\n   methods: {\n\n      closeDialog(closeResult) {\n         if(!closeResult) {\n            this.$emit(\"closeSelection\", undefined);\n         }\n         else {\n            this.$emit(\"closeSelection\",this.groupSelected)\n         }\n         \n      },\n   \n      getAllData() {\n         attributeService.getAllGroupContext(this.type).then((res) => {\n            this.data = res;\n            this.updateCategory();\n            this.updateGroups();\n         });\n      },\n      \n      getGroups() {\n         this.groupSelected = undefined;\n\n         if (this.contextSelected && this.categorySelected) {\n            let context = this.data.find(\n               (el) => el.id === this.contextSelected\n            );\n            if (context) {\n               let category = context.category.find(\n                  (el) => el.id == this.categorySelected\n               );\n\n               if (category) return category.groups;\n            }\n         }\n         return [];\n      },\n\n      disabled() {\n         return !(\n            this.contextSelected &&\n            this.categorySelected &&\n            this.groupSelected\n         );\n      },\n\n      //////////////////////////////////////////////////////////////////\n      // Modify\n      //////////////////////////////////////////////////////////////////\n\n      updateCategory() {\n         // this.categorySelected = undefined;\n         this.categories = [];\n         if (this.contextSelected) {\n            let val = this.data.find((el) => el.id === this.contextSelected);\n            if (val) this.categories = val.category;\n         }\n      },\n\n      updateGroups() {\n         // this.groupSelected = undefined;\n         this.groups = [];\n         if (this.contextSelected && this.categorySelected) {\n            let context = this.data.find(\n               (el) => el.id === this.contextSelected\n            );\n            if (context) {\n               let category = context.category.find(\n                  (el) => el.id == this.categorySelected\n               );\n\n               if (category) this.groups = category.groups;\n            }\n         }\n      },\n\n      selectContext(id) {\n         this.contextSelected = id;\n      },\n\n      selectCategory(id) {\n         this.categorySelected = id;\n      },\n\n      selectGroup(id) {\n         this.groupSelected = id;\n      },\n   },\n   watch: {\n      contextSelected() {\n         this.categorySelected = undefined;\n         this.groupSelected = undefined;\n\n         this.updateCategory();\n         this.updateGroups();\n      },\n\n      categorySelected() {\n         this.groupSelected = undefined;\n\n         this.updateGroups();\n      },\n   },\n};\n</script>\n\n<style scoped>\n.mdDialogContainer {\n   transform: translate(-50%,-50%) scale(1) !important;\n   z-index: 1000 !important;\n   width: 100%;\n   height: 600px;\n}\n\n.mdDialogContainer .dialogTitle {\n   text-align: center;\n}\n\n.mdDialogContainer .content {\n   display: flex;\n   justify-content: space-between;\n   align-items: stretch;\n}\n\n.mdDialogContainer .content .section {\n   width: 30%;\n   border: 1px solid grey;\n   border-radius: 4% 4% 0 0;\n   padding: 15px;\n}\n\n/* .mdIcon {\n  display: flex;\n  align-items: center;\n} */\n</style>\n\n<style>\n.mdDialogContainer .md-dialog-container {\n   max-width: 100%;\n   max-height: 100%;\n}\n</style>","<!--\nCopyright 2020 SpinalCom - www.spinalcom.com\n\nThis file is part of SpinalCore.\n\nPlease read all of the following terms and conditions\nof the Free Software license Agreement (\"Agreement\")\ncarefully.\n\nThis Agreement is a legally binding contract between\nthe Licensee (as defined below) and SpinalCom that\nsets forth the terms and conditions that govern your\nuse of the Program. By installing and/or using the\nProgram, you agree to abide by all the terms and\nconditions stated or referenced herein.\n\nIf you do not agree to abide by these terms and\nconditions, do not demonstrate your acceptance and do\nnot install or use the Program.\nYou should have received a copy of the license along\nwith this file. If not, see\n<http://resources.spinalcom.com/licenses.pdf>.\n-->\n\n<template>\n  <md-dialog\n    class=\"mdDialogContainer\"\n    :md-active.sync=\"visible\"\n  >\n    <md-dialog-title class=\"dialogTitle\"\n      >Link to {{ this.entityType }}</md-dialog-title\n    >\n    <md-dialog-content class=\"content\">\n      <div class=\"section\">\n        <link-template\n          :title=\"'Buildings'\"\n          :data=\"data\"\n          :itemSelected=\"buildingSelected\"\n          @select=\"selectBuilding\"\n        ></link-template>\n      </div>\n\n      <div class=\"section\" v-if=\"this.entityType != 'geographicBuilding'\">\n        <link-template\n          :title=\"'Floors'\"\n          :data=\"floors\"\n          :itemSelected=\"floorSelected\"\n          @select=\"selectFloor\"\n          :disableBtn=\"!buildingSelected\"\n        ></link-template>\n      </div>\n\n      <div class=\"section\" v-if=\"this.entityType == 'geographicRoom'\">\n        <link-template\n          :title=\"'Rooms'\"\n          :data=\"rooms\"\n          :itemSelected=\"roomSelected\"\n          @select=\"selectRoom\"\n          :disableBtn=\"!floorSelected\"\n        ></link-template>\n      </div>\n    </md-dialog-content>\n    <md-dialog-actions>\n      <md-button class=\"md-primary\" @click=\"closeDialog(false)\"\n        >Close</md-button\n      >\n      <md-button\n        class=\"md-primary\"\n        :disabled=\"!buildingSelected\"\n        @click=\"closeDialog(true)\"\n        >Save</md-button\n      >\n    </md-dialog-actions>\n  </md-dialog>\n</template>\n\n<script>\nimport attributeService from '../../../services/index';\n\nimport { spinalPanelManagerService } from 'spinal-env-viewer-panel-manager-service';\nimport { SpinalGraphService } from 'spinal-env-viewer-graph-service';\n\nimport linkToGroupTemplate from './linkerTemplate.vue';\n\nexport default {\n  name: 'spatialSelectComponent',\n  components: {\n    'link-template': linkToGroupTemplate,\n  },\n  props: ['visible', 'entityType'],\n  data() {\n    return {\n      showDialog: true,\n      data: [],\n      rooms: [],\n      floors: [],\n      buildingSelected: undefined,\n      floorSelected: undefined,\n      roomSelected: undefined,\n\n      items: [],\n      spatialContextId: undefined,\n    };\n  },\n\n  mounted() {\n    this.getAllData();\n    this.spatialContextId =\n      SpinalGraphService.getContext('spatial').info.id.get();\n  },\n\n  methods: {\n\n    closeDialog(closeResult) {\n      if (!closeResult) {\n        this.$emit('closeSelection', undefined);\n      } else {\n          if(this.roomSelected){\n            this.$emit('closeSelection', this.roomSelected); \n            return;   \n          }\n          if(this.floorSelected){\n            this.$emit('closeSelection', this.floorSelected);\n            return;\n          }\n          if(this.buildingSelected){\n            this.$emit('closeSelection', this.buildingSelected);\n            return;\n          }\n            \n        \n      }\n    },\n\n    getAllData() {\n      attributeService.getAllSpatialBuildings().then((res) => {\n        this.data = res;\n        //this.updateCategory();\n        //this.updateGroups();\n      });\n    },\n\n    updateCategory() {\n      // this.floorSelected = undefined;\n      this.floors = [];\n      if (this.buildingSelected) {\n        SpinalGraphService.findInContextByType(\n          this.buildingSelected,\n          this.spatialContextId,\n          'geographicFloor'\n        ).then((res) => {\n          this.floors = res;\n        });\n      }\n    },\n\n    updateGroups() {\n      // this.roomSelected = undefined;\n      this.rooms = [];\n      if (this.floorSelected) {\n        SpinalGraphService.findInContextByType(\n          this.floorSelected,\n          this.spatialContextId,\n          'geographicRoom'\n        ).then((res) => {\n          this.rooms = res;\n        });\n      }\n    },\n\n    selectBuilding(id) {\n      console.log('select building ', id);\n      this.buildingSelected = id;\n      this.floorSelected = undefined;\n      this.roomSelected = undefined;\n    },\n\n    selectFloor(id) {\n      console.log('select floor ', id);\n      this.floorSelected = id;\n      this.roomSelected = undefined;\n    },\n\n    selectRoom(id) {\n      console.log('select room ', id);\n      this.roomSelected = id;\n    },\n  },\n  watch: {\n    buildingSelected() {\n      this.floorSelected = undefined;\n      this.roomSelected = undefined;\n\n      this.updateCategory();\n      this.updateGroups();\n    },\n\n    floorSelected() {\n      this.roomSelected = undefined;\n\n      this.updateGroups();\n    },\n  },\n};\n</script>\n\n<style scoped>\n.mdDialogContainer {\n  transform: translate(-50%, -50%) scale(1) !important;\n  z-index: 1000 !important;\n  width: 100%;\n  height: 600px;\n}\n\n.mdDialogContainer .dialogTitle {\n  text-align: center;\n}\n\n.mdDialogContainer .content {\n  display: flex;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n\n.mdDialogContainer .content .section {\n  flex: 1;\n  border: 1px solid grey;\n  border-radius: 4% 4% 0 0;\n  padding: 15px;\n}\n\n/* .mdIcon {\n  display: flex;\n  align-items: center;\n} */\n</style>\n\n<style>\n.mdDialogContainer .md-dialog-container {\n  max-width: 100%;\n  max-height: 100%;\n}\n</style>\n","<!--\nCopyright 2020 SpinalCom - www.spinalcom.com\n\nThis file is part of SpinalCore.\n\nPlease read all of the following terms and conditions\nof the Free Software license Agreement (\"Agreement\")\ncarefully.\n\nThis Agreement is a legally binding contract between\nthe Licensee (as defined below) and SpinalCom that\nsets forth the terms and conditions that govern your\nuse of the Program. By installing and/or using the\nProgram, you agree to abide by all the terms and\nconditions stated or referenced herein.\n\nIf you do not agree to abide by these terms and\nconditions, do not demonstrate your acceptance and do\nnot install or use the Program.\nYou should have received a copy of the license along\nwith this file. If not, see\n<http://resources.spinalcom.com/licenses.pdf>.\n-->\n\n<template>\n  <md-dialog class=\"mdDialogContainer\" :md-active.sync=\"visible\">\n    <md-dialog-title class=\"dialogTitle\">Link to context</md-dialog-title>\n    <md-dialog-content class=\"content\">\n      <div class=\"section\">\n        <link-template\n          :title=\"'Contexts'\"\n          :data=\"data\"\n          :itemSelected=\"contextSelected\"\n          @select=\"selectContext\"\n        ></link-template>\n      </div>\n    </md-dialog-content>\n    <md-dialog-actions>\n      <md-button class=\"md-primary\" @click=\"closeDialog(false)\"\n        >Close</md-button\n      >\n      <md-button\n        class=\"md-primary\"\n        :disabled=\"!contextSelected\"\n        @click=\"closeDialog(true)\"\n        >Save</md-button\n      >\n    </md-dialog-actions>\n  </md-dialog>\n</template>\n\n<script>\nimport attributeService from '../../../services/index';\n\nimport linkToGroupTemplate from './linkerTemplate.vue';\n\nexport default {\n  name: 'spatialSelectComponent',\n  components: {\n    'link-template': linkToGroupTemplate,\n  },\n  props: ['visible', 'entityType'],\n  data() {\n    return {\n      showDialog: true,\n      data: [],\n      contextSelected: undefined,\n      items: [],\n    };\n  },\n\n  mounted() {\n    this.getAllData();\n  },\n\n  methods: {\n    closeDialog(closeResult) {\n      if (!closeResult) {\n        this.$emit('closeSelection', undefined);\n      } else {\n        this.$emit('closeSelection', this.contextSelected);\n      }\n    },\n\n    getAllData() {\n      attributeService.getAllContexts().then((res) => {\n        this.data = res;\n      });\n    },\n\n    //////////////////////////////////////////////////////////////////\n    // Modify\n    //////////////////////////////////////////////////////////////////\n\n    selectContext(id) {\n      console.log('select context ', id);\n      this.contextSelected = id;\n    },\n  },\n  watch: {\n    // buildingSelected() {\n    //   this.floorSelected = undefined;\n    //   this.roomSelected = undefined;\n    //   this.updateCategory();\n    //   this.updateGroups();\n    // },\n    // floorSelected() {\n    //   this.roomSelected = undefined;\n    //   this.updateGroups();\n    // },\n  },\n};\n</script>\n\n<style scoped>\n.mdDialogContainer {\n  transform: translate(-50%, -50%) scale(1) !important;\n  z-index: 1000 !important;\n  width: 100%;\n  height: 600px;\n}\n\n.mdDialogContainer .dialogTitle {\n  text-align: center;\n}\n\n.mdDialogContainer .content {\n  display: flex;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n\n.mdDialogContainer .content .section {\n  flex: 1;\n  border: 1px solid grey;\n  border-radius: 4% 4% 0 0;\n  padding: 15px;\n}\n\n/* .mdIcon {\n  display: flex;\n  align-items: center;\n} */\n</style>\n\n<style>\n.mdDialogContainer .md-dialog-container {\n  max-width: 100%;\n  max-height: 100%;\n}\n</style>\n","<template>\n  <div>\n    <md-dialog\n      :md-click-outside-to-close=\"false\"\n      :md-close-on-esc=\"false\"\n      class=\"mdDialog\"\n      :md-active.sync=\"visible\"\n    >\n      <md-dialog-title>Preview captured data</md-dialog-title>\n      \n      <md-content class=\"content md-scrollbar\">\n        <div class=\"json-preview\">\n          <pre>{{ data }}</pre>\n        </div>\n      </md-content>\n\n      <md-dialog-actions>\n        <md-button class=\"md-primary\" @click=\"close\">Close</md-button>\n      </md-dialog-actions>\n    </md-dialog>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'previewDialog',\n  props: {\n    visible: {\n      type: Boolean,\n      required: true,\n    },\n    data: {\n      type: String,\n      required: true,\n    },\n  },\n  data: () => ({}),\n  methods: {\n    close() {\n      this.$emit('closeDialog');\n    },\n  },\n};\n</script>\n\n<style scoped>\n.mdDialog {\n  transform: translate(-50%, -50%) scale(1) !important;\n  z-index: 1000 !important;\n}\n.content {\n  max-height: 400px;\n  width: 700px;\n  overflow-y: auto;\n}\n.json-preview {\n  margin: 20px;\n  background-color: #1e1e1e;\n  border: 2px solid #3a3a3a;\n  border-radius: 8px;\n  padding: 20px;\n  color: #ffffff;\n  font-family: monospace;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n}\n\n.json-preview pre {\n  margin: 10px;\n}\n</style>\n","<template>\n  <md-step\n    class=\"mdStep\"\n    :id=\"STEPPERS_DATA.inputConfiguration\"\n    md-label=\"Inputs\"\n    :md-done.sync=\"stepper.third\"\n  >\n    <md-content class=\"contents md-scrollbar\">\n      <p>Each tracking method is an input for an algorithm</p>\n      <p>\n        The <b>search depth</b> is how deep the program should search for the tracked item. If 0, only the infered followed entities of\n        the anchor will be considered.\n      </p>\n      <p>\n        If the <b>strict depth</b> is true, the program will only consider the items found at exactly the given depth.\n      </p>\n      <p>\n        The <b>search relations</b> are the relations that the program is allowed to use to find the tracked item.\n      </p>\n      <p>\n        Timeseries interval time is how far in the past should the analytic gather data. Must be positive or null. If\n        null (equal 0), only the currentValue will be picked, otherwise, the\n        data will be picked from the current time at which the analytic will be\n        run to (currentTime - intervalTime). Beware, if the interval time > 0,\n        make sure the control-endpoint/ endpoint has timeseries.\n      </p>\n      <div v-for=\"([inputName, value]) in Object.entries(localInputs)\" :key=\"inputName\" class=\"trackingMethodBlock\">\n\n        <b>Input {{inputName}}</b>\n        <md-field class=\"fixed-size-field\">\n          <label>Tracking Method</label>\n          <md-select v-model=\"value.trackingMethod\">\n            <md-option\n              v-for=\"data of TRACK_METHOD\"\n              :key=\"data\"\n              :value=\"data\"\n            >{{ data }}</md-option\n            >\n          </md-select>\n        </md-field>\n        <md-field class=\"fixed-size-field\"  v-if=\"value.trackingMethod != ''\">\n          <label> Search Depth </label>\n          <md-input type=\"number\" min=\"0\" v-model=\"value.searchDepth\"></md-input>\n        </md-field>\n        <md-button\n          class=\"md-primary\"\n          :disabled=\"isShowAvailableDataDisabled(value)\"\n          @click=\"scanRelations(value)\"\n        >\n          Scan relations\n        </md-button>\n  \n        <md-button\n          class=\"md-primary\"\n          :disabled=\"isShowAvailableDataDisabled(value)\"\n          @click=\"getPreviewAvailableData(value)\"\n        >\n          Show available data\n        </md-button>\n\n        <md-field class=\"fixed-size-field\"  v-if=\"value.trackingMethod != '' && value.searchDepth>0\" >\n          <label> \n            Search Relations separated by comma (example: hasBimObject,relation2,... )\n          </label>\n          <md-input v-model=\"value.searchRelations\"></md-input>\n        </md-field>\n        \n\n        <md-field class=\"fixed-size-field\"  v-if=\"value.trackingMethod != ''\">\n          <label> Filter Value ( Case sensitive )</label>\n          <md-input v-model=\"value.filterValue\"></md-input>\n        </md-field>\n\n        <md-switch v-if=\"value.trackingMethod != '' && value.searchDepth >0\"\n          v-model=\"value.strictDepth\"\n        >Data must be found at exactly depth {{value.searchDepth}} : <b> {{value.strictDepth ? 'Yes' : 'No'}} </b> \n        </md-switch>\n\n        \n\n        <md-field class=\"fixed-size-field\"  v-if=\"showTimeSeriesField(value)\">\n          <label> Timeseries interval time ( 0 to only take current value )</label>\n          <md-input type=\"number\" min=\"0\" v-model=\"value.timeseriesIntervalTime\"></md-input>\n        </md-field>\n        \n        <md-button\n          class=\"md-primary\"\n          :disabled=\"isPreviewDisabled(value)\"\n          @click=\"getPreviewData(value)\"\n        >\n          Preview input\n        </md-button>\n        <md-button\n          class=\"md-accent\"\n          @click=\"removeInput(inputName)\">\n          Remove\n        </md-button>\n        \n      </div>\n\n      <md-button\n        class=\"md-primary\"\n        @click=\"addInput\"\n      >\n        Add Input\n      </md-button>\n\n      <!--     \n      <md-button\n        class=\"md-primary\"\n        :disabled=\"isGlobalPreviewDisabled\"\n        @click=\"getGlobalPreviewData()\"\n      >\n      Preview All inputs\n      </md-button> -->\n    </md-content>\n    <preview-dialog\n      :visible=\"showPreviewDialog\"\n      :data=\"prettyData\"\n      @closeDialog=\"closePreviewDialog\"\n    >\n    </preview-dialog>\n  </md-step>\n</template>\n\n<script>\nimport { TRACK_METHOD, spinalAnalyticService, ATTRIBUTE_VALUE_SEPARATOR,\n getChoiceRelationsWithDepth, getAvailableData } from 'spinal-model-analysis';\nimport { SpinalGraphService } from 'spinal-env-viewer-graph-service';\nimport previewDialogVue from '../previewDialog.vue';\n\nexport default {\n  props: ['STEPPERS_DATA', 'stepper','entityType','followedEntity'\n  ,'inputs' ],\n  components: {\n    'preview-dialog': previewDialogVue,\n  },\n  data() {\n    return {\n        localInputs : this.inputs,\n        showPreviewDialog:false,\n        previewData: '',\n        scannedRelations:'',\n      \n    };\n  },\n  created() {\n    this.TRACK_METHOD = TRACK_METHOD;\n  },\n  methods: {\n    \n    addInput() {\n      console.log('clicked on button add input');\n      this.$emit('addInput');\n    },\n    removeInput(index){\n      this.$emit('removeInput',index);\n    },\n\n    async getCapturedInputs(tracking,entity){\n      console.log('Calling getCapturedInputs tracking:' ,tracking)\n      const capturedInput =\n          await spinalAnalyticService.applyTrackingMethodWithParams(\n            entity,\n            tracking.trackingMethod,\n            tracking.filterValue,\n            tracking.searchDepth,\n            tracking.strictDepth,\n            tracking.searchRelations.split(ATTRIBUTE_VALUE_SEPARATOR)\n          );\n        if (!capturedInput) return \"!! Not found !!\";\n        console.log('capturedInput :', capturedInput);\n        if(tracking.trackingMethod === this.TRACK_METHOD.ATTRIBUTE_NAME_FILTER){\n          if (Array.isArray(capturedInput)) return capturedInput;\n          return capturedInput.label.get();\n        }\n        if(Array.isArray(capturedInput)) return capturedInput.map(el => el.name.get());\n        return capturedInput.name.get();\n    },\n\n    async scanRelations(tracking){\n      this.showPreviewDialog = true;\n      this.previewData = '';\n      console.log('Calling scanRelations');\n      \n      const followedEntityInfo = SpinalGraphService.getInfo(\n        this.followedEntity\n      );\n      const previewData = {};\n      const entities  = await spinalAnalyticService.getWorkingFollowedEntitiesWithParam(followedEntityInfo,this.entityType);\n      for (const subEntity of entities) {\n        let subEntityName = subEntity.name.get();\n        subEntityName = subEntityName.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n        const relations = await getChoiceRelationsWithDepth(subEntity.id.get(),tracking.searchDepth);\n        previewData[subEntityName] = relations;\n      }\n      this.previewData = previewData;\n\n    },\n\n    async getPreviewAvailableData(tracking){\n      this.showPreviewDialog = true;\n      this.previewData = '';\n      console.log('Calling getPreviewAvailableData');\n      const followedEntityInfo = SpinalGraphService.getInfo(\n        this.followedEntity\n      );\n      const entities  = await spinalAnalyticService.getWorkingFollowedEntitiesWithParam(followedEntityInfo,this.entityType);\n      const previewData = {};\n      for (const subEntity of entities) {\n        let subEntityName = subEntity.name.get();\n        subEntityName = subEntityName.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n        const availableData = await getAvailableData(\n          tracking.trackingMethod,\n          subEntity.id.get(),\n          tracking.filterValue,\n          tracking.searchDepth,\n          tracking.strictDepth,\n          tracking.searchRelations.split(ATTRIBUTE_VALUE_SEPARATOR));\n        previewData[subEntityName] = availableData;\n      }\n      this.previewData = previewData;\n    },\n\n    async getPreviewData(tracking){\n      this.showPreviewDialog = true;\n      this.previewData = '';\n      console.log('Calling getPreviewData');\n      const followedEntityInfo = SpinalGraphService.getInfo(\n        this.followedEntity\n      );\n      const entities  = await spinalAnalyticService.getWorkingFollowedEntitiesWithParam(followedEntityInfo,this.entityType);\n      const previewData = {};\n      for (const subEntity of entities) {\n        let subEntityName = subEntity.name.get();\n        subEntityName = subEntityName.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n        const capturedInputs = await this.getCapturedInputs(tracking,subEntity);\n        previewData[subEntityName] = capturedInputs;\n      }\n      \n      //this.previewData = JSON.stringify(previewData, null, 2);\n      this.previewData = previewData;\n\n    },\n    \n    /*async getPreviewData2(tracking) {\n      this.showPreviewDialog = true;\n      this.previewData = '';\n      console.log('Calling getPreviewData');\n\n      const followedEntityInfo = SpinalGraphService.getInfo(\n        this.followedEntity\n      );\n\n      let followedEntityName = followedEntityInfo.name.get();\n      followedEntityName = followedEntityName.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\n      const previewData = { [followedEntityName]: {} };\n\n      if (this.entityType === followedEntityInfo.type.get()) {\n        const capturedInputs = await this.getCapturedInputs(tracking,followedEntityInfo);\n        previewData[followedEntityName] = capturedInputs;\n      } else {\n        const isGroup = followedEntityInfo.type.get().includes('Group');\n        let subEntities;\n        if (isGroup) {\n          const relationNameToSubEntities = 'groupHas' + this.entityType;\n          subEntities = await SpinalGraphService.getChildren(\n            followedEntityInfo.id.get(),\n            [relationNameToSubEntities]\n          );\n        } else {\n          console.log('Getting sub entities through spatial context');\n          const spatialContextId = SpinalGraphService.getContext('spatial').info.id.get();\n          subEntities = await SpinalGraphService.findInContextByType(\n          this.followedEntity,\n          spatialContextId,\n          this.entityType\n          );\n        }\n\n        await this.updatePreviewData(tracking,subEntities, followedEntityName, previewData);\n      }\n\n      console.log('previewData :', previewData);\n      //this.previewData = JSON.stringify(previewData, null, 2);\n      this.previewData = previewData;\n    },*/\n\n\n    closePreviewDialog(){\n      this.showPreviewDialog = false;\n    },\n\n    isPreviewDisabled(tracking) {\n      return (\n        !this.followedEntity ||\n        tracking.trackingMethod === ''\n        || tracking.filterValue === ''\n      );\n    },\n    isShowAvailableDataDisabled(tracking) {\n      return (\n        !this.followedEntity ||\n        tracking.trackingMethod === ''\n      );\n    },\n    showTimeSeriesField(tracking) {\n      return  (tracking.trackingMethod === this.TRACK_METHOD.ENDPOINT_NAME_FILTER ||\n       tracking.trackingMethod === this.TRACK_METHOD.CONTROL_ENDPOINT_NAME_FILTER);\n    },\n\n  },\n  computed: {\n    isGlobalPreviewDisabled() {\n      return (\n        true);\n    },\n    \n\n    followedEntityName() {\n      if (!this.followedEntity) return '';\n      const info = SpinalGraphService.getInfo(this.followedEntity);\n      console.log(info);\n      return `${info.name.get()} | Type : ${info.type.get()} | Node id : ${info.id.get()}`;\n    },\n    prettyData() {\n      return JSON.stringify(this.previewData, null, 2);\n    },\n  },\n\n  watch:{\n    inputs(){\n      console.log('parent inputs changed')\n      this.localInputs = this.inputs;\n    }\n  }\n};\n</script>\n\n<style scoped>\n.trackingMethodBlock {\n  border: 2px dashed #ffffff;\n  padding: 10px;\n  margin-bottom: 10px;\n  width: 90%;\n}\n\n\n</style>\n\n","<template>\n  <md-dialog\n    :md-click-outside-to-close=\"false\"\n    :md-close-on-esc=\"false\"\n    class=\"mdDialog\"\n    :md-active.sync=\"showCronHelpModal\"\n  >\n    <md-dialog-title>Cron Pattern Guide</md-dialog-title>\n    <md-dialog-content>\n      <p\n        >This guide will help you understand how to create cron patterns for\n        scheduling tasks. A cron pattern is composed of five fields separated by a blank space: (minute) (hour) (day of the month) (month) (day of the week)</p\n      >\n      <ul>\n        <li><strong>Minute</strong> (0 - 59)</li>\n        <li><strong>Hour</strong> (0 - 23)</li>\n        <li><strong>Day of the Month</strong> (1 - 31)</li>\n        <li><strong>Month</strong> (1 - 12 or JAN - DEC)</li>\n        <li\n          ><strong>Day of the Week</strong> (0 - 7, where 0 or 7 is Sunday, or\n          SUN - SAT)</li\n        >\n      </ul>\n      <p>A field may be an asterisk (*), which always stands for first-last</p>\n\n      <p\n        >Ranges of numbers are allowed. Ranges are two numbers separated with a\n        hyphen. The specified range is inclusive. For example, 8-11 for an\n        ''hour'' entry specifies execution at hours 8, 9, 10 and 11.</p\n      >\n\n      <p\n        >Lists are allowed.  A list is a set of numbers (or ranges)\n             separated by commas.  Examples: ``1,2,5,9'', ``0-4,8-12''.</p\n      >\n\n      <p>Here are some common examples:</p>\n      <ul>\n        <li><code>0 * * * *</code> - Every hour at the start of the hour.</li>\n        <li><code>30 9 * * 1</code> - Every Monday at 9:30 AM.</li>\n        <li\n          ><code>0 0 1 * *</code> - The first day of every month at\n          midnight.</li\n        >\n      </ul>\n    </md-dialog-content>\n    <md-dialog-actions>\n      <md-button class=\"md-primary\" @click=\"closeDialog()\">Close</md-button>\n    </md-dialog-actions>\n  </md-dialog>\n</template>\n\n<script>\nexport default {\n  props: ['showCronHelpModal'],\n  data() {\n    return {};\n  },\n  methods: {\n    closeDialog() {\n      this.$emit('closeCronHelpDialog');\n    },\n  },\n};\n</script>\n\n<style scoped>\n.mdDialog {\n  z-index: 1000 !important;\n  width: 100%;\n  padding: 20px;\n  border-radius: 10px;\n}\n\n.md-dialog-content ul {\n  padding-left: 20px;\n  list-style-type: disc;\n}\n.md-dialog-content code {\n  background-color: #e5e5e5;\n  margin-bottom: 5px;\n  padding: 2px 4px;\n  border-radius: 4px;\n  font-family: monospace;\n}\n</style>\n","<template>\n  <md-step\n    class=\"mdStep\"\n    :id=\"STEPPERS_DATA.triggerConfiguration\"\n    md-label=\"Triggers\"\n    :md-done.sync=\"stepper.fourth\"\n  >\n    <md-content class=\"contents md-scrollbar\">\n      <p>\n        A trigger is a condition that must be met for the analytic to be\n        executed. For exemple you can bind on one of the inputs to execute the\n        analytic when the value of the input is changed. Or you can add a time\n        based trigger that will make the analytic execute every 20000 ms ( 20s\n        ).\n      </p>\n\n      <div\n        v-for=\"[triggerName, value] in Object.entries(localTriggers)\"\n        :key=\"triggerName\"\n        class=\"block\"\n      >\n        <b>Trigger {{ triggerName }}</b>\n        <md-field class=\"fixed-size-field\">\n          <label>Trigger type</label>\n          <md-select\n            v-model=\"value.triggerType\"\n            @md-selected=\"resetInfo(value)\"\n          >\n            <md-option v-for=\"data of TRIGGER_TYPE\" :key=\"data\" :value=\"data\">{{\n              data\n            }}</md-option>\n          </md-select>\n        </md-field>\n\n        <md-field\n          class=\"fixed-size-field\"\n          v-if=\"value.triggerType == TRIGGER_TYPE.INTERVAL_TIME\"\n        >\n          <label> Interval time value (ms) </label>\n          <md-input\n            type=\"number\"\n            min=\"0\"\n            v-model=\"value.triggerValue\"\n          ></md-input>\n        </md-field>\n        <md-field\n          class=\"fixed-size-field\"\n          v-if=\"showInputSelection(value.triggerType)\"\n        >\n          <label\n            >Input selection (which input do you want to use for change of value\n            tracking)</label\n          >\n          <md-select v-model=\"value.triggerValue\">\n            <md-option\n              v-for=\"data of Object.keys(inputs)\"\n              :key=\"data\"\n              :value=\"data\"\n              >{{ data }}</md-option\n            >\n          </md-select>\n        </md-field>\n        <md-field\n          class=\"fixed-size-field\"\n          v-if=\"\n            value.triggerType == TRIGGER_TYPE.CHANGE_OF_VALUE_WITH_THRESHOLD\n          \"\n        >\n          <label>\n            Threshold value (any change greater than treshold value will trigger\n            analytic)\n          </label>\n          <md-input\n            type=\"number\"\n            min=\"0\"\n            v-model=\"value.changeOfValueThreshold\"\n          ></md-input>\n        </md-field>\n\n        <div v-if=\"value.triggerType == TRIGGER_TYPE.CRON\" >\n          \n          <md-button class=\"md-primary\" @click=\"showCronHelper\"> Need help ?\n            <md-icon class=\"help-icon\" @click=\"showCronHelper\"\n              >help</md-icon\n            >\n          </md-button>\n          <md-field\n            class=\"fixed-size-field\"\n            \n          >\n            <label> Cron pattern </label>\n            <md-input\n              v-model=\"value.triggerValue\"\n              placeholder=\"* * * * *\"\n            ></md-input>\n            \n          </md-field>\n        </div>\n        \n\n        <md-button class=\"md-accent\" @click=\"removeTrigger(triggerName)\">\n          Remove\n        </md-button>\n      </div>\n\n      <md-button class=\"md-primary\" @click=\"addTrigger\">\n        Add Trigger\n      </md-button>\n      <cron-help-dialog\n          :showCronHelpModal=\"showCronHelpModal\"\n          @closeCronHelpDialog=\"showCronHelpModal = false\"\n        ></cron-help-dialog>\n    </md-content>\n  </md-step>\n</template>\n\n<script>\nimport { TRIGGER_TYPE } from 'spinal-model-analysis';\nimport cronHelpDialog from '../cronHelpDialog.vue';\n\nexport default {\n  props: ['STEPPERS_DATA', 'stepper', 'inputs', 'triggers'],\n  components: {\n    'cron-help-dialog':cronHelpDialog,\n  },\n  data() {\n    return {\n      localTriggers: this.triggers,\n      showPreviewDialog: false,\n      showCronHelpModal: false,\n      previewData: '',\n    };\n  },\n  created() {\n    this.TRIGGER_TYPE = TRIGGER_TYPE;\n  },\n  methods: {\n    addTrigger() {\n      console.log('clicked on button add Trigger');\n      this.$emit('addTrigger');\n    },\n    removeTrigger(triggerName) {\n      this.$emit('removeTrigger', triggerName);\n    },\n    showInputSelection(triggerType) {\n      return [\n        TRIGGER_TYPE.CHANGE_OF_VALUE_WITH_THRESHOLD,\n        TRIGGER_TYPE.CHANGE_OF_VALUE,\n      ].includes(triggerType);\n    },\n\n    showCronHelper() {\n      this.showCronHelpModal = true;\n      console.log('showCronHelper : ', this.showCronHelpModal);\n    },\n\n    resetInfo(triggerInfo) {\n      console.log('reset info');\n      triggerInfo.changeOfValueThreshold = null;\n      triggerInfo.triggerValue = '';\n    },\n  },\n  computed: {},\n\n  watch: {\n    triggers() {\n      console.log('parent triggers changed');\n      this.localTriggers = this.triggers;\n    },\n  },\n};\n</script>\n\n<style scoped>\n.block {\n  border: 2px dashed #ffffff;\n  padding: 10px;\n  margin-bottom: 10px;\n  width: 90%;\n}\n.help-icon {\n  cursor: pointer;\n  margin-left: 10px;\n}\n</style>\n","<template>\n  <md-step\n    class=\"mdStep\"\n    :id=\"STEPPERS_DATA.algorithmConfiguration\"\n    md-label=\"Algorithms\"\n    :md-done.sync=\"stepper.fifth\"\n  >\n    <md-content class=\"contents md-scrollbar\">\n        <p>\n        An algorithm is a function that the analytic uses to get the work done.\n        </p>\n\n      <div v-for=\"(algorithmIndexName, index) of Object.keys(localAlgorithms)\" :key=\"index\" class=\"block\">\n        <b>Algorithm {{algorithmIndexName}}</b>\n        <md-field class=\"fixed-size-field\">\n          <label>Algorithm</label>\n          <md-select @md-selected=\"resetParams(algorithmIndexName)\" v-model=\"algorithms[algorithmIndexName].name\">\n            <md-option\n              v-for=\"data of algo_names\"\n              :key=\"data.name\"\n              :value=\"data.name\"\n            >{{ data.name }}</md-option\n            >\n          </md-select>\n        </md-field>\n\n        <div v-if=\"algorithms[algorithmIndexName].name != ''\">\n        <p>\n          <strong> Description : </strong>\n          {{ algos[algorithms[algorithmIndexName].name].description }}</p\n        >\n        </div>\n\n      <!-- \n      <div v-if=\"algorithm != ''\">\n        <div v-if=\"algos[algorithm].requiredParams == 'boolean'\">\n          <div\n          class=\"fixed-size-field\"\n          v-for=\"(item, index) of inputs\"\n          :key=\"index\"\n        >\n          <label> {{ index }} </label>\n          <md-radio value=\"false\">\n            False\n          </md-radio>\n          <md-radio value=\"true\">\n            True\n          </md-radio>\n        </div>\n        </div>\n        <div v-else-if=\"algos[algorithm].requiredParams == 'number'\">\n          <md-field\n            class=\"fixed-size-field\"\n            v-for=\"(item, index) of inputs\"\n            :key=\"index\"\n          >\n            <label> {{ index }} </label>\n            <md-input\n              @change=\"update('algorithmParameters',localAlgorithmParameters)\"\n              type=\"number\"\n              v-model=\"localAlgorithmParameters[index]\"\n            ></md-input>\n          </md-field>\n        </div>\n        <div v-else-if=\"algos[algorithm].requiredParams == 'string'\">\n          <md-field\n            class=\"fixed-size-field\"\n            v-for=\"(item, index) of inputs\"\n            :key=\"index\"\n          >\n            <label> {{ index }} </label>\n            <md-input\n              @change=\"update('algorithmParameters',localAlgorithmParameters)\"\n              v-model=\"localAlgorithmParameters[index]\"\n            ></md-input>\n          </md-field>\n        </div>\n        -->\n\n        <div v-if=\"algorithms[algorithmIndexName].name != ''\">\n          <md-field\n            class=\"fixed-size-field\"\n            v-for=\"(item, index) in algos[algorithms[algorithmIndexName].name].requiredParams\"\n            :key=\"index\"\n          >\n            <label>{{ item.name }}, {{ item.description }}</label>\n            <md-input\n              :type=\"item.type\"\n              v-model=\"algorithms[algorithmIndexName].params[index]\"\n            ></md-input>\n          </md-field>\n        </div>\n\n        <md-button\n          class=\"md-accent\"\n          @click=\"removeAlgorithm(algorithmIndexName)\">\n          Remove\n        </md-button>\n        \n      </div>\n\n      <md-button\n        class=\"md-primary\"\n        @click=\"addAlgorithm\"\n      >\n        Add Algorithm\n      </md-button> \n\n    </md-content>\n  </md-step>\n</template>\n\n<script>\nimport { algos} from 'spinal-model-analysis';\n\nexport default {\n  props: ['STEPPERS_DATA', 'stepper','entityType','followedEntity'\n  ,'inputs', 'algorithms','algorithms_parameters' ],\n  components: {\n  },\n  data() {\n    return {\n        localAlgorithms: this.algorithms,      \n    };\n  },\n  created() {\n    this.algos = algos;\n  },\n  methods: {\n    addAlgorithm() {\n      console.log('clicked on button add Algorithm');\n      this.$emit('addAlgorithm');\n    },\n    removeAlgorithm(algoIndexName){\n      this.$emit('removeAlgorithm',algoIndexName);\n    },\n    resetParams(algoIndexName){\n      this.algorithms[algoIndexName].params = [];\n    }\n    \n  },\n  computed: {\n    algo_names() {\n      return Object.values(algos);\n    },\n  },\n\n  watch:{\n    algorithms(){\n      console.log('parent algorithms changed')\n      this.localAlgorithms = this.algorithms;\n    }\n  }\n};\n</script>\n\n<style scoped>\n.block {\n  border: 2px dashed #ffffff;\n  padding: 10px;\n  margin-bottom: 10px;\n  width: 90%;\n}\n\n\n</style>\n\n","<template>\n    <md-dialog :md-click-outside-to-close=\"false\" :md-close-on-esc=\"false\" class=\"mdDialog\" :md-active.sync=\"showSelectionDialog\">\n      \n      <!-- Inputs Table -->\n      <md-table v-model=\"inputListComputed\" md-card @md-selected=\"onSelectInput\" :md-selected-value.sync=\"selectedInputs\" class=\"table\">\n        <md-table-toolbar>\n          <h1 class=\"md-title table-title\">Inputs</h1>\n        </md-table-toolbar>\n        <md-table-toolbar slot=\"md-table-alternate-header\" slot-scope=\"{ count }\">\n          <div class=\"md-toolbar-section-start\">{{ getAlternateLabel(count) }}</div>\n          <div class=\"md-toolbar-section-end\">\n            <md-button @click=\"deleteAllInputSelection\" class=\"md-icon-button delete-button\">\n              <md-icon >delete</md-icon>\n            </md-button>\n          </div>\n        </md-table-toolbar>\n      \n      \n      <md-table-row slot=\"md-table-row\" slot-scope=\"{ item }\" md-selectable=\"multiple\" md-auto-select\n      :md-disabled=\"isResultSelection\"\n      :class=\"{ 'disabled-row': isResultSelection}\"\n      >\n        <md-table-cell md-label=\"Index Name\"> {{item.indexName}} </md-table-cell>\n        <md-table-cell md-label=\"Tracking Method\"> {{item.trackingMethod}} </md-table-cell>\n        <md-table-cell md-label=\"Filter value\"> {{item.filterValue}} </md-table-cell>\n        <md-table-cell md-numeric md-label=\"Timeseries\"> {{item.timeseriesIntervalTime}} </md-table-cell>\n      </md-table-row>\n\n\n    </md-table>\n\n    \n    <md-table v-model=\"algorithmListComputed\" md-card @md-selected=\"onSelectAlgorithm\" class=\"table\"\n    :md-selected-value.sync=\"selectedAlgorithms\">\n        <md-table-toolbar>\n          <h1 class=\"md-title table-title\">Algorithms</h1>\n        </md-table-toolbar>\n      <md-table-toolbar slot=\"md-table-alternate-header\" slot-scope=\"{ count }\">\n        <div class=\"md-toolbar-section-start\">{{ getAlternateLabel(count) }}</div>\n\n        <div class=\"md-toolbar-section-end\">\n          <md-button @click=\"deleteAllAlgoSelection\" class=\"md-icon-button\">\n            <md-icon>delete</md-icon>\n          </md-button>\n        </div>\n      </md-table-toolbar>\n\n      <md-table-row slot=\"md-table-row\" slot-scope=\"{ item }\" :md-selectable=\"isResultSelection? 'single': 'multiple'\" md-auto-select \n      :md-disabled=\"disableSameAlgorithmSelection(item.indexName)\"\n      :class=\"{ 'disabled-row': disableSameAlgorithmSelection(item.indexName) }\">\n        <md-table-cell md-label=\"Index Name\"> {{item.indexName}} </md-table-cell>\n        <md-table-cell md-label=\"Algorithm name\"> {{item.name}} </md-table-cell>\n        <md-table-cell md-label=\"Parameters\"> {{item.params}} </md-table-cell>\n      </md-table-row>\n    </md-table>\n    <md-dialog-actions class=\"dialog-actions\">\n        <md-button class=\"md-accent action-button\" @click=\"closeDialog\">Close</md-button>\n        <md-button class=\"md-primary action-button\" @click=\"sendSelected\">Save</md-button>\n      </md-dialog-actions>\n\n\n  </md-dialog>\n</template>\n\n<script>\nexport default {\n  props: ['selectedAlgorithm','algorithms', 'inputs','showSelectionDialog'],\n  components: {},\n  data() {\n    return {\n      selectedInputs: [],\n      selectedAlgorithms : [],\n\n    };\n  },\n  created() {\n  \n  },\n  methods: {\n    deleteAllInputSelection(){\n        console.log(\"deleteAllInputSelection\")\n        this.selectedInputs = [];\n    },\n    deleteAllAlgoSelection(){\n        this.selectedAlgorithms = [];\n    },\n\n    closeDialog(){\n        this.selectedAlgorithms = [];\n        this.selectedInputs = [];\n        this.$emit(\"closeSelectionDialog\");\n    },\n    sendSelected() \n    {\n      this.$emit('sendSelectedInputs', this.selectedInputs.concat(this.selectedAlgorithms));\n      this.$emit(\"closeSelectionDialog\");\n      this.selectedAlgorithms = [];\n      this.selectedInputs = [];\n      console.log(\"sendSelectedEvent :\" , this.selectedAlgorithms)\n    },\n    onSelectInput (items) {\n        console.log(\"onSelectInputEvent :\" , items)\n        this.selectedInputs = items\n\n    },\n    onSelectAlgorithm ( items ) {\n        console.log(\"onSelectAlgorithmEvent :\" , items)\n        this.selectedAlgorithms = items\n    },\n    getAlternateLabel (count) {\n        let plural = ''\n\n        if (count > 1) {\n          plural = 's'\n        }\n        return `${count} Item${plural} selected`\n    },\n\n    flattenObject(obj) {\n    const flattened = [];\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const flatItem = {\n                indexName: key,\n                ...obj[key]\n            };\n            flattened.push(flatItem);\n        }\n    }\n    return flattened;\n    },\n\n    disableSameAlgorithmSelection(indexName){\n        return indexName == this.selectedAlgorithm;\n    },\n\n    \n    \n  },\n  computed: {\n    inputListComputed: {\n        get() {\n            return this.flattenObject(this.inputs);\n        },\n        set(newValue) {\n            \n        }\n    },\n    algorithmListComputed: {\n        get() {\n            return this.flattenObject(this.algorithms);\n        },\n        set(newValue) {\n            \n        }\n    },\n\n    isResultSelection(){\n        return  this.selectedAlgorithm == 'R';\n    }\n\n  },\n\n  watch: {},\n};\n</script>\n\n<style  scoped>\n.mdDialog {\n    z-index: 1000 !important;\n    width: 100%;\n    height: 100%;\n    padding: 20px;\n}\n\n.table {\n    margin-bottom: 20px;\n    border: 1px dashed #ccc;\n}\n\n.table md-table-row {\n    border-bottom: 1px dashed #ccc;\n}\n\n.table-title {\n    font-weight: 600;\n    color: #333;\n    margin-bottom: 10px;\n}\n\n.delete-button {\n    color: #f44336; /* Red color for delete */\n}\n\n.selected-label {\n    font-weight: 600;\n    margin-top: 10px;\n}\n\n.selected-content {\n    background-color: #f5f5f5;\n    padding: 10px;\n    border-radius: 5px;\n    margin-top: 5px;\n}\n\n.dialog-actions {\n    display: flex;\n    justify-content: right;\n    margin-top: 20px;\n}\n\n.action-button {\n    padding: 10px 20px;\n    border-radius: 5px;\n    transition: background-color 0.3s;\n}\n\n.action-button:hover {\n    background-color: #f5f5f5;\n}\n\n.disabled-row {\n    background-color: #f0f0f026; /* Light grey background */\n    color: #aaa; /* Grey text */\n    pointer-events: none; /* Makes the row non-interactive */\n}\n</style>","<template>\n  <md-step\n    class=\"mdStep\"\n    :id=\"STEPPERS_DATA.IODependencies\"\n    md-label=\"IO\"\n    :md-done.sync=\"stepper.seventh\"\n  >\n    <md-content class=\"contents md-scrollbar\">\n      <div v-if=\"Object.keys(algorithms).length==0\">\n        <p>\n          <b>Warning</b>\n          An analytic must have a minimum of 1 algorithm. Please add an\n          algorithm first\n        </p>\n      </div>\n      <div v-else>\n        <p>\n          Dependencies :\n        </p>\n\n        <md-list>\n          <md-list-item class=\"pretty-list-item\">\n            R (Result) : \n              <div class=\"draggable-item\">\n                Final Result : {{ ioDependencies['R'][0] }}\n              </div>\n          \n            <md-button @click=\"showSelection('R')\">Select dependencies</md-button>\n\n          </md-list-item>\n          <md-list-item\n            v-for=\"(algorithmIndexName, index) of Object.keys(algorithms)\"\n            :key=\"index\" class=\"pretty-list-item\">\n            {{algorithmIndexName}} : \n          \n        <draggable v-model=\"ioDependencies[algorithmIndexName]\" @end=\"updateDependenciesOrder(algorithmIndexName)\">\n          <div v-for=\"(dep,indexDep) in ioDependencies[algorithmIndexName]\" :key=\"dep\" class=\"draggable-item\">\n            Input {{ indexDep+1 }} : {{ dep }}\n          </div>\n        </draggable>\n            <md-button @click=\"showSelection(algorithmIndexName)\">Select dependencies</md-button>\n\n          </md-list-item>\n        </md-list>\n      </div>\n      <input-selection-table\n        :algorithms=\"algorithms\"\n        :inputs=\"inputs\"\n        :ioDependencies=\"ioDependencies\"\n        :showSelectionDialog=\"showSelectionDialog\"\n        :selectedAlgorithm=\"selectedAlgorithm\"\n        @closeSelectionDialog=\"closeSelectionDialog\"\n        @sendSelectedInputs=\"saveSelectedDependencies\"\n        >\n      </input-selection-table>\n    </md-content>\n  </md-step>\n</template>\n\n<script>\nimport inputSelectionTableVue from './inputSelectionTable.vue';\nimport draggable from \"vuedraggable\";\nimport { spinalAnalyticService } from 'spinal-model-analysis'\n\n\n\nexport default {\n  props: ['STEPPERS_DATA', 'stepper', 'algorithms', 'inputs','ioDependencies'],\n  components: {\n    draggable,\n    'input-selection-table': inputSelectionTableVue,\n  },\n  data() {\n    return {\n      showSelectionDialog: false,\n      selectedAlgorithm : '',\n    };\n  },\n  created() {},\n  methods: {\n    updateDependenciesOrder(algorithmIndexName) {\n      console.log(\"Updated order for:\", algorithmIndexName);\n      console.log(this.ioDependencies[algorithmIndexName]);\n    },\n\n    showSelection(indexName) {\n      this.selectedAlgorithm = indexName;\n      this.showSelectionDialog = true;\n      \n    },\n    closeSelectionDialog(){\n        this.showSelectionDialog = false;\n    },\n\n\n    findExecutionOrder(dependencies ) {\n    const graph = {};\n    const visited = {};\n    const stack = [];\n    const tempStack = []; // for cycle detection\n\n    // Create graph from dependency map\n    for (let algo of Object.keys(dependencies)) {\n        graph[algo] = graph[algo] || [];\n        for (let dep of dependencies[algo]) {\n            graph[dep] = graph[dep] || [];\n            graph[dep].push(algo);\n        }\n    }\n\n    const visit = (node) => {\n        if (tempStack.includes(node)) {\n            return false; // cycle detected\n        }\n        if (!visited[node]) {\n            visited[node] = true;\n            tempStack.push(node);\n            if (graph[node]) {\n                for (let neighbor of graph[node]) {\n                    if (!visit(neighbor)) return false; // propagate cycle detection\n                }\n            }\n            tempStack.pop();\n            stack.push(node);\n        }\n        return true;\n    };\n\n    for (let node of Object.keys(graph)) {\n        if (!visited[node]) {\n            if (!visit(node)) return null; // cycle detected\n        }\n    }\n\n    return stack.filter(x => x.startsWith('A'));\n    },\n\n\n    saveSelectedDependencies(selectedItems) {\n      console.log(\"saving selected dependencies : \", selectedItems)\n      console.log(\" to \", this.selectedAlgorithm)\n\n      let indexNames = selectedItems.map(item => item.indexName);\n      this.ioDependencies[this.selectedAlgorithm]=indexNames;\n\n      console.log(\"ioDependencies : \", this.ioDependencies)\n      const executionOrder = this.findExecutionOrder(this.ioDependencies)\n      console.log(\"executionOrder : \", executionOrder)\n    },\n\n    \n  },\n  computed: {},\n\n  watch: {},\n};\n</script>\n\n<style scoped>\n.draggable-item {\n  display: inline-block;\n  margin: 0 5px;\n  padding: 5px 10px;\n  border-radius: 4px;\n  background-color: #484848;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  transition: background-color 0.3s ease;\n}\n\n.draggable-item:hover {\n  background-color: #232323;\n  cursor: grab;\n}\n\n.draggable-item:active {\n  background-color: #572727;\n  cursor: grabbing;\n}\n\n\n.pretty-list-item {\n    display: flex !important;\n    align-items: center !important;\n    justify-content: space-between !important;\n    border-bottom: 1px solid #ccc !important;\n    padding-bottom: 10px !important;\n    margin-bottom: 10px !important; \n}\n\nmd-button {\n  margin-left: 20px;\n}\n</style>\n","<template>\n  <md-step\n    class=\"mdStep\"\n    :id=\"STEPPERS_DATA.summary\"\n    md-label=\"Summary\"\n    :md-done.sync=\"stepper.eighth\"\n  >\n    <md-content class=\"contents md-scrollbar\">\n      <p>\n        Please check that all the information are correct before saving the\n        analytic.\n      </p>\n      <div\n        v-for=\"(field, index) in summaryList\"\n        :key=\"index\"\n        class=\"summary-item\"\n      >\n        <strong>{{ field.label }}:</strong>\n        {{ field.value === '' ? 'Missing !' : field.value }}\n      </div>\n    </md-content>\n  </md-step>\n</template>\n\n<script>\n\nexport default {\n  props: [\n    'STEPPERS_DATA',\n    'stepper',\n    'analyticName',\n    'trackingMethods',\n    'followedEntity',\n    'algorithm',\n    'algorithmParameters',\n    'resultName',\n    'resultType',\n    'intervalTime',\n  ],\n  data() {\n\n    return {\n\n    };\n  },\n  methods: {},\n  computed: {\n    summaryList() {\n      return [\n        { label: 'Analytic Name', value: this.analyticName },\n        { label: 'Tracking Methods', value: JSON.stringify(this.trackingMethods) },\n        { label: 'Followed Entity', value: this.followedEntity },\n        { label: 'Algorithm', value: this.algorithm },\n        {\n          label: 'Algorithm Parameters',\n          value: JSON.stringify(this.algorithmParameters),\n        },\n        { label: 'Result Name', value: this.resultName },\n        { label: 'Result Type', value: this.resultType },\n        { label: 'Interval Time (ms)', value: this.intervalTime },\n      ];\n    },\n  },\n};\n</script>\n\n<style scoped>\n.summary-item {\n  padding: 8px 0;\n  font-size: 16px;\n  line-height: 1.5;\n}\n\n.summary-item strong {\n  margin-right: 8px;\n}\n</style>\n","<template>\n  <md-dialog\n    :md-active.sync=\"showDialog\"\n    :md-click-outside-to-close=\"false\"\n    @md-closed=\"closeDialog(false)\"\n    class=\"mdDialog\"\n  >\n    <md-dialog-title class=\"mdDialogTitle\"> Create Analytic </md-dialog-title>\n\n    <md-dialog-content class=\"mdDialogContainer\">\n      <md-steppers\n        :md-active-step.sync=\"stepper.active\"\n        @md-changed=\"changeStep\"\n        md-linear\n      >\n        <analytic-name\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          v-bind:analyticName.sync=\"analyticName\"\n          v-bind:analyticDescription.sync=\"analyticDescription\"\n          v-bind:analyticShouldTriggerAtStart.sync=\"analyticShouldTriggerAtStart\"\n          v-bind:analyticStatus.sync=\"analyticStatus\"\n          :editable=\"true\"\n        ></analytic-name>\n\n         <followed-entity\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :entityType=\"entityType\"\n          v-bind:followedEntity.sync=\"followedEntity\"\n        ></followed-entity>\n\n        <input-configuration\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :entityType=\"entityType\"\n          :followedEntity=\"followedEntity\"\n          @addInput=\"addInput\"\n          @removeInput=\"removeInput\"\n          v-bind:inputs.sync=\"inputs\"\n        >\n        </input-configuration>\n\n        <trigger-configuration\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :inputs=\"inputs\"\n          @addTrigger=\"addTrigger\"\n          @removeTrigger=\"removeTrigger\"\n          v-bind:triggers.sync=\"triggers\"\n        >\n        </trigger-configuration>\n\n        <algorithm-configuration\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          @addAlgorithm=\"addAlgorithm\"\n          @removeAlgorithm=\"removeAlgorithm\"\n          v-bind:algorithms.sync=\"algorithms\"\n          >\n        </algorithm-configuration>\n\n\n        <result-configuration\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :inputs=\"inputs\"\n          v-bind:resultName.sync=\"resultName\"\n          v-bind:resultType.sync=\"resultType\"\n          v-bind:intervalTime.sync=\"intervalTime\"\n          v-bind:ticketContextId.sync=\"ticketContextId\"\n          v-bind:ticketProcessId.sync=\"ticketProcessId\"\n          v-bind:phoneNumber.sync=\"phoneNumber\"\n          v-bind:phoneMessage.sync=\"phoneMessage\"\n          v-bind:gChatMessage.sync=\"gChatMessage\"\n          v-bind:gChatSpaceName.sync=\"gChatSpaceName\"\n          v-bind:alarmPriority.sync=\"alarmPriority\">\n        </result-configuration>\n\n\n        <io-dependencies\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :inputs=\"inputs\"\n          :algorithms=\"algorithms\"\n          v-bind:ioDependencies.sync=\"ioDependencies\"\n          >\n        </io-dependencies>\n\n        <summary-analytic\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :analyticName=\"analyticName\"\n          :trackingMethods=\"trackingMethods\"\n          :followedEntity=\"followedEntity\"\n          :algorithm=\"algorithm\"\n          :algorithmParameters=\"algorithmParameters\"\n          :resultName=\"resultName\"\n          :resultType=\"resultType\"\n          :intervalTime=\"intervalTime\"\n        >\n        </summary-analytic> \n      </md-steppers>\n    </md-dialog-content>\n\n    <md-dialog-actions>\n      <md-button class=\"md-primary\" @click=\"closeDialog(false)\"\n        >Close</md-button\n      >\n\n      <md-button\n        class=\"md-primary\"\n        v-if=\"stepper.active !== this.STEPPERS_DATA.summary\"\n        @click=\"PassToNextStep\"\n        >Next\n      </md-button>\n      <md-button\n        v-if=\"stepper.active === this.STEPPERS_DATA.summary\"\n        :disabled=\"isSaveButtonDisabled()\"\n        class=\"md-primary\"\n        @click=\"closeDialog(true)\"\n        >Save</md-button\n      >\n    </md-dialog-actions>\n  </md-dialog>\n</template>\n\n<script>\nimport {\n  spinalAnalyticService,\n  CATEGORY_ATTRIBUTE_TICKET_LOCALIZATION_PARAMETERS,\n  CATEGORY_ATTRIBUTE_ALGORTHM_PARAMETERS,\n  CATEGORY_ATTRIBUTE_RESULT_PARAMETERS,\n  CATEGORY_ATTRIBUTE_TRACKING_METHOD_PARAMETERS,\n  CATEGORY_ATTRIBUTE_TWILIO_PARAMETERS,\n  CATEGORY_ATTRIBUTE_ANALYTIC_PARAMETERS,\n  CATEGORY_ATTRIBUTE_IO_DEPENDENCIES,\n  CATEGORY_ATTRIBUTE_TRIGGER_PARAMETERS,\n  CATEGORY_ATTRIBUTE_ALGORITHM_INDEX_MAPPING,\n  CATEGORY_ATTRIBUTE_GCHAT_PARAMETERS,\n  ATTRIBUTE_GCHAT_MESSAGE,\n  ATTRIBUTE_GCHAT_SPACE,\n  ATTRIBUTE_PHONE_NUMBER,\n  ATTRIBUTE_PHONE_MESSAGE,\n  ATTRIBUTE_SEPARATOR,\n  ATTRIBUTE_TRACKING_METHOD,\n  ATTRIBUTE_FILTER_VALUE,\n  ATTRIBUTE_TIMESERIES,\n  ATTRIBUTE_RESULT_NAME,\n  ATTRIBUTE_RESULT_TYPE,\n  ATTRIBUTE_ANALYTIC_STATUS,\n  ATTRIBUTE_ANALYTIC_DESCRIPTION,\n  ATTRIBUTE_SEARCH_DEPTH,\n  ATTRIBUTE_STRICT_DEPTH,\n  ATTRIBUTE_SEARCH_RELATIONS,\n  ATTRIBUTE_TRIGGER_AT_START,\n  ATTRIBUTE_TICKET_CONTEXT_ID,\n  ATTRIBUTE_TICKET_PROCESS_ID,\n  ATTRIBUTE_ALARM_PRIORITY,\n  ATTRIBUTE_VALUE_SEPARATOR,\n  ANALYTIC_RESULT_TYPE,\n  TRACK_METHOD,\n  algos,\n  ANALYTIC_STATUS,\n  TRIGGER_TYPE\n} from 'spinal-model-analysis';\n\nimport analyticNameVue from './components/analyticSteps/analyticName.vue';\nimport followedEntityVue from './components/analyticSteps/followedEntity.vue';\nimport inputConfiguration from './components/analyticSteps/inputConfiguration.vue';\nimport triggerConfiguration from './components/analyticSteps/triggerConfiguration.vue';\nimport algorithmConfiguration from './components/analyticSteps/algorithmConfiguration.vue';\nimport resultConfiguration from './components/analyticSteps/resultConfiguration.vue';\nimport IODependenciesVue from './components/analyticSteps/IODependencies.vue';\nimport configurationVue from './components/analyticSteps/configuration.vue';\nimport summaryVue from './components/analyticSteps/summary.vue';\n\n\nexport default {\n  name: 'createAnalyticDialog',\n  props: ['onFinised'],\n  components: {\n    'analytic-name': analyticNameVue,\n    'followed-entity': followedEntityVue,\n    'input-configuration': inputConfiguration,\n    'trigger-configuration': triggerConfiguration,\n    'algorithm-configuration': algorithmConfiguration,\n    'result-configuration': resultConfiguration,\n    'io-dependencies': IODependenciesVue,\n    'configuration': configurationVue,\n    'summary-analytic': summaryVue,\n  },\n  data() {\n\n    this.STEPPERS_DATA = {\n      analytic: 'first',\n      followedEntity: 'second',\n      inputConfiguration: 'third',\n      triggerConfiguration: 'fourth',\n      algorithmConfiguration: 'fifth',\n      resultConfiguration: 'sixth',\n      IODependencies : 'seventh',\n      summary : 'eighth',\n    };\n\n    return {\n      showDialog: true,\n      showPreviewDialog: false,\n\n      // Analytic attributes data\n      analyticName: '',\n      analyticDescription:'',\n      analyticShouldTriggerAtStart : false,\n      analyticStatus : false,\n\n\n      // Inputs -> Followed Entity -> attribute data\n      followedEntity: undefined, \n\n      // Inputs  -> Tracking Method -> attribute data\n      inputs: { },\n\n\n      // Config -> trigger attribute data\n      triggers: { },\n\n      // Config -> Algorithms attribute data\n      algorithms: {},\n\n      // Config -> I/O Dependencies attribute data\n      ioDependencies : { R : \"\"},\n\n      // Config -> Result attribute data\n      resultType : '',\n      resultName : '', \n      ticketContextId: '',\n      ticketProcessId: '',\n      phoneNumber:'',\n      phoneMessage:'',\n      alarmPriority: null,\n      gChatMessage : '',\n      gChatSpaceName : '',\n      \n      selectedNode: undefined,\n      entityType: undefined,\n\n      stepper: {\n        active: this.STEPPERS_DATA.analytic,\n        first: false,\n        second: false,\n        third: false,\n        fourth: false,\n        fifth: false,\n        sixth: false,\n        seventh: false,\n        eighth: false,\n      },\n    };\n  },\n\n  created() {\n    this.ANALYTIC_STATUS = ANALYTIC_STATUS;\n  },\n\n  methods: {\n    opened(option) {\n      this.selectedNode = option.selectedNode;\n      this.entityType = this.selectedNode.entityType.get();\n    },\n\n    async removed(res) {\n      if (res.closeResult) {\n\n        // there must be a better way to get the context id...\n        const contextId = Object.keys(this.selectedNode.contextIds.get())[0];\n\n        //create analytic Node\n        const IAnalytic = {\n          name: this.analyticName,\n          description: '',\n        };\n\n        const analyticInfo = await spinalAnalyticService.addAnalytic(\n          IAnalytic,\n          contextId,\n          this.selectedNode.id.get()\n        );\n\n        //create trackingMethod Node\n        const trackingMethodAttributes = this.getTrackingMethodAttributes();\n        console.log('trackingMethodAttributes :', trackingMethodAttributes);\n        \n        const trackingMethodInfo =\n          await spinalAnalyticService.addInputTrackingMethod(\n            trackingMethodAttributes,\n            contextId,\n            analyticInfo.id.get()\n          );\n\n\n\n        //create followedEntity Node\n\n        const followedEntityInfo =\n          await spinalAnalyticService.addInputLinkToFollowedEntity(\n            contextId,\n            analyticInfo.id.get(),\n            this.followedEntity\n        );\n\n\n        //create config Node\n        const configAttributes = {};\n\n\n        //Add all analytic parameters ( description, status, triggerAtStart)\n        const analyticAttributes = this.getAnalyticAttributes();\n        configAttributes[\n          CATEGORY_ATTRIBUTE_ANALYTIC_PARAMETERS\n        ] = analyticAttributes;\n\n\n        const triggerAttributes = this.getTriggerAttributes();\n        configAttributes[\n          CATEGORY_ATTRIBUTE_TRIGGER_PARAMETERS\n        ] = triggerAttributes;\n\n\n        const resultAttributes = this.getResultAttributes();\n        configAttributes[CATEGORY_ATTRIBUTE_RESULT_PARAMETERS] = resultAttributes;\n        \n\n\n        const algorithmParametersAttributes = this.getAlgorithmParametersAttributes();\n        configAttributes[CATEGORY_ATTRIBUTE_ALGORTHM_PARAMETERS] =\n          algorithmParametersAttributes;\n        \n        const algorithmMappingAttributes = this.getAlgorithmMappingAttributes();\n        configAttributes[CATEGORY_ATTRIBUTE_ALGORITHM_INDEX_MAPPING] = algorithmMappingAttributes;\n\n        const ioAttributes = this.getIOAttributes();\n        configAttributes[CATEGORY_ATTRIBUTE_IO_DEPENDENCIES] = ioAttributes;\n        \n        if (this.ticketContextId && this.ticketProcessId) {\n          const ticketAttributes = this.getTicketAttributes();\n          configAttributes[\n            CATEGORY_ATTRIBUTE_TICKET_LOCALIZATION_PARAMETERS\n          ] = ticketAttributes;\n        }\n\n        if(this.resultType == ANALYTIC_RESULT_TYPE.SMS){\n          const smsAttributes = this.getSMSAttributes();\n          configAttributes[\n            CATEGORY_ATTRIBUTE_TWILIO_PARAMETERS\n          ] = smsAttributes;\n        };\n\n        if([ANALYTIC_RESULT_TYPE.GCHAT_MESSAGE,ANALYTIC_RESULT_TYPE.GCHAT_ORGAN_CARD].includes(this.resultType)){\n          const gChatAttributes = this.getGChatAttributes();\n          configAttributes[\n            CATEGORY_ATTRIBUTE_GCHAT_PARAMETERS\n          ] = gChatAttributes;\n        };\n        \n        console.log('configAttributes :', configAttributes);\n\n        const configInfo = await spinalAnalyticService.addConfig(\n          configAttributes,\n          analyticInfo.id.get(),\n          contextId\n        );\n      }\n\n      this.showDialog = false;\n    },\n\n    closeDialog(closeResult) {\n      if (typeof this.onFinised === 'function') {\n        this.onFinised({\n          closeResult,\n          analyticName: this.analyticName,\n        });\n      }\n    },\n\n    addInput() {\n      let length = Object.keys(this.inputs).length;\n      console.log('adding input');\n      this.inputs = { ...this.inputs, [`I${length}`]: { trackingMethod: '', filterValue: '', searchDepth:0, strictDepth:false, searchRelations:'', timeseriesIntervalTime : 0 }};\n    },\n\n    removeInput(inputName) {\n      delete this.inputs[inputName];\n      let index = Number(inputName.match(/(\\d+)/)[0]);\n      // shift back all the inputs after the deleted one.\n      let i = index;\n      while (this.inputs[`I${i + 1}`] !== undefined) {\n        this.inputs[`I${i}`] = this.inputs[`I${i + 1}`];\n        i++;\n      }\n      // Remove the last item.\n      delete this.inputs[`I${i}`];\n\n      this.inputs = { ...this.inputs };\n      console.log(\"deleted input : \", inputName);\n    },\n\n    addTrigger() {\n      let length = Object.keys(this.triggers).length;\n      console.log('adding input');\n      this.triggers = { ...this.triggers, [`T${length}`]: { triggerType: '', triggerValue: '', changeOfValueThreshold : 0 }};\n      \n    },\n\n    removeTrigger(triggerName) {\n      delete this.triggers[triggerName];\n      let index = Number(triggerName.match(/(\\d+)/)[0]);\n      // shift back all the elements after the deleted one.\n      let i = index;\n      while (this.triggers[`T${i + 1}`] !== undefined) {\n        this.triggers[`T${i}`] = this.triggers[`T${i + 1}`];\n        i++;\n      }\n      // Remove the last item.\n      delete this.triggers[`T${i}`];\n\n      this.triggers = { ...this.triggers };\n      console.log(\"deleted trigger : \", triggerName);\n    },\n\n    addAlgorithm(){\n      let length = Object.keys(this.algorithms).length;\n      console.log('adding algorithm');\n      this.algorithms = { ...this.algorithms, [`A${length}`]: { name :'', params: []}};\n    },\n\n    removeAlgorithm(algorithmIndexName){\n      delete this.algorithms[algorithmIndexName];\n      let index = Number(algorithmIndexName.match(/(\\d+)/)[0]);\n      // shift back all the elements after the deleted one.\n      let i = index;\n      while (this.algorithms[`A${i + 1}`] !== undefined) {\n        this.algorithms[`A${i}`] = this.algorithms[`A${i + 1}`];\n        i++;\n      }\n      // Remove the last item.\n      delete this.algorithms[`A${i}`];\n\n      this.algorithms = { ...this.algorithms };\n      console.log(\"deleted algorithm : \", algorithmIndexName);\n    },\n\n    changeStep(stepId) {\n      this.stepper.active = stepId;\n    },\n\n    PassToNextStep() {\n      switch (this.stepper.active) {\n        case this.STEPPERS_DATA.analytic:\n          this.stepper.first = true;\n          this.stepper.active = this.STEPPERS_DATA.followedEntity;\n          break;\n        case this.STEPPERS_DATA.followedEntity:\n          this.stepper.second = true;\n          this.stepper.active = this.STEPPERS_DATA.inputConfiguration;\n          break;\n        case this.STEPPERS_DATA.inputConfiguration:\n          this.stepper.third = true;\n          this.stepper.active = this.STEPPERS_DATA.triggerConfiguration;\n          break;\n        case this.STEPPERS_DATA.triggerConfiguration:\n          this.stepper.fourth = true;\n          this.stepper.active = this.STEPPERS_DATA.algorithmConfiguration;\n          break;\n        case this.STEPPERS_DATA.algorithmConfiguration:\n          this.stepper.fifth = true;\n          this.stepper.active = this.STEPPERS_DATA.resultConfiguration;\n          break;\n        case this.STEPPERS_DATA.resultConfiguration:\n          this.stepper.sixth = true;\n          this.stepper.active = this.STEPPERS_DATA.IODependencies;\n          break;\n        case this.STEPPERS_DATA.IODependencies:\n          this.stepper.seventh = true;\n          this.stepper.active = this.STEPPERS_DATA.summary;\n          break;\n        case this.STEPPERS_DATA.summary:\n          this.stepper.eighth = true;\n          this.stepper.active = this.STEPPERS_DATA.summary;\n          break;\n      }\n    },\n\n    isSaveButtonDisabled() {\n      return (\n        this.analyticName === '' ||\n        this.algorithm === '' ||\n        this.resultType === '' ||\n        this.resultName === '' ||\n        this.intervalTime === null ||\n        !this.followedEntity\n      );\n    },\n\n    getTrackingMethodAttributes(){\n      const trackingMethodAttributes = {};\n      for ( const inputKey of Object.keys(this.inputs))\n      {\n        trackingMethodAttributes[inputKey] = []\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_TRACKING_METHOD}`,\n                  type: 'string',\n                  value: this.inputs[inputKey].trackingMethod });\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_FILTER_VALUE}`,\n                  type: 'string',\n                  value: this.inputs[inputKey].filterValue });\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_SEARCH_DEPTH}`,\n                  type: 'number',\n                  value: this.inputs[inputKey].searchDepth });\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_STRICT_DEPTH}`,\n                  type: 'boolean',\n                  value: this.inputs[inputKey].strictDepth });\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_SEARCH_RELATIONS}`,\n                  type: 'string',\n                  value: this.inputs[inputKey].searchRelations });\n        \n        if([TRACK_METHOD.CONTROL_ENDPOINT_NAME_FILTER,TRACK_METHOD.ENDPOINT_NAME_FILTER].includes(this.inputs[inputKey].trackingMethod) ){\n          trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_TIMESERIES}`,\n                  type: 'number',\n                  value: this.inputs[inputKey].timeseriesIntervalTime });\n        }\n        \n      }\n      return trackingMethodAttributes;\n    },\n\n    getAnalyticAttributes(){\n      const analyticAttributes = [];\n      analyticAttributes.push({\n        name: `${ATTRIBUTE_ANALYTIC_DESCRIPTION}`,\n        type: 'string',\n        value: this.analyticDescription,\n      });\n      analyticAttributes.push({\n        name: `${ATTRIBUTE_ANALYTIC_STATUS}`,\n        type: 'string',\n        value: this.analyticStatus? ANALYTIC_STATUS.ACTIVE : ANALYTIC_STATUS.INACTIVE,\n      });\n      analyticAttributes.push({\n        name: `${ATTRIBUTE_TRIGGER_AT_START}`,\n        type: 'boolean',\n        value: this.analyticShouldTriggerAtStart,\n      });\n      return analyticAttributes;\n    },\n\n    getResultAttributes(){\n      const resultAttributes = [];\n      resultAttributes.push({\n        name: `${ATTRIBUTE_RESULT_TYPE}`,\n        type: 'string',\n        value: this.resultType,\n      });\n      resultAttributes.push({\n        name: `${ATTRIBUTE_RESULT_NAME}`,\n        type: 'string',\n        value: this.resultName,\n      });\n      return resultAttributes;\n    },\n\n    getAlgorithmParametersAttributes(){\n      const algorithmParametersAttributes = [];\n      for (const algorithmIndexName of Object.keys(this.algorithms)) {\n        let algoName = this.algorithms[algorithmIndexName].name;\n        const doc = algos[algoName].requiredParams;\n        for(let i = 0 ; i<this.algorithms[algorithmIndexName].params.length; i++){\n          algorithmParametersAttributes.push({\n            name: `${algorithmIndexName}${ATTRIBUTE_SEPARATOR}${doc[i].name}`,\n            value: doc[i].type === 'number' ? + this.algorithms[algorithmIndexName].params[i] : this.algorithms[algorithmIndexName].params[i],\n            type: doc[i].type,\n          });\n        }\n      }\n      return algorithmParametersAttributes;\n    },\n\n    getAlgorithmMappingAttributes(){\n      const algorithmMappingAttributes = [];\n      for (const algorithmIndexName of Object.keys(this.algorithms)) {\n        algorithmMappingAttributes.push({\n          name: `${algorithmIndexName}`,\n          type: 'string',\n          value: this.algorithms[algorithmIndexName].name,\n        });\n      }\n      return algorithmMappingAttributes;\n    },\n\n    getTicketAttributes(){\n      const ticketAttributes = [];\n      ticketAttributes.push({\n        name: `${ATTRIBUTE_TICKET_CONTEXT_ID}`,\n        type: 'string',\n        value: this.ticketContextId,\n      });\n      ticketAttributes.push({\n        name: `${ATTRIBUTE_TICKET_PROCESS_ID}`,\n        type: 'string',\n        value: this.ticketProcessId,\n      });\n      if(this.alarmPriority){\n          ticketAttributes.push({\n            name: `${ATTRIBUTE_ALARM_PRIORITY}`,\n            value: this.alarmPriority,\n            type: 'number',\n          });\n        }\n      return ticketAttributes;\n    },\n\n    getSMSAttributes(){\n      const smsAttributes = [];\n      smsAttributes.push({\n        name: `${ATTRIBUTE_PHONE_NUMBER}`,\n        type: 'string',\n        value: this.phoneNumber,\n      });\n      smsAttributes.push({\n        name: `${ATTRIBUTE_PHONE_MESSAGE}`,\n        type: 'string',\n        value: this.phoneMessage,\n      });\n      return smsAttributes;\n    },\n\n    getGChatAttributes(){\n      const gChatAttributes = [];\n      gChatAttributes.push({\n        name: `${ATTRIBUTE_GCHAT_MESSAGE}`,\n        type: 'string',\n        value: this.gChatMessage,\n      });\n      gChatAttributes.push({\n        name: `${ATTRIBUTE_GCHAT_SPACE}`,\n        type: 'string',\n        value: this.gChatSpaceName,\n      });\n      return gChatAttributes;\n    },\n    \n\n    getIOAttributes(){\n      const ioAttributes = [];\n      for (const ioDependencyName of Object.keys(this.ioDependencies)) {\n        let str = \"\";\n        for (const ioDependency of this.ioDependencies[ioDependencyName]) {\n          str += `${ioDependency}${ATTRIBUTE_VALUE_SEPARATOR}`;\n        }\n        str = str.slice(0, -1);\n        ioAttributes.push({\n          name: `${ioDependencyName}`,\n          type: 'string',\n          value: str,\n        });\n      }\n      return ioAttributes;\n    },\n\n    getTriggerAttributes(){\n      const triggerAttributes = [];\n      for (const triggerIndex of Object.keys(this.triggers)) {\n        let str = `${this.triggers[triggerIndex].triggerType}${ATTRIBUTE_VALUE_SEPARATOR}${this.triggers[triggerIndex].triggerValue}`;\n        if (this.triggers[triggerIndex].changeOfValueThreshold !== null) {\n          str += `${ATTRIBUTE_VALUE_SEPARATOR}${this.triggers[triggerIndex].changeOfValueThreshold}`;\n        }\n        triggerAttributes.push({\n          name: `${triggerIndex}`,\n          type: 'string',\n          value: str,\n        });\n      }\n      return triggerAttributes;\n    },\n    \n  },\n};\n</script>\n\n<style scoped>\n.mdDialog {\n  width: 1200px;\n  max-width: 1500px;\n  height: 600px;\n}\n\n.mdDialog .mdDialogTitle {\n  text-align: center;\n}\n\n.mdDialog .mdDialogContainer {\n  width: 1200px;\n  max-width: 1500px;\n  height: 100%;\n  overflow: auto;\n}\n\n.fixed-size-field {\n  width: 85%;\n  max-width: 85%;\n}\n\n.md-dialog-actions {\n  padding: 8px 16px; /* Add this line */\n  margin: 0; /* Add this line */\n}\n\n.md-button {\n  margin: 0 8px; /* Add this line */\n}\n\n.mdDialog .mdDialogContainer .mdStep {\n  height: 350px;\n  padding: 10px 0px;\n  overflow: auto;\n}\n</style>\n\n<style>\n.mdDialog .mdDialogContainer .mdStep .md-stepper-content.md-active {\n  width: 100%;\n  height: 100%;\n}\n.fixed-size-field {\n  width: 85%;\n  max-width: 85%;\n}\n\n.mdDialog .mdDialogContainer .mdStep .contents {\n  width: 100%;\n  height: 100%;\n  align-items: center;\n  overflow: auto;\n}\n</style>\n","<template>\n  <md-dialog\n    :md-active.sync=\"showDialog\"\n    :md-click-outside-to-close=\"false\"\n    @md-closed=\"closeDialog(false)\"\n    class=\"mdDialog\"\n  >\n    <md-dialog-title class=\"mdDialogTitle\"> Modify Analytic </md-dialog-title>\n\n    <md-dialog-content class=\"mdDialogContainer\">\n      <md-steppers\n        :md-active-step.sync=\"stepper.active\"\n        @md-changed=\"changeStep\"\n        md-linear\n      >\n        <analytic-name\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          v-bind:analyticName.sync=\"analyticName\"\n          v-bind:analyticDescription.sync=\"analyticDescription\"\n          v-bind:analyticShouldTriggerAtStart.sync=\"analyticShouldTriggerAtStart\"\n          v-bind:analyticStatus.sync=\"analyticStatus\"\n          :editable=\"false\"\n        ></analytic-name>\n\n         <followed-entity\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :entityType=\"entityType\"\n          v-bind:followedEntity.sync=\"followedEntity\"\n        ></followed-entity>\n\n        <input-configuration\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :entityType=\"entityType\"\n          :followedEntity=\"followedEntity\"\n          @addInput=\"addInput\"\n          @removeInput=\"removeInput\"\n          v-bind:inputs.sync=\"inputs\"\n        >\n        </input-configuration>\n\n        <trigger-configuration\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :inputs=\"inputs\"\n          @addTrigger=\"addTrigger\"\n          @removeTrigger=\"removeTrigger\"\n          v-bind:triggers.sync=\"triggers\"\n        >\n        </trigger-configuration>\n\n        <algorithm-configuration\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          @addAlgorithm=\"addAlgorithm\"\n          @removeAlgorithm=\"removeAlgorithm\"\n          v-bind:algorithms.sync=\"algorithms\"\n          >\n        </algorithm-configuration>\n\n\n        <result-configuration\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :inputs=\"inputs\"\n          v-bind:resultName.sync=\"resultName\"\n          v-bind:resultType.sync=\"resultType\"\n          v-bind:intervalTime.sync=\"intervalTime\"\n          v-bind:ticketContextId.sync=\"ticketContextId\"\n          v-bind:ticketProcessId.sync=\"ticketProcessId\"\n          v-bind:phoneNumber.sync=\"phoneNumber\"\n          v-bind:phoneMessage.sync=\"phoneMessage\"\n          v-bind:gChatMessage.sync=\"gChatMessage\"\n          v-bind:gChatSpaceName.sync=\"gChatSpaceName\"\n          v-bind:alarmPriority.sync=\"alarmPriority\">\n        </result-configuration>\n\n\n        <io-dependencies\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :inputs=\"inputs\"\n          :algorithms=\"algorithms\"\n          v-bind:ioDependencies.sync=\"ioDependencies\"\n          >\n        </io-dependencies>\n\n        <summary-analytic\n          :STEPPERS_DATA=\"STEPPERS_DATA\"\n          :stepper=\"stepper\"\n          :analyticName=\"analyticName\"\n          :trackingMethods=\"trackingMethods\"\n          :followedEntity=\"followedEntity\"\n          :algorithm=\"algorithm\"\n          :algorithmParameters=\"algorithmParameters\"\n          :resultName=\"resultName\"\n          :resultType=\"resultType\"\n          :intervalTime=\"intervalTime\"\n        >\n        </summary-analytic> \n      </md-steppers>\n    </md-dialog-content>\n\n    <md-dialog-actions>\n      <md-button class=\"md-primary\" @click=\"closeDialog(false)\"\n        >Close</md-button\n      >\n\n      <md-button\n        class=\"md-primary\"\n        v-if=\"stepper.active !== this.STEPPERS_DATA.summary\"\n        @click=\"PassToNextStep\"\n        >Next\n      </md-button>\n      <md-button\n        v-if=\"stepper.active === this.STEPPERS_DATA.summary\"\n        :disabled=\"isSaveButtonDisabled()\"\n        class=\"md-primary\"\n        @click=\"closeDialog(true)\"\n        >Save</md-button\n      >\n    </md-dialog-actions>\n  </md-dialog>\n</template>\n\n<script>\nimport {\n  spinalAnalyticService,\n  CATEGORY_ATTRIBUTE_TICKET_LOCALIZATION_PARAMETERS,\n  CATEGORY_ATTRIBUTE_ALGORTHM_PARAMETERS,\n  CATEGORY_ATTRIBUTE_RESULT_PARAMETERS,\n  CATEGORY_ATTRIBUTE_TRACKING_METHOD_PARAMETERS,\n  CATEGORY_ATTRIBUTE_TWILIO_PARAMETERS,\n  CATEGORY_ATTRIBUTE_ANALYTIC_PARAMETERS,\n  CATEGORY_ATTRIBUTE_IO_DEPENDENCIES,\n  CATEGORY_ATTRIBUTE_TRIGGER_PARAMETERS,\n  CATEGORY_ATTRIBUTE_ALGORITHM_INDEX_MAPPING,\n  CATEGORY_ATTRIBUTE_GCHAT_PARAMETERS,\n  ATTRIBUTE_GCHAT_MESSAGE,\n  ATTRIBUTE_GCHAT_SPACE,\n  ATTRIBUTE_PHONE_NUMBER,\n  ATTRIBUTE_PHONE_MESSAGE,\n  ATTRIBUTE_SEPARATOR,\n  ATTRIBUTE_TRACKING_METHOD,\n  ATTRIBUTE_SEARCH_DEPTH,\n  ATTRIBUTE_STRICT_DEPTH,\n  ATTRIBUTE_SEARCH_RELATIONS,\n  ATTRIBUTE_FILTER_VALUE,\n  ATTRIBUTE_TIMESERIES,\n  ATTRIBUTE_RESULT_NAME,\n  ATTRIBUTE_RESULT_TYPE,\n  ATTRIBUTE_ANALYTIC_STATUS,\n  ATTRIBUTE_ANALYTIC_DESCRIPTION,\n  ATTRIBUTE_TRIGGER_AT_START,\n  ATTRIBUTE_TICKET_CONTEXT_ID,\n  ATTRIBUTE_TICKET_PROCESS_ID,\n  ATTRIBUTE_ALARM_PRIORITY,\n  ATTRIBUTE_VALUE_SEPARATOR,\n  ANALYTIC_RESULT_TYPE,\n  ANALYTIC_STATUS,\n  TRACK_METHOD,\n  algos,\n} from 'spinal-model-analysis';\n\nimport analyticNameVue from './components/analyticSteps/analyticName.vue';\nimport followedEntityVue from './components/analyticSteps/followedEntity.vue';\nimport inputConfiguration from './components/analyticSteps/inputConfiguration.vue';\nimport triggerConfiguration from './components/analyticSteps/triggerConfiguration.vue';\nimport algorithmConfiguration from './components/analyticSteps/algorithmConfiguration.vue';\nimport resultConfiguration from './components/analyticSteps/resultConfiguration.vue';\nimport IODependenciesVue from './components/analyticSteps/IODependencies.vue';\nimport configurationVue from './components/analyticSteps/configuration.vue';\nimport summaryVue from './components/analyticSteps/summary.vue';\nimport { SpinalGraphService } from 'spinal-env-viewer-graph-service';\nimport AttributeService, { attributeService} from 'spinal-env-viewer-plugin-documentation-service';\n\nexport default {\n  name: 'modifyAnalyticDialog',\n  props: ['onFinised'],\n  components: {\n    'analytic-name': analyticNameVue,\n    'followed-entity': followedEntityVue,\n    'input-configuration': inputConfiguration,\n    'trigger-configuration': triggerConfiguration,\n    'algorithm-configuration': algorithmConfiguration,\n    'result-configuration': resultConfiguration,\n    'io-dependencies': IODependenciesVue,\n    'configuration': configurationVue,\n    'summary-analytic': summaryVue,\n  },\n  data() {\n\n    this.STEPPERS_DATA = {\n      analytic: 'first',\n      followedEntity: 'second',\n      inputConfiguration: 'third',\n      triggerConfiguration: 'fourth',\n      algorithmConfiguration: 'fifth',\n      resultConfiguration: 'sixth',\n      IODependencies : 'seventh',\n      summary : 'eighth',\n    };\n\n    return {\n      showDialog: true,\n      showPreviewDialog: false,\n\n      // Analytic attributes data\n      analyticName: '',\n      analyticDescription:'',\n      analyticShouldTriggerAtStart : undefined,\n      analyticStatus : undefined,\n\n\n      // Inputs -> Followed Entity -> attribute data\n      followedEntity: undefined, \n\n      // Inputs  -> Tracking Method -> attribute data\n      inputs: { },\n\n\n      // Config -> trigger attribute data\n      triggers: { },\n\n      // Config -> Algorithms attribute data\n      algorithms: {},\n\n      // Config -> I/O Dependencies attribute data\n      ioDependencies : { R : \"\"},\n\n      // Config -> Result attribute data\n      resultType : '',\n      resultName : '', \n      ticketContextId: '',\n      ticketProcessId: '',\n      phoneNumber:'',\n      phoneMessage:'',\n      alarmPriority: null,\n      gChatMessage : '',\n      gChatSpaceName : '',\n      \n      selectedNode: undefined,\n      entityType: undefined,\n\n      stepper: {\n        active: this.STEPPERS_DATA.analytic,\n        first: false,\n        second: false,\n        third: false,\n        fourth: false,\n        fifth: false,\n        sixth: false,\n        seventh: false,\n        eighth: false,\n      },\n    };\n  },\n  methods: {\n    async opened(option) {\n      this.selectedNode = option.selectedNode;\n      // selectedNode is the analytic node\n      const selectedNodeId = this.selectedNode.id.get();\n      const entity = await spinalAnalyticService.getEntityFromAnalytic(selectedNodeId);\n      this.entityType = entity.entityType.get();\n      this.analyticName = this.selectedNode.name.get();\n      const followedEntityNode = await spinalAnalyticService.getFollowedEntity(selectedNodeId);\n      this.followedEntity = followedEntityNode ? followedEntityNode.id.get() : undefined;\n\n      // need to get all the category names first\n      const trackingMethodNodeRef = await spinalAnalyticService.getTrackingMethod(selectedNodeId);\n      const parseInputs = await spinalAnalyticService.getAllCategoriesAndAttributesFromNode(trackingMethodNodeRef.id.get());\n      for(const inputKey of Object.keys(parseInputs)){\n        this.inputs[inputKey] = { trackingMethod : parseInputs[inputKey][ATTRIBUTE_TRACKING_METHOD],\n                                  filterValue :parseInputs[inputKey][ATTRIBUTE_FILTER_VALUE],\n                                  searchDepth : parseInputs[inputKey][ATTRIBUTE_SEARCH_DEPTH],\n                                  strictDepth : parseInputs[inputKey][ATTRIBUTE_STRICT_DEPTH],\n                                  searchRelations : parseInputs[inputKey][ATTRIBUTE_SEARCH_RELATIONS],\n                                  timeseriesIntervalTime : parseInputs[inputKey][ATTRIBUTE_TIMESERIES] };\n      }\n\n      this.inputs = { ...this.inputs };\n      //this.input = Object.assign({}, this.inputs);\n\n      console.log(this.inputs);\n      const configNode = await spinalAnalyticService.getConfig(selectedNodeId);\n      const analyticAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_ANALYTIC_PARAMETERS);\n      this.analyticDescription = analyticAttributes[ATTRIBUTE_ANALYTIC_DESCRIPTION];\n      this.analyticStatus = analyticAttributes[ATTRIBUTE_ANALYTIC_STATUS]===ANALYTIC_STATUS.ACTIVE;\n      this.analyticShouldTriggerAtStart = analyticAttributes[ATTRIBUTE_TRIGGER_AT_START];\n      const triggerAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_TRIGGER_PARAMETERS);\n      for(const triggerKey of Object.keys(triggerAttributes)){\n        let triggerValue = triggerAttributes[triggerKey].split(ATTRIBUTE_VALUE_SEPARATOR);\n        this.triggers[triggerKey] = { triggerType : triggerValue[0],\n                                      triggerValue : triggerValue[1],\n                                      changeOfValueThreshold : triggerValue[2] ? triggerValue[2] : null };\n      }\n      this.triggers = { ...this.triggers };\n\n      const algorithmMappingAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_ALGORITHM_INDEX_MAPPING);\n      for(const algorithmIndexName of Object.keys(algorithmMappingAttributes)){\n        this.algorithms[algorithmIndexName] = { name : algorithmMappingAttributes[algorithmIndexName],\n                                                params : []};\n      }\n      const algorithmParametersAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_ALGORTHM_PARAMETERS);\n      for(const algorithmIndexName of Object.keys(this.algorithms)){\n        let algoName = this.algorithms[algorithmIndexName].name;\n        const doc = algos[algoName].requiredParams;\n        for(let i = 0 ; i<doc.length; i++){\n          this.algorithms[algorithmIndexName].params.push(algorithmParametersAttributes[`${algorithmIndexName}${ATTRIBUTE_SEPARATOR}${doc[i].name}`]);\n        }\n      }\n      this.algorithms = { ...this.algorithms };\n\n      const resultAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_RESULT_PARAMETERS);\n      this.resultType = resultAttributes[ATTRIBUTE_RESULT_TYPE];\n      this.resultName = resultAttributes[ATTRIBUTE_RESULT_NAME];\n      if ([ANALYTIC_RESULT_TYPE.TICKET,ANALYTIC_RESULT_TYPE.ALARM].includes(this.resultType)){\n        const ticketAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_TICKET_LOCALIZATION_PARAMETERS);\n        this.ticketContextId = ticketAttributes[ATTRIBUTE_TICKET_CONTEXT_ID];\n        this.ticketProcessId = ticketAttributes[ATTRIBUTE_TICKET_PROCESS_ID];\n        if(this.resultType === ANALYTIC_RESULT_TYPE.ALARM){\n          this.alarmPriority = ticketAttributes[ATTRIBUTE_ALARM_PRIORITY];\n        }\n      }\n      if ([ANALYTIC_RESULT_TYPE.SMS].includes(this.resultType)){\n        const smsAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_TWILIO_PARAMETERS);\n        this.phoneNumber = smsAttributes[ATTRIBUTE_PHONE_NUMBER];\n        this.phoneMessage = smsAttributes[ATTRIBUTE_PHONE_MESSAGE];\n      }\n\n      if([ANALYTIC_RESULT_TYPE.GCHAT_MESSAGE,ANALYTIC_RESULT_TYPE.GCHAT_ORGAN_CARD].includes(this.resultType)){\n        const gChatAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_GCHAT_PARAMETERS);\n        this.gChatMessage = gChatAttributes[ATTRIBUTE_GCHAT_MESSAGE];\n        this.gChatSpaceName = gChatAttributes[ATTRIBUTE_GCHAT_SPACE];\n      }\n      const ioAttributes = await spinalAnalyticService.getAttributesFromNode(configNode.id.get(),CATEGORY_ATTRIBUTE_IO_DEPENDENCIES);\n      for(const ioDependencyName of Object.keys(ioAttributes)){\n        let ioDependencyValue = ioAttributes[ioDependencyName].split(ATTRIBUTE_VALUE_SEPARATOR);\n        this.ioDependencies[ioDependencyName] = ioDependencyValue;\n      }\n      this.ioDependencies = { ...this.ioDependencies };\n    },\n\n    async removed(res) {\n      if (res.closeResult) {\n        // there must be a better way to get the context id...\n        const contextId = Object.keys(this.selectedNode.contextIds.get())[0];\n        const followedEntityNodeRef = await spinalAnalyticService.getFollowedEntity(this.selectedNode.id.get());\n        if (followedEntityNodeRef && followedEntityNodeRef.id.get() !== this.followedEntity) {\n          console.log(\"change followed entity\");\n          await spinalAnalyticService.removeLinkToFollowedEntity(this.selectedNode.id.get(), followedEntityNodeRef.id.get());\n          await spinalAnalyticService.addInputLinkToFollowedEntity(contextId,this.selectedNode.id.get(), this.followedEntity);\n        }\n        if(!followedEntityNodeRef){\n          await spinalAnalyticService.addInputLinkToFollowedEntity(contextId,this.selectedNode.id.get(), this.followedEntity);\n        }\n\n\n\n        const trackingMethodAttributes = this.getTrackingMethodAttributes();\n        console.log('trackingMethodAttributes :', trackingMethodAttributes);\n        const trackingMethodNodeRef = await spinalAnalyticService.getTrackingMethod(\n          this.selectedNode.id.get(),\n        );\n        const trackingMethodNode =  SpinalGraphService.getRealNode(\n          trackingMethodNodeRef.id.get(),\n        );\n        await spinalAnalyticService.addAttributesToNode(\n          trackingMethodNode,\n          trackingMethodAttributes,\n        );\n\n        \n        const configAttributes = {};\n        const analyticAttributes = this.getAnalyticAttributes();\n        configAttributes[\n          CATEGORY_ATTRIBUTE_ANALYTIC_PARAMETERS\n        ] = analyticAttributes;\n\n\n        const resultAttributes = this.getResultAttributes();\n        configAttributes[\n          CATEGORY_ATTRIBUTE_RESULT_PARAMETERS\n        ] = resultAttributes;\n\n        const algorithmParametersAttributes = this.getAlgorithmParametersAttributes();\n        configAttributes[\n          CATEGORY_ATTRIBUTE_ALGORTHM_PARAMETERS\n        ] = algorithmParametersAttributes;\n\n        const algorithmMappingAttributes = this.getAlgorithmMappingAttributes();\n        configAttributes[\n          CATEGORY_ATTRIBUTE_ALGORITHM_INDEX_MAPPING\n        ] = algorithmMappingAttributes;\n\n        if (this.ticketContextId && this.ticketProcessId) {\n          const ticketAttributes = this.getTicketAttributes();\n          configAttributes[\n            CATEGORY_ATTRIBUTE_TICKET_LOCALIZATION_PARAMETERS\n          ] = ticketAttributes;\n        }\n\n        if(this.resultType == ANALYTIC_RESULT_TYPE.SMS){\n          const smsAttributes = this.getSMSAttributes();\n          configAttributes[\n            CATEGORY_ATTRIBUTE_TWILIO_PARAMETERS\n          ] = smsAttributes;\n        };\n\n        if([ANALYTIC_RESULT_TYPE.GCHAT_MESSAGE,ANALYTIC_RESULT_TYPE.GCHAT_ORGAN_CARD].includes(this.resultType)){\n          const gChatAttributes = this.getGChatAttributes();\n          configAttributes[\n            CATEGORY_ATTRIBUTE_GCHAT_PARAMETERS\n          ] = gChatAttributes;\n        };\n\n        const ioAttributes = this.getIOAttributes();\n        configAttributes[\n          CATEGORY_ATTRIBUTE_IO_DEPENDENCIES\n        ] = ioAttributes;\n\n        const triggerAttributes = this.getTriggerAttributes();\n        configAttributes[\n          CATEGORY_ATTRIBUTE_TRIGGER_PARAMETERS\n        ] = triggerAttributes;\n\n\n\n        const configNodeRef = await spinalAnalyticService.getConfig(\n          this.selectedNode.id.get()\n        );\n        const configNode = SpinalGraphService.getRealNode(\n          configNodeRef.id.get()\n        );\n        await spinalAnalyticService.addAttributesToNode(\n          configNode,\n          configAttributes\n        );\n        \n        \n      }\n\n      this.showDialog = false;\n    },\n\n    closeDialog(closeResult) {\n      if (typeof this.onFinised === 'function') {\n        this.onFinised({\n          closeResult,\n          analyticName: this.analyticName,\n        });\n      }\n    },\n\n    addInput() {\n      let length = Object.keys(this.inputs).length;\n      console.log('adding input');\n      this.inputs = { ...this.inputs, [`I${length}`]: { trackingMethod: '', filterValue: '', searchDepth:0, strictDepth:false, searchRelations:'', timeseriesIntervalTime : 0 }};\n    },\n\n    removeInput(inputName) {\n      delete this.inputs[inputName];\n      let index = Number(inputName.match(/(\\d+)/)[0]);\n      // shift back all the inputs after the deleted one.\n      let i = index;\n      while (this.inputs[`I${i + 1}`] !== undefined) {\n        this.inputs[`I${i}`] = this.inputs[`I${i + 1}`];\n        i++;\n      }\n      // Remove the last item.\n      delete this.inputs[`I${i}`];\n\n      this.inputs = { ...this.inputs };\n      console.log(\"deleted input : \", inputName);\n    },\n\n    addTrigger() {\n      let length = Object.keys(this.triggers).length;\n      console.log('adding input');\n      this.triggers = { ...this.triggers, [`T${length}`]: { triggerType: '', triggerValue: '', changeOfValueThreshold : 0 }};\n      \n    },\n\n    removeTrigger(triggerName) {\n      delete this.triggers[triggerName];\n      let index = Number(triggerName.match(/(\\d+)/)[0]);\n      // shift back all the elements after the deleted one.\n      let i = index;\n      while (this.triggers[`T${i + 1}`] !== undefined) {\n        this.triggers[`T${i}`] = this.triggers[`T${i + 1}`];\n        i++;\n      }\n      // Remove the last item.\n      delete this.triggers[`T${i}`];\n\n      this.triggers = { ...this.triggers };\n      console.log(\"deleted trigger : \", triggerName);\n    },\n\n    addAlgorithm(){\n      let length = Object.keys(this.algorithms).length;\n      console.log('adding algorithm');\n      this.algorithms = { ...this.algorithms, [`A${length}`]: { name :'', params: []}};\n    },\n\n    removeAlgorithm(algorithmIndexName){\n      delete this.algorithms[algorithmIndexName];\n      let index = Number(algorithmIndexName.match(/(\\d+)/)[0]);\n      // shift back all the elements after the deleted one.\n      let i = index;\n      while (this.algorithms[`A${i + 1}`] !== undefined) {\n        this.algorithms[`A${i}`] = this.algorithms[`A${i + 1}`];\n        i++;\n      }\n      // Remove the last item.\n      delete this.algorithms[`A${i}`];\n\n      this.algorithms = { ...this.algorithms };\n      console.log(\"deleted algorithm : \", algorithmIndexName);\n    },\n\n    changeStep(stepId) {\n      this.stepper.active = stepId;\n    },\n\n    PassToNextStep() {\n      switch (this.stepper.active) {\n        case this.STEPPERS_DATA.analytic:\n          this.stepper.first = true;\n          this.stepper.active = this.STEPPERS_DATA.followedEntity;\n          break;\n        case this.STEPPERS_DATA.followedEntity:\n          this.stepper.second = true;\n          this.stepper.active = this.STEPPERS_DATA.inputConfiguration;\n          break;\n        case this.STEPPERS_DATA.inputConfiguration:\n          this.stepper.third = true;\n          this.stepper.active = this.STEPPERS_DATA.triggerConfiguration;\n          break;\n        case this.STEPPERS_DATA.triggerConfiguration:\n          this.stepper.fourth = true;\n          this.stepper.active = this.STEPPERS_DATA.algorithmConfiguration;\n          break;\n        case this.STEPPERS_DATA.algorithmConfiguration:\n          this.stepper.fifth = true;\n          this.stepper.active = this.STEPPERS_DATA.resultConfiguration;\n          break;\n        case this.STEPPERS_DATA.resultConfiguration:\n          this.stepper.sixth = true;\n          this.stepper.active = this.STEPPERS_DATA.IODependencies;\n          break;\n        case this.STEPPERS_DATA.IODependencies:\n          this.stepper.seventh = true;\n          this.stepper.active = this.STEPPERS_DATA.summary;\n          break;\n        case this.STEPPERS_DATA.summary:\n          this.stepper.eighth = true;\n          this.stepper.active = this.STEPPERS_DATA.summary;\n          break;\n      }\n    },\n\n    isSaveButtonDisabled() {\n      return (\n        this.analyticName === '' ||\n        this.algorithm === '' ||\n        this.resultType === '' ||\n        this.resultName === '' ||\n        this.intervalTime === null ||\n        !this.followedEntity\n      );\n    },\n\n    getTrackingMethodAttributes(){\n      const trackingMethodAttributes = {};\n      for ( const inputKey of Object.keys(this.inputs))\n      {\n        trackingMethodAttributes[inputKey] = []\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_TRACKING_METHOD}`,\n                  type: 'string',\n                  value: this.inputs[inputKey].trackingMethod });\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_FILTER_VALUE}`,\n                  type: 'string',\n                  value: this.inputs[inputKey].filterValue });\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_SEARCH_DEPTH}`,\n                  type: 'number',\n                  value: this.inputs[inputKey].searchDepth });\n\n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_STRICT_DEPTH}`,\n                  type: 'boolean',\n                  value: this.inputs[inputKey].strictDepth });\n                  \n        trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_SEARCH_RELATIONS}`,\n                  type: 'string',\n                  value: this.inputs[inputKey].searchRelations });\n\n        if([TRACK_METHOD.CONTROL_ENDPOINT_NAME_FILTER,TRACK_METHOD.ENDPOINT_NAME_FILTER].includes(this.inputs[inputKey].trackingMethod) ){\n          trackingMethodAttributes[inputKey].push({ name: `${ATTRIBUTE_TIMESERIES}`,\n                  type: 'number',\n                  value: this.inputs[inputKey].timeseriesIntervalTime });\n        }\n        \n      }\n      return trackingMethodAttributes;\n    },\n\n    getAnalyticAttributes(){\n      const analyticAttributes = [];\n      analyticAttributes.push({\n        name: `${ATTRIBUTE_ANALYTIC_DESCRIPTION}`,\n        type: 'string',\n        value: this.analyticDescription,\n      });\n      analyticAttributes.push({\n        name: `${ATTRIBUTE_ANALYTIC_STATUS}`,\n        type: 'string',\n        value: this.analyticStatus? ANALYTIC_STATUS.ACTIVE : ANALYTIC_STATUS.INACTIVE,\n      });\n      analyticAttributes.push({\n        name: `${ATTRIBUTE_TRIGGER_AT_START}`,\n        type: 'boolean',\n        value: this.analyticShouldTriggerAtStart,\n      });\n      return analyticAttributes;\n    },\n\n    getResultAttributes(){\n      const resultAttributes = [];\n      resultAttributes.push({\n        name: `${ATTRIBUTE_RESULT_TYPE}`,\n        type: 'string',\n        value: this.resultType,\n      });\n      resultAttributes.push({\n        name: `${ATTRIBUTE_RESULT_NAME}`,\n        type: 'string',\n        value: this.resultName,\n      });\n      return resultAttributes;\n    },\n\n    getAlgorithmParametersAttributes(){\n      const algorithmParametersAttributes = [];\n      for (const algorithmIndexName of Object.keys(this.algorithms)) {\n        let algoName = this.algorithms[algorithmIndexName].name;\n        const doc = algos[algoName].requiredParams;\n        for(let i = 0 ; i<this.algorithms[algorithmIndexName].params.length; i++){\n          algorithmParametersAttributes.push({\n            name: `${algorithmIndexName}${ATTRIBUTE_SEPARATOR}${doc[i].name}`,\n            value: doc[i].type === 'number' ? + this.algorithms[algorithmIndexName].params[i] : this.algorithms[algorithmIndexName].params[i],\n            type: doc[i].type,\n          });\n        }\n      }\n      return algorithmParametersAttributes;\n    },\n\n    getAlgorithmMappingAttributes(){\n      const algorithmMappingAttributes = [];\n      for (const algorithmIndexName of Object.keys(this.algorithms)) {\n        algorithmMappingAttributes.push({\n          name: `${algorithmIndexName}`,\n          type: 'string',\n          value: this.algorithms[algorithmIndexName].name,\n        });\n      }\n      return algorithmMappingAttributes;\n    },\n\n    getTicketAttributes(){\n      const ticketAttributes = [];\n      ticketAttributes.push({\n        name: `${ATTRIBUTE_TICKET_CONTEXT_ID}`,\n        type: 'string',\n        value: this.ticketContextId,\n      });\n      ticketAttributes.push({\n        name: `${ATTRIBUTE_TICKET_PROCESS_ID}`,\n        type: 'string',\n        value: this.ticketProcessId,\n      });\n      if(this.alarmPriority){\n          ticketAttributes.push({\n            name: `${ATTRIBUTE_ALARM_PRIORITY}`,\n            value: this.alarmPriority,\n            type: 'number',\n          });\n        }\n      return ticketAttributes;\n    },\n\n    getSMSAttributes(){\n      const smsAttributes = [];\n      smsAttributes.push({\n        name: `${ATTRIBUTE_PHONE_NUMBER}`,\n        type: 'string',\n        value: this.phoneNumber,\n      });\n      smsAttributes.push({\n        name: `${ATTRIBUTE_PHONE_MESSAGE}`,\n        type: 'string',\n        value: this.phoneMessage,\n      });\n      return smsAttributes;\n    },\n\n    getGChatAttributes(){\n      const gChatAttributes = [];\n      gChatAttributes.push({\n        name: `${ATTRIBUTE_GCHAT_MESSAGE}`,\n        type: 'string',\n        value: this.gChatMessage,\n      });\n      gChatAttributes.push({\n        name: `${ATTRIBUTE_GCHAT_SPACE}`,\n        type: 'string',\n        value: this.gChatSpaceName,\n      });\n      return gChatAttributes;\n    },\n\n    getIOAttributes(){\n      const ioAttributes = [];\n      for (const ioDependencyName of Object.keys(this.ioDependencies)) {\n        let str = \"\";\n        for (const ioDependency of this.ioDependencies[ioDependencyName]) {\n          str += `${ioDependency}${ATTRIBUTE_VALUE_SEPARATOR}`;\n        }\n        str = str.slice(0, -1);\n        ioAttributes.push({\n          name: `${ioDependencyName}`,\n          type: 'string',\n          value: str,\n        });\n      }\n      return ioAttributes;\n    },\n\n    getTriggerAttributes(){\n      const triggerAttributes = [];\n      for (const triggerIndex of Object.keys(this.triggers)) {\n        let str = `${this.triggers[triggerIndex].triggerType}${ATTRIBUTE_VALUE_SEPARATOR}${this.triggers[triggerIndex].triggerValue}`;\n        if (this.triggers[triggerIndex].changeOfValueThreshold !== null) {\n          str += `${ATTRIBUTE_VALUE_SEPARATOR}${this.triggers[triggerIndex].changeOfValueThreshold}`;\n        }\n        triggerAttributes.push({\n          name: `${triggerIndex}`,\n          type: 'string',\n          value: str,\n        });\n      }\n      return triggerAttributes;\n    },\n\n  },\n};\n</script>\n\n<style scoped>\n.mdDialog {\n  width: 1200px;\n  max-width: 1500px;\n  height: 600px;\n}\n\n.mdDialog .mdDialogTitle {\n  text-align: center;\n}\n\n.mdDialog .mdDialogContainer {\n  width: 1200px;\n  max-width: 1500px;\n  height: 100%;\n  overflow: auto;\n}\n\n.fixed-size-field {\n  width: 85%;\n  max-width: 85%;\n}\n\n.md-dialog-actions {\n  padding: 8px 16px; /* Add this line */\n  margin: 0; /* Add this line */\n}\n\n.md-button {\n  margin: 0 8px; /* Add this line */\n}\n\n.mdDialog .mdDialogContainer .mdStep {\n  height: 350px;\n  padding: 10px 0px;\n  overflow: auto;\n}\n</style>\n\n<style>\n.mdDialog .mdDialogContainer .mdStep .md-stepper-content.md-active {\n  width: 100%;\n  height: 100%;\n}\n.fixed-size-field {\n  width: 85%;\n  max-width: 85%;\n}\n\n.mdDialog .mdDialogContainer .mdStep .contents {\n  width: 100%;\n  height: 100%;\n  align-items: center;\n  overflow: auto;\n}\n</style>\n","<!--\nCopyright 2020 SpinalCom - www.spinalcom.com\n\nThis file is part of SpinalCore.\n\nPlease read all of the following terms and conditions\nof the Free Software license Agreement (\"Agreement\")\ncarefully.\n\nThis Agreement is a legally binding contract between\nthe Licensee (as defined below) and SpinalCom that\nsets forth the terms and conditions that govern your\nuse of the Program. By installing and/or using the\nProgram, you agree to abide by all the terms and\nconditions stated or referenced herein.\n\nIf you do not agree to abide by these terms and\nconditions, do not demonstrate your acceptance and do\nnot install or use the Program.\nYou should have received a copy of the license along\nwith this file. If not, see\n<http://resources.spinalcom.com/licenses.pdf>.\n-->\n\n<template>\n\t<md-content class=\"mdContent\">\n\t\t<div class=\"header\">\n\t\t\t<div class=\"buscar-caja\" :class=\"{ isOpened: isOpened }\">\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tname=\"\"\n\t\t\t\t\tclass=\"buscar-txt\"\n\t\t\t\t\tplaceholder=\"Search...\"\n\t\t\t\t\t:class=\"{ isOpened: isOpened }\"\n\t\t\t\t\tv-model=\"search\"\n\t\t\t\t/>\n\t\t\t\t<a class=\"md-icon-button buscar-btn\" @click=\"openSearchBar\">\n\t\t\t\t\t<md-icon>search</md-icon>\n\t\t\t\t</a>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div\n\t\t\tv-if=\"tempList.length > 0 && appState === STATES.normal\"\n\t\t\tclass=\"_container\"\n\t\t>\n\t\t\t<md-content class=\"listItem md-scrollbar\">\n\t\t\t\t<RecycleScroller\n\t\t\t\t\t:items=\"tempList\"\n\t\t\t\t\t:item-size=\"60\"\n\t\t\t\t\tkey-field=\"id\"\n\t\t\t\t\tv-slot=\"{ item }\"\n\t\t\t\t>\n\t\t\t\t\t<div class=\"listContainer\">\n\t\t\t\t\t\t<span class=\"md-list-item-text\">{{ item.name }}</span>\n\n\t\t\t\t\t\t<md-button\n\t\t\t\t\t\t\tclass=\"md-icon-button panel_link_button\"\n\t\t\t\t\t\t\t@click=\"linkUnlink(item)\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<md-icon>{{ getIcon(item) }}</md-icon>\n\t\t\t\t\t\t</md-button>\n\t\t\t\t\t</div>\n\t\t\t\t</RecycleScroller>\n\t\t\t</md-content>\n\t\t</div>\n\n\t\t<div\n\t\t\tclass=\"_container empty\"\n\t\t\tv-if=\"tempList.length === 0 && appState === STATES.normal\"\n\t\t>\n\t\t\tNo Data found !\n\t\t</div>\n\n\t\t<div class=\"_container empty\" v-if=\"appState === STATES.loading\">\n\t\t\t<md-progress-spinner\n\t\t\t\tclass=\"spiner\"\n\t\t\t\tmd-mode=\"indeterminate\"\n\t\t\t></md-progress-spinner>\n\t\t</div>\n\n\t\t<div class=\"_container empty\" v-if=\"appState === STATES.error\">\n\t\t\tSorry, Something was wrong. Please retry !!\n\t\t</div>\n\t</md-content>\n</template>\n\n<script>\n\timport Vue from \"vue\";\n\n\timport { groupManagerService } from \"spinal-env-viewer-plugin-group-manager-service\";\n\timport { spinalAnalyticService } from \"spinal-env-viewer-plugin-analytics-service\";\n\n\timport { RecycleScroller } from \"vue-virtual-scroller\";\n\n\tVue.component(\"RecycleScroller\", RecycleScroller);\n\n\texport default {\n\t\tname: \"linkGroupToAnalyticPanel\",\n\t\tcomponents: {\n\t\t\t// \"pagination-component\": paginationComponent,\n\t\t\t// \"filter-menu\": filterMenu,\n\t\t\t// \"virtual-scroller\": VueVirtualScroller,\n\t\t},\n\t\tdata() {\n\t\t\tthis.STATES = {\n\t\t\t\tnormal: 1,\n\t\t\t\tloading: 2,\n\t\t\t\terror: 3,\n\t\t\t};\n\t\t\tthis.contextId;\n\t\t\tthis.analyticId;\n\t\t\tthis.childrenType;\n\n\t\t\tthis.data = [];\n\n\t\t\tthis.countPerPage = 10;\n\n\t\t\treturn {\n\t\t\t\tsearch: \"\",\n\t\t\t\tisOpened: false,\n\t\t\t\ttempList: [],\n\t\t\t\tdataLinked: [],\n\t\t\t\tcurrentPage: 1,\n\t\t\t\tappState: this.STATES.normal,\n\t\t\t};\n\t\t},\n\t\tmethods: {\n\t\t\tasync opened(option) {\n\t\t\t\tthis.appState = this.STATES.loading;\n\t\t\t\tthis.contextId = option.contextId;\n\t\t\t\tthis.analyticId = option.analyticId;\n\t\t\t\tthis.childrenType = option.childrenType;\n\n\t\t\t\tPromise.all([\n\t\t\t\t\tthis.getGroupsLinked(this.analyticId),\n\t\t\t\t\tthis.getAllGroups(this.childrenType),\n\t\t\t\t])\n\t\t\t\t\t.then(([linked, groups]) => {\n\t\t\t\t\t\tthis.data = groups;\n\t\t\t\t\t\tthis.tempList = groups;\n\t\t\t\t\t\tthis.dataLinked = linked;\n\t\t\t\t\t\tthis.appState = this.STATES.normal;\n\t\t\t\t\t})\n\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\tthis.appState = this.STATES.error;\n\t\t\t\t\t});\n\t\t\t},\n\n\t\t\tisLinked(item) {\n\t\t\t\treturn this.dataLinked.find((el) => {\n\t\t\t\t\treturn item.id === el.id;\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tgetIcon(item) {\n\t\t\t\treturn typeof this.isLinked(item) === \"undefined\"\n\t\t\t\t\t? \"link\"\n\t\t\t\t\t: \"link_off\";\n\t\t\t},\n\n\t\t\t// eventMethod(eventName, item) {\n\t\t\t// \tEventBus.$emit(eventName, item);\n\t\t\t// },\n\n\t\t\topenSearchBar() {\n\t\t\t\tthis.isOpened = !this.isOpened;\n\t\t\t},\n\n\t\t\tasync linkUnlink(item) {\n\t\t\t\tif (!this.isLinked(item)) {\n\t\t\t\t\tawait spinalAnalyticService.linkGroupToAnalytic(\n\t\t\t\t\t\tthis.contextId,\n\t\t\t\t\t\tthis.analyticId,\n\t\t\t\t\t\titem.id\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.dataLinked.push(item);\n\t\t\t\t} else {\n\t\t\t\t\tconst removed =\n\t\t\t\t\t\tawait spinalAnalyticService.unLinkGroupToAnalytic(\n\t\t\t\t\t\t\tthis.analyticId,\n\t\t\t\t\t\t\titem.id\n\t\t\t\t\t\t);\n\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tthis.dataLinked = this.dataLinked.filter(\n\t\t\t\t\t\t\t(el) => el.id !== item.id\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync getGroupsLinked(analyticId) {\n\t\t\t\tconst groups = await spinalAnalyticService.getGroupsLinked(\n\t\t\t\t\tanalyticId\n\t\t\t\t);\n\t\t\t\treturn groups.map((group) => group.get());\n\t\t\t},\n\n\t\t\tasync getAllGroups(type) {\n\t\t\t\tconst contexts = await groupManagerService.getGroupContexts(type);\n\t\t\t\tconst promises = contexts.map((el) => {\n\t\t\t\t\treturn groupManagerService.getGroups(el.id);\n\t\t\t\t});\n\n\t\t\t\treturn Promise.all(promises).then((result) => {\n\t\t\t\t\tconst _result = result.flat();\n\t\t\t\t\treturn _result.map((el) => el.get());\n\t\t\t\t});\n\t\t\t},\n\t\t},\n\t\twatch: {\n\t\t\tsearch: function (newValue) {\n\t\t\t\tnewValue = newValue.trim();\n\t\t\t\t// console.log(\"newValue\", newValue);\n\t\t\t\tif (newValue.length === 0) {\n\t\t\t\t\tthis.tempList = [...this.data];\n\t\t\t\t} else {\n\t\t\t\t\tthis.tempList = this.data.filter((el) => {\n\t\t\t\t\t\treturn el.name.toLowerCase().includes(newValue.toLowerCase());\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t// computed: {\n\t\t//   isOpened: function() {\n\t\t//     return this.search.trim().length > 0;\n\t\t//   }\n\t\t// }\n\t};\n</script>\n\n<style scoped>\n\t.mdContent {\n\t\twidth: 100%;\n\t\theight: calc(100% - 15px);\n\t}\n\n\t.header {\n\t\twidth: 100%;\n\t\theight: 40px;\n\t\tdisplay: flex;\n\t\tflex-direction: row-reverse;\n\t\tmargin-bottom: 10px;\n\t}\n\n\t._container {\n\t\twidth: 100%;\n\t\theight: calc(100% - 50px);\n\t\toverflow: hidden;\n\t}\n\n\t._container .listItem {\n\t\twidth: 98%;\n\t\theight: calc(100% - 10px);\n\t\toverflow: hidden;\n\t\toverflow-y: auto;\n\t\tmargin: auto;\n\t}\n\n\t._container .listItem .listcontent {\n\t\twidth: 95%;\n\t\tmargin: auto;\n\t}\n\n\t.empty {\n\t\twidth: 100%;\n\t\theight: calc(100% - 50px);\n\t\t/* text-align: center; */\n\t\tfont-size: 20px;\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t}\n\n\t.listContainer {\n\t\twidth: 95%;\n\t\theight: 60px;\n\t\tfont-size: 1.2em;\n\t\tpadding: 0 5px 0 5px;\n\t\tborder-bottom: 1px solid white;\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t\talign-items: center;\n\t}\n\n\t.listContainer:hover {\n\t\tcursor: pointer;\n\t\tbackground-color: gray;\n\t}\n\n\t.paginationContent {\n\t\twidth: 40%;\n\t\tmargin: auto;\n\t\theight: 40px;\n\t}\n\n\t.paginationContent {\n\t\twidth: 100%;\n\t\theight: 40px;\n\t}\n\n\t/* .groupColor {\n\t\twidth: 24px;\n\t\theight: 24px;\n\t\tborder: 1px solid white;\n\t}\n\n\t.spiner {\n\t\tposition: absolute;\n\t\ttop: calc(50% - 30px);\n\t\tright: calc(50% - 30px);\n\t} */\n</style>\n\n<style>\n\t.listContainer .md-list-item-content {\n\t\tpadding-left: 5px;\n\t\t/* padding-top: 4px;\n  padding-bottom: 4px; */\n\t}\n\n\t.listContainer .panel_link_button .md-ripple {\n\t\tpadding: unset !important;\n\t}\n\n\t/*\n//////////////////////////////////////////////////////////////////\n*/\n\n\t.buscar-caja {\n\t\t/* position: absolute; */\n\t\t/* top: 50%;\n  left: 50%; */\n\t\t/* right: 0; */\n\t\t/* transform: translate(-50%, -50%); */\n\t\t/* background: #2f3640; */\n\t\theight: 35px;\n\t\tborder-radius: 40px;\n\t\tmargin-top: 5px;\n\t\t/* padding: 10px; */\n\t}\n\n\t.buscar-caja.isOpened {\n\t\tbackground: #2f3640;\n\t}\n\n\t/* .buscar-caja:hover > .buscar-txt, */\n\t.buscar-caja > .buscar-txt.isOpened {\n\t\twidth: 240px;\n\t\tpadding: 0 6px;\n\t}\n\n\t/* .buscar-caja:hover > .buscar-btn {\n  background: white;\n  color: black;\n} */\n\n\t.buscar-btn {\n\t\tcolor: #e84118;\n\t\tfloat: right;\n\t\twidth: 40px;\n\t\theight: 35px;\n\t\tborder-radius: 50%;\n\t\t/* background: #2f3640; */\n\t\tdisplay: flex;\n\t\tjustify-content: center;\n\t\talign-items: center;\n\t\ttransition: 0.4s;\n\t\tcolor: white;\n\t\tcursor: pointer;\n\t}\n\n\t.buscar-btn > i {\n\t\tfont-size: 30px;\n\t}\n\n\t.buscar-txt {\n\t\tborder: none;\n\t\tbackground: none;\n\t\toutline: none;\n\t\tfloat: left;\n\t\tpadding: 0;\n\t\tcolor: white;\n\t\tfont-size: 16px;\n\t\ttransition: 0.4s;\n\t\tline-height: 40px;\n\t\twidth: 0px;\n\t\t/* font-weight: bold; */\n\t}\n\n\t/*\n//////////////////////////////////////////////////////////\n//                VUe scroll\n//////////////////////////////////////////////////////////\n*/\n\t.vue-recycle-scroller {\n\t\tposition: relative;\n\t}\n\t.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n\t\toverflow-y: auto;\n\t}\n\t.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n\t\toverflow-x: auto;\n\t}\n\t.vue-recycle-scroller.direction-horizontal {\n\t\tdisplay: -webkit-box;\n\t\tdisplay: -ms-flexbox;\n\t\tdisplay: flex;\n\t}\n\t.vue-recycle-scroller__slot {\n\t\t-webkit-box-flex: 1;\n\t\t-ms-flex: auto 0 0px;\n\t\tflex: auto 0 0;\n\t}\n\t.vue-recycle-scroller__item-wrapper {\n\t\t-webkit-box-flex: 1;\n\t\t-ms-flex: 1;\n\t\tflex: 1;\n\t\t-webkit-box-sizing: border-box;\n\t\tbox-sizing: border-box;\n\t\toverflow: hidden;\n\t\tposition: relative;\n\t}\n\t.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\twill-change: transform;\n\t}\n\n\t.vue-recycle-scroller.direction-vertical\n\t\t.vue-recycle-scroller__item-wrapper {\n\t\twidth: 100%;\n\t}\n\n\t.vue-recycle-scroller.direction-horizontal\n\t\t.vue-recycle-scroller__item-wrapper {\n\t\theight: 100%;\n\t}\n\t.vue-recycle-scroller.ready.direction-vertical\n\t\t.vue-recycle-scroller__item-view {\n\t\twidth: 100%;\n\t}\n\t.vue-recycle-scroller.ready.direction-horizontal\n\t\t.vue-recycle-scroller__item-view {\n\t\theight: 100%;\n\t}\n\t.resize-observer[data-v-b329ee4c] {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\tz-index: -1;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tborder: none;\n\t\tbackground-color: transparent;\n\t\tpointer-events: none;\n\t\tdisplay: block;\n\t\toverflow: hidden;\n\t\topacity: 0;\n\t}\n\t.resize-observer[data-v-b329ee4c] object {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\theight: 100%;\n\t\twidth: 100%;\n\t\toverflow: hidden;\n\t\tpointer-events: none;\n\t\tz-index: -1;\n\t}\n</style>\n"],"names":[],"version":3,"file":"spinal-env-viewer-plugin-analysis.1015c7c0.css.map"}