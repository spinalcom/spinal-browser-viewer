{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A;ACAA;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,kB,A,I,I,I,C,mB,C,O,S,S,C,E,C,E,C,E,E;I,I,O,W,K;I,I,O,O,yB,G;I,I,C,Q,C,S,O,C,E,a,K,Y,K,Y,G,O;Q,Y;Q,K;Y,O,C,C,E;Q;I;I,O,e,G,I;A,I,S,C,E,C,E,C,E,E;I,I,O,W,K;I,C,C,G,G,C,C,E;A,C;A,I,e,A,I,I,I,C,gB,S,C,E,Q;I,I,I,K,E,I,M,a,C,O,U,e,K,U,I,gB,U,G;A;A,I,Y,A,I,I,I,C,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;A,O,e,S,c;I,O;A;AAIH,MAAA,YAAA,QAAA;AACA,MAAA,iBAAA,QAAA;AAeA,MAAA,iBAAA,QAAA;AAMA,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;AAEA;;;;;;CAMG,GACH,SAAe,mBACb,UAAyB,EACzB,aAA4B,EAC5B,WAAmB;I,O,U,I,E,K,G,K,G;QAEnB,MAAM,UAAyB,AAAA,CAAA,GAAA,eAAA,WAAA,EAAY,WAAW,GAAG;QACzD,MAAM,SAAqB,AAAA,CAAA,GAAA,eAAA,WAAA,EAAY,cAAc,GAAG;QACxD,MAAM,OAAO,MAAM,AAAA,CAAA,GAAA,eAAA,kBAAA,EAAqB,SAAS,QAAQ;QACzD,CAAA,GAAA,eAAA,mBAAA,EAAoB;QACpB,OAAO,AAAA,CAAA,GAAA,eAAA,mBAAA,EAAoB,KAAK,KAAK,GAAG;IAC1C;AAAC;AAED;;;;CAIG,GACH,SAAe,YACb,SAAiB,EACjB,QAAgB,EAChB,YAAoB;I,O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BAAoB,OAAO,OAC/B,IAAI,IAAI;IACN;QAAC;QAAe;KAAU;IAC1B;QAAC;QAAmB;KAAc;IAClC;QAAC;QAAgB;KAAW;IAC5B;QAAC;QAAe;KAAU;IAC1B;QAAC;QAAe;KAAU;IAC1B;QAAC;QAAoB;KAAe;CACrC;AAsBD,QAAA,oBAAA;;;A;A,I,Y,A,I,I,I,C,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;A,I,U,A,I,I,I,C,W,S,C;I,O,I,Y,U,C,I,C,I,G,I,A,I,I,Q;A;A,I,mB,A,I,I,I,C,oB,S,O,E,U,E,S;I,I,C,O,e,M,I,U;I,I,I,U,M,S,c,E,G,G,I,E;I,O,I,C,G,K,S,K,U,K,W,C,C,O,c,G;Q,O,I;I,G;I,S,K,C;Q,I,C,C,E,E,C,C,E,G,S,C;Y,O,I,Q,S,C,E,C;gB,E,K;oB;oB;oB;oB;iB,I,K,O,G;Y;Q;I;I,S,O,C,E,C;Q,I;Y,K,C,C,E,C;Q,E,O,G;Y,O,C,C,E,C,E,E;Q;I;I,S,K,C;Q,E,iB,U,Q,Q,E,M,G,K,S,U,O,C,C,E,C,E,E;I;I,S,Q,K;Q,O,Q;I;I,S,O,K;Q,O,S;I;I,S,O,C,E,C;Q,I,E,I,E,S,E,Q,O,C,C,E,C,E,E,C,C,E,C,E;I;A;A,O,e,S,c;I,O;A;A,Q,wB,Q,wB,Q,sC,Q,wB,Q,2B,Q,gB,Q,U,Q,U,Q,U,Q,W,Q,c,Q,qB,Q,gB,Q,e,K;AE7HF;;;;;;;;;;;;;;;;;;;;;;CAsBG,GACH,MAAA,uBAAA,QAAA;AAKA,MAAA,cAAA,QAAA;AAqBA,MAAA,iBAAA,QAAA;AAEA,MAAM,iBAAiB,IAAI;AAK3B;;;;CAIG,GACH,SAAgB,aAAa,UAAkB;IAC7C,IAAI,kBAAkB,YAAA,uBAAuB,QAAQ;IACrD,IAAI,oBAAoB,IACtB,OAAO;IAET,OAAO,YAAA,sBAAsB,CAAC,kBAAkB,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","sources":["node_modules/spinal-env-viewer-context-geographic-service/build/index.js","node_modules/spinal-env-viewer-context-geographic-service/src/index.ts","node_modules/spinal-env-viewer-context-geographic-service/build/constants.js","node_modules/spinal-env-viewer-context-geographic-service/src/constants.ts","node_modules/spinal-env-viewer-context-geographic-service/build/geoServiceV2.js","node_modules/spinal-env-viewer-context-geographic-service/src/geoServiceV2.ts","node_modules/spinal-env-viewer-context-geographic-service/build/graphservice.js","node_modules/spinal-env-viewer-context-geographic-service/src/graphservice.ts"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants = require(\"./constants\");\nconst geoServiceV2_1 = require(\"./geoServiceV2\");\nconst graphservice_1 = require(\"./graphservice\");\n__exportStar(require(\"./constants\"), exports);\n__exportStar(require(\"./geoServiceV2\"), exports);\n/**\n * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;\n * @param {SpinalNodeRef} contextRef - The Context geographic\n * @param {SpinalNodeRef} parentNodeRef - The parent Node\n * @param {string} elementName - The AbstactElement Name\n * @returns {Promise<SpinalNode>}\n */\nfunction addAbstractElement(contextRef, parentNodeRef, elementName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextRef.id.get());\n        const parent = (0, graphservice_1.getRealNode)(parentNodeRef.id.get());\n        const node = yield (0, geoServiceV2_1.addAbstractElement)(context, parent, elementName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return (0, graphservice_1.getInfoGraphService)(node.info.id.get());\n    });\n}\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} buildingName - Building Name\n */\nfunction addBuilding(contextId, parentId, buildingName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addBuilding)(context, parent, buildingName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} floorName - the floor Name\n */\nfunction addFloor(contextId, parentId, floorName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addFloor)(context, parent, floorName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} siteName - the site Name\n */\nfunction addSite(contextId, parentId, siteName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addSite)(context, parent, siteName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} zoneName - Zone name\n */\nfunction addZone(contextId, parentId, zoneName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addZone)(context, parent, zoneName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * @param {string} contextId - The Context geographic\n * @param {string} parentId - The parent Node\n * @param {string} roomName - Room Name\n */\nfunction addRoom(contextId, parentId, roomName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addRoom)(context, parent, roomName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * it uses bimObject service to add all dbIds passed as parameters.\n * the parameter elements can be a simple or an array of the following element interface.\n * `{ dbId: number, name: string }`\n * @param {SpinalNodeRef} contextRef - The Context geographic\n * @param {SpinalNodeRef} parentRef - The parent Node\n * @param {TAddBimElementItem | TAddBimElementItem[]} elements\n */\nfunction addBimElement(contextRef, parentRef, elements, model) {\n    let context = (0, graphservice_1.getRealNode)(contextRef.id.get());\n    let parent = (0, graphservice_1.getRealNode)(parentRef.id.get());\n    return (0, geoServiceV2_1.addBimElement)(context, parent, elements, model);\n}\nfunction _getReferenceContextName(nodeId) {\n    let node = (0, graphservice_1.getRealNode)(nodeId);\n    return (0, geoServiceV2_1._getReferenceContextName)(node.info.type.get());\n}\n/**\n *\n * @param {string} nodeId\n */\nfunction addToReferenceContext(nodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let node = (0, graphservice_1.getRealNode)(nodeId);\n        return (0, geoServiceV2_1.addToReferenceContext)(node);\n    });\n}\n/**\n *\n * @param {string} contextId\n */\nfunction addContextToReference(contextId) {\n    let context = (0, graphservice_1.getRealNode)(contextId);\n    return (0, geoServiceV2_1.addContextToReference)(context);\n}\nconst GeographicContext = {\n    constants,\n    getChildType: geoServiceV2_1.getChildType,\n    createContext: geoServiceV2_1.createContext,\n    addAbstractElement,\n    addBuilding,\n    addFloor,\n    addSite,\n    addZone,\n    addRoom,\n    addBimElement,\n    _getReferenceContextName,\n    addToReferenceContext,\n    addContextToReference,\n};\nexports.default = GeographicContext;\n//# sourceMappingURL=index.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport type { SpinalNodeRef } from 'spinal-env-viewer-graph-service';\nimport type { SpinalContext, SpinalNode } from 'spinal-model-graph';\nimport * as constants from './constants';\nimport {\n  getChildType,\n  createContext,\n  addAbstractElement as addAbstractElementv2,\n  addBuilding as addBuildingv2,\n  addFloor as addFloorv2,\n  addSite as addSitev2,\n  addZone as addZonev2,\n  addRoom as addRoomv2,\n  addBimElement as addBimElementv2,\n  _getReferenceContextName as _getReferenceContextNamev2,\n  addToReferenceContext as addToReferenceContextv2,\n  addContextToReference as addContextToReferencev2,\n  TAddBimElementItem,\n} from './geoServiceV2';\nimport {\n  addNodeGraphService,\n  getInfoGraphService,\n  getRealNode,\n} from './graphservice';\n\nexport * from './constants';\nexport * from './geoServiceV2';\n\n/**\n * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;\n * @param {SpinalNodeRef} contextRef - The Context geographic\n * @param {SpinalNodeRef} parentNodeRef - The parent Node\n * @param {string} elementName - The AbstactElement Name\n * @returns {Promise<SpinalNode>}\n */\nasync function addAbstractElement(\n  contextRef: SpinalNodeRef,\n  parentNodeRef: SpinalNodeRef,\n  elementName: string\n): Promise<SpinalNodeRef> {\n  const context: SpinalContext = getRealNode(contextRef.id.get());\n  const parent: SpinalNode = getRealNode(parentNodeRef.id.get());\n  const node = await addAbstractElementv2(context, parent, elementName);\n  addNodeGraphService(node);\n  return getInfoGraphService(node.info.id.get());\n}\n\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} buildingName - Building Name\n */\nasync function addBuilding(\n  contextId: string,\n  parentId: string,\n  buildingName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addBuildingv2(context, parent, buildingName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} floorName - the floor Name\n */\nasync function addFloor(\n  contextId: string,\n  parentId: string,\n  floorName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addFloorv2(context, parent, floorName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} siteName - the site Name\n */\nasync function addSite(\n  contextId: string,\n  parentId: string,\n  siteName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addSitev2(context, parent, siteName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} zoneName - Zone name\n */\nasync function addZone(\n  contextId: string,\n  parentId: string,\n  zoneName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addZonev2(context, parent, zoneName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * @param {string} contextId - The Context geographic\n * @param {string} parentId - The parent Node\n * @param {string} roomName - Room Name\n */\nasync function addRoom(\n  contextId: string,\n  parentId: string,\n  roomName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addRoomv2(context, parent, roomName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * it uses bimObject service to add all dbIds passed as parameters.\n * the parameter elements can be a simple or an array of the following element interface.\n * `{ dbId: number, name: string }`\n * @param {SpinalNodeRef} contextRef - The Context geographic\n * @param {SpinalNodeRef} parentRef - The parent Node\n * @param {TAddBimElementItem | TAddBimElementItem[]} elements\n */\nfunction addBimElement(\n  contextRef: SpinalNodeRef,\n  parentRef: SpinalNodeRef,\n  elements: TAddBimElementItem | TAddBimElementItem[],\n  model: any\n): Promise<unknown[]> {\n  let context = getRealNode(contextRef.id.get());\n  let parent = getRealNode(parentRef.id.get());\n  return addBimElementv2(context, parent, elements, model);\n}\n\nfunction _getReferenceContextName(nodeId: string): {\n  name: string;\n  relation: string;\n} {\n  let node = getRealNode(nodeId);\n  return _getReferenceContextNamev2(node.info.type.get());\n}\n\n/**\n *\n * @param {string} nodeId\n */\nasync function addToReferenceContext(nodeId: string): Promise<void> {\n  let node = getRealNode(nodeId);\n  return addToReferenceContextv2(node);\n}\n\n/**\n *\n * @param {string} contextId\n */\nfunction addContextToReference(contextId: string): Promise<void> {\n  let context = getRealNode(contextId);\n  return addContextToReferencev2(context);\n}\n\nconst GeographicContext = {\n  constants,\n  getChildType,\n  createContext,\n  addAbstractElement,\n  addBuilding,\n  addFloor,\n  addSite,\n  addZone,\n  addRoom,\n  addBimElement,\n  _getReferenceContextName,\n  addToReferenceContext,\n  addContextToReference,\n};\n\nexport default GeographicContext;\n","\"use strict\";\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.REFERENCE_ROOM_RELATION = exports.ROOM_REFERENCE_CONTEXT = exports.ZONE_REFERENCE_CONTEXT = exports.FLOOR_REFERENCE_CONTEXT = exports.BUILDING_REFERENCE_CONTEXT = exports.SITE_REFERENCE_CONTEXT = exports.REFERENCE_RELATION = exports.REFERENCE_TYPE = exports.MAP_RELATION_TYPE = exports.MAP_TYPE_RELATION = exports.GEOGRAPHIC_RELATIONS_ORDER = exports.EQUIPMENT_RELATION = exports.GEOGRAPHIC_RELATIONS = exports.ROOM_RELATION = exports.ZONE_RELATION = exports.FLOOR_RELATION = exports.BUILDING_RELATION = exports.SITE_RELATION = exports.GEOGRAPHIC_TYPES_ORDER = exports.EQUIPMENT_TYPE = exports.GEOGRAPHIC_TYPES = exports.ROOM_TYPE = exports.ZONE_TYPE = exports.FLOOR_TYPE = exports.BUILDING_TYPE = exports.SITE_TYPE = exports.CONTEXT_TYPE = void 0;\nconst CONTEXT_TYPE = 'geographicContext';\nexports.CONTEXT_TYPE = CONTEXT_TYPE;\nconst SITE_TYPE = 'geographicSite';\nexports.SITE_TYPE = SITE_TYPE;\nconst BUILDING_TYPE = 'geographicBuilding';\nexports.BUILDING_TYPE = BUILDING_TYPE;\nconst FLOOR_TYPE = 'geographicFloor';\nexports.FLOOR_TYPE = FLOOR_TYPE;\nconst ZONE_TYPE = 'geographicZone';\nexports.ZONE_TYPE = ZONE_TYPE;\nconst ROOM_TYPE = 'geographicRoom';\nexports.ROOM_TYPE = ROOM_TYPE;\nconst EQUIPMENT_TYPE = 'BIMObject';\nexports.EQUIPMENT_TYPE = EQUIPMENT_TYPE;\nconst REFERENCE_TYPE = 'geographicReference';\nexports.REFERENCE_TYPE = REFERENCE_TYPE;\nconst SITE_RELATION = 'hasGeographicSite';\nexports.SITE_RELATION = SITE_RELATION;\nconst BUILDING_RELATION = 'hasGeographicBuilding';\nexports.BUILDING_RELATION = BUILDING_RELATION;\nconst FLOOR_RELATION = 'hasGeographicFloor';\nexports.FLOOR_RELATION = FLOOR_RELATION;\nconst ZONE_RELATION = 'hasGeographicZone';\nexports.ZONE_RELATION = ZONE_RELATION;\nconst ROOM_RELATION = 'hasGeographicRoom';\nexports.ROOM_RELATION = ROOM_RELATION;\nconst EQUIPMENT_RELATION = 'hasBimObject';\nexports.EQUIPMENT_RELATION = EQUIPMENT_RELATION;\nconst REFERENCE_RELATION = 'hasReferenceObject';\nexports.REFERENCE_RELATION = REFERENCE_RELATION;\nconst REFERENCE_ROOM_RELATION = 'hasReferenceObject.ROOM';\nexports.REFERENCE_ROOM_RELATION = REFERENCE_ROOM_RELATION;\nconst SITE_REFERENCE_CONTEXT = '.SiteContext';\nexports.SITE_REFERENCE_CONTEXT = SITE_REFERENCE_CONTEXT;\nconst BUILDING_REFERENCE_CONTEXT = '.BuildingContext';\nexports.BUILDING_REFERENCE_CONTEXT = BUILDING_REFERENCE_CONTEXT;\nconst FLOOR_REFERENCE_CONTEXT = '.FloorContext';\nexports.FLOOR_REFERENCE_CONTEXT = FLOOR_REFERENCE_CONTEXT;\nconst ZONE_REFERENCE_CONTEXT = '.ZoneContext';\nexports.ZONE_REFERENCE_CONTEXT = ZONE_REFERENCE_CONTEXT;\nconst ROOM_REFERENCE_CONTEXT = '.RoomContext';\nexports.ROOM_REFERENCE_CONTEXT = ROOM_REFERENCE_CONTEXT;\nconst GEOGRAPHIC_TYPES = Object.freeze([\n    SITE_TYPE,\n    BUILDING_TYPE,\n    FLOOR_TYPE,\n    ZONE_TYPE,\n    ROOM_TYPE,\n]);\nexports.GEOGRAPHIC_TYPES = GEOGRAPHIC_TYPES;\nconst GEOGRAPHIC_TYPES_ORDER = Object.freeze([\n    CONTEXT_TYPE,\n    SITE_TYPE,\n    BUILDING_TYPE,\n    FLOOR_TYPE,\n    ZONE_TYPE,\n    ROOM_TYPE,\n    EQUIPMENT_TYPE,\n]);\nexports.GEOGRAPHIC_TYPES_ORDER = GEOGRAPHIC_TYPES_ORDER;\nconst GEOGRAPHIC_RELATIONS = Object.freeze([\n    SITE_RELATION,\n    BUILDING_RELATION,\n    FLOOR_RELATION,\n    ZONE_RELATION,\n    ROOM_RELATION,\n    EQUIPMENT_RELATION,\n]);\nexports.GEOGRAPHIC_RELATIONS = GEOGRAPHIC_RELATIONS;\nconst GEOGRAPHIC_RELATIONS_ORDER = Object.freeze([\n    SITE_RELATION,\n    BUILDING_RELATION,\n    FLOOR_RELATION,\n    ZONE_RELATION,\n    ROOM_RELATION,\n    EQUIPMENT_RELATION,\n]);\nexports.GEOGRAPHIC_RELATIONS_ORDER = GEOGRAPHIC_RELATIONS_ORDER;\nconst MAP_TYPE_RELATION = Object.freeze(new Map([\n    [SITE_TYPE, SITE_RELATION],\n    [BUILDING_TYPE, BUILDING_RELATION],\n    [FLOOR_TYPE, FLOOR_RELATION],\n    [ZONE_TYPE, ZONE_RELATION],\n    [ROOM_TYPE, ROOM_RELATION],\n    [EQUIPMENT_TYPE, EQUIPMENT_RELATION],\n]));\nexports.MAP_TYPE_RELATION = MAP_TYPE_RELATION;\nconst MAP_RELATION_TYPE = Object.freeze(new Map([\n    [SITE_RELATION, SITE_TYPE],\n    [BUILDING_RELATION, BUILDING_TYPE],\n    [FLOOR_RELATION, FLOOR_TYPE],\n    [ZONE_RELATION, ZONE_TYPE],\n    [ROOM_RELATION, ROOM_TYPE],\n    [EQUIPMENT_RELATION, EQUIPMENT_TYPE],\n]));\nexports.MAP_RELATION_TYPE = MAP_RELATION_TYPE;\n//# sourceMappingURL=constants.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nconst CONTEXT_TYPE = 'geographicContext';\nconst SITE_TYPE = 'geographicSite';\nconst BUILDING_TYPE = 'geographicBuilding';\nconst FLOOR_TYPE = 'geographicFloor';\nconst ZONE_TYPE = 'geographicZone';\nconst ROOM_TYPE = 'geographicRoom';\nconst EQUIPMENT_TYPE = 'BIMObject';\nconst REFERENCE_TYPE = 'geographicReference';\n\nconst SITE_RELATION = 'hasGeographicSite';\nconst BUILDING_RELATION = 'hasGeographicBuilding';\nconst FLOOR_RELATION = 'hasGeographicFloor';\nconst ZONE_RELATION = 'hasGeographicZone';\nconst ROOM_RELATION = 'hasGeographicRoom';\nconst EQUIPMENT_RELATION = 'hasBimObject';\nconst REFERENCE_RELATION = 'hasReferenceObject';\nconst REFERENCE_ROOM_RELATION = 'hasReferenceObject.ROOM';\n\nconst SITE_REFERENCE_CONTEXT = '.SiteContext';\nconst BUILDING_REFERENCE_CONTEXT = '.BuildingContext';\nconst FLOOR_REFERENCE_CONTEXT = '.FloorContext';\nconst ZONE_REFERENCE_CONTEXT = '.ZoneContext';\nconst ROOM_REFERENCE_CONTEXT = '.RoomContext';\n\nconst GEOGRAPHIC_TYPES = Object.freeze([\n  SITE_TYPE,\n  BUILDING_TYPE,\n  FLOOR_TYPE,\n  ZONE_TYPE,\n  ROOM_TYPE,\n]) as string[];\n\nconst GEOGRAPHIC_TYPES_ORDER = Object.freeze([\n  CONTEXT_TYPE,\n  SITE_TYPE,\n  BUILDING_TYPE,\n  FLOOR_TYPE,\n  ZONE_TYPE,\n  ROOM_TYPE,\n  EQUIPMENT_TYPE,\n]) as string[];\n\nconst GEOGRAPHIC_RELATIONS = Object.freeze([\n  SITE_RELATION,\n  BUILDING_RELATION,\n  FLOOR_RELATION,\n  ZONE_RELATION,\n  ROOM_RELATION,\n  EQUIPMENT_RELATION,\n]) as string[];\n\nconst GEOGRAPHIC_RELATIONS_ORDER = Object.freeze([\n  SITE_RELATION,\n  BUILDING_RELATION,\n  FLOOR_RELATION,\n  ZONE_RELATION,\n  ROOM_RELATION,\n  EQUIPMENT_RELATION,\n]) as string[];\n\nconst MAP_TYPE_RELATION = Object.freeze(\n  new Map([\n    [SITE_TYPE, SITE_RELATION],\n    [BUILDING_TYPE, BUILDING_RELATION],\n    [FLOOR_TYPE, FLOOR_RELATION],\n    [ZONE_TYPE, ZONE_RELATION],\n    [ROOM_TYPE, ROOM_RELATION],\n    [EQUIPMENT_TYPE, EQUIPMENT_RELATION],\n  ])\n) as Map<string, string>;\n\nconst MAP_RELATION_TYPE = Object.freeze(\n  new Map([\n    [SITE_RELATION, SITE_TYPE],\n    [BUILDING_RELATION, BUILDING_TYPE],\n    [FLOOR_RELATION, FLOOR_TYPE],\n    [ZONE_RELATION, ZONE_TYPE],\n    [ROOM_RELATION, ROOM_TYPE],\n    [EQUIPMENT_RELATION, EQUIPMENT_TYPE],\n  ])\n) as Map<string, string>;\n\nexport {\n  CONTEXT_TYPE,\n  SITE_TYPE,\n  BUILDING_TYPE,\n  FLOOR_TYPE,\n  ZONE_TYPE,\n  ROOM_TYPE,\n  GEOGRAPHIC_TYPES,\n  EQUIPMENT_TYPE,\n  GEOGRAPHIC_TYPES_ORDER,\n  SITE_RELATION,\n  BUILDING_RELATION,\n  FLOOR_RELATION,\n  ZONE_RELATION,\n  ROOM_RELATION,\n  GEOGRAPHIC_RELATIONS,\n  EQUIPMENT_RELATION,\n  GEOGRAPHIC_RELATIONS_ORDER,\n  MAP_TYPE_RELATION,\n  MAP_RELATION_TYPE,\n  REFERENCE_TYPE,\n  REFERENCE_RELATION,\n  SITE_REFERENCE_CONTEXT,\n  BUILDING_REFERENCE_CONTEXT,\n  FLOOR_REFERENCE_CONTEXT,\n  ZONE_REFERENCE_CONTEXT,\n  ROOM_REFERENCE_CONTEXT,\n  REFERENCE_ROOM_RELATION\n};\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addContextToReference = exports.getOrCreateRefContext = exports.getOrCreateElemFromReferenceContext = exports.addToReferenceContext = exports._getReferenceContextName = exports.addBimElement = exports.addRoom = exports.addZone = exports.addSite = exports.addFloor = exports.addBuilding = exports.addAbstractElement = exports.createContext = exports.getChildType = void 0;\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_model_graph_1 = require(\"spinal-model-graph\");\nconst constants_1 = require(\"./constants\");\nconst graphservice_1 = require(\"./graphservice\");\nconst dicoContextRef = new Map();\n/**\n * Returns the child type of the type given as parameter.\n * @param {string} parentType\n * @return {string} Child type\n */\nfunction getChildType(parentType) {\n    let parentTypeIndex = constants_1.GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);\n    if (parentTypeIndex === -1) {\n        return '';\n    }\n    return constants_1.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];\n}\nexports.getChildType = getChildType;\nfunction createContext(contextName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof contextName !== 'string') {\n            throw Error('contextName must be a string');\n        }\n        const graph = (0, graphservice_1.getGraph)();\n        const context = yield graph.getContext(contextName);\n        if (typeof context !== 'undefined')\n            return Promise.resolve(context);\n        const contextRes = new spinal_model_graph_1.SpinalContext(contextName, constants_1.CONTEXT_TYPE);\n        yield graph.addContext(contextRes);\n        (0, graphservice_1.addNodeGraphService)(contextRes);\n        return contextRes;\n    });\n}\nexports.createContext = createContext;\nfunction addAbstractElement(context, parent, elementName, id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const parentType = parent.info.type.get();\n        const childType = getChildType(parentType);\n        if (!childType) {\n            throw Error(`${parentType} is not a valid type in geographic context`);\n        }\n        return getOrCreateElemFromReferenceContext(childType, context, parent, elementName, id);\n    });\n}\nexports.addAbstractElement = addAbstractElement;\nfunction addBuilding(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.BUILDING_TYPE, context, parent, elementName, id);\n}\nexports.addBuilding = addBuilding;\nfunction addFloor(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.FLOOR_TYPE, context, parent, elementName, id);\n}\nexports.addFloor = addFloor;\nfunction addSite(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.SITE_TYPE, context, parent, elementName, id);\n}\nexports.addSite = addSite;\nfunction addZone(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.ZONE_TYPE, context, parent, elementName, id);\n}\nexports.addZone = addZone;\nfunction addRoom(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.ROOM_TYPE, context, parent, elementName, id);\n}\nexports.addRoom = addRoom;\nfunction addBimElement(context, parent, elements, model) {\n    const elems = Array.isArray(elements) ? elements : [elements];\n    let contextId = context.info.id.get();\n    let parentId = parent.info.id.get();\n    (0, graphservice_1.addNodeGraphService)(context);\n    (0, graphservice_1.addNodeGraphService)(parent);\n    return Promise.all(elems.map((element) => {\n        return window.spinal.BimObjectService.addBIMObject(contextId, parentId, element.dbId, element.name, model);\n    }));\n}\nexports.addBimElement = addBimElement;\nfunction _getReferenceContextName(nodeType) {\n    switch (nodeType) {\n        case constants_1.SITE_TYPE:\n            return {\n                name: constants_1.SITE_REFERENCE_CONTEXT,\n                relation: constants_1.SITE_RELATION,\n            };\n        case constants_1.BUILDING_TYPE:\n            return {\n                name: constants_1.BUILDING_REFERENCE_CONTEXT,\n                relation: constants_1.BUILDING_RELATION,\n            };\n        case constants_1.FLOOR_TYPE:\n            return {\n                name: constants_1.FLOOR_REFERENCE_CONTEXT,\n                relation: constants_1.FLOOR_RELATION,\n            };\n        case constants_1.ZONE_TYPE:\n            return {\n                name: constants_1.ZONE_REFERENCE_CONTEXT,\n                relation: constants_1.ZONE_RELATION,\n            };\n        case constants_1.ROOM_TYPE:\n            return {\n                name: constants_1.ROOM_REFERENCE_CONTEXT,\n                relation: constants_1.ROOM_RELATION,\n            };\n        default:\n            return undefined;\n    }\n}\nexports._getReferenceContextName = _getReferenceContextName;\nfunction addToReferenceContext(node) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const obj = _getReferenceContextName(node.info.type.get());\n        if (typeof obj !== 'undefined') {\n            let context = yield getOrCreateRefContext(obj.name);\n            yield context.addChild(node, obj.relation, spinal_model_graph_1.SPINAL_RELATION_PTR_LST_TYPE);\n        }\n    });\n}\nexports.addToReferenceContext = addToReferenceContext;\nfunction getOrCreateElemFromReferenceContext(nodeType, context, parent, elementName, id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const obj = _getReferenceContextName(nodeType);\n        if (typeof obj === 'undefined')\n            throw new Error(`error unknonw node type : ${nodeType}`);\n        const refContext = yield getOrCreateRefContext(obj.name);\n        let node;\n        if (typeof id !== 'undefined') {\n            const refNodes = yield refContext.getChildren(obj.relation);\n            node = refNodes.find((itm) => itm.info.id.get() === id);\n        }\n        if (!node) {\n            node = new spinal_model_graph_1.SpinalNode(elementName, nodeType);\n            if (typeof id !== 'undefined')\n                node.info.id.set(id);\n            yield refContext.addChild(node, obj.relation, spinal_model_graph_1.SPINAL_RELATION_PTR_LST_TYPE);\n        }\n        yield parent.addChildInContext(node, obj.relation, spinal_model_graph_1.SPINAL_RELATION_PTR_LST_TYPE, context);\n        return node;\n    });\n}\nexports.getOrCreateElemFromReferenceContext = getOrCreateElemFromReferenceContext;\nfunction _getOrCreateRefContext(contextName) {\n    return __asyncGenerator(this, arguments, function* _getOrCreateRefContext_1() {\n        const graph = (0, graphservice_1.getGraph)();\n        let context = yield __await(graph.getContext(contextName));\n        if (!context) {\n            context = new spinal_model_graph_1.SpinalContext(contextName, contextName.replace('.', ''));\n            yield __await(graph.addContext(context));\n        }\n        (0, graphservice_1.addNodeGraphService)(context);\n        while (true)\n            yield yield __await(context);\n    });\n}\nfunction getOrCreateRefContext(contextName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!dicoContextRef.has(contextName)) {\n            const gen = _getOrCreateRefContext(contextName);\n            dicoContextRef.set(contextName, gen);\n        }\n        return (yield dicoContextRef.get(contextName).next()).value;\n    });\n}\nexports.getOrCreateRefContext = getOrCreateRefContext;\nfunction addContextToReference(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof context !== 'undefined') {\n            yield context.map(constants_1.GEOGRAPHIC_RELATIONS, (node) => {\n                (0, graphservice_1.addNodeGraphService)(node);\n                return addToReferenceContext(node);\n            });\n        }\n    });\n}\nexports.addContextToReference = addContextToReference;\n//# sourceMappingURL=geoServiceV2.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport {\n  SpinalContext,\n  SpinalNode,\n  SPINAL_RELATION_PTR_LST_TYPE,\n} from 'spinal-model-graph';\nimport {\n  GEOGRAPHIC_TYPES_ORDER,\n  GEOGRAPHIC_RELATIONS,\n  MAP_TYPE_RELATION,\n  SITE_RELATION,\n  BUILDING_RELATION,\n  FLOOR_RELATION,\n  ZONE_RELATION,\n  ROOM_RELATION,\n  CONTEXT_TYPE,\n  SITE_TYPE,\n  BUILDING_TYPE,\n  FLOOR_TYPE,\n  ZONE_TYPE,\n  ROOM_TYPE,\n  SITE_REFERENCE_CONTEXT,\n  BUILDING_REFERENCE_CONTEXT,\n  FLOOR_REFERENCE_CONTEXT,\n  ZONE_REFERENCE_CONTEXT,\n  ROOM_REFERENCE_CONTEXT,\n} from './constants';\nimport { addNodeGraphService, getGraph } from './graphservice';\n\nconst dicoContextRef = new Map<\n  string,\n  AsyncGenerator<SpinalNode, never, never>\n>();\n\n/**\n * Returns the child type of the type given as parameter.\n * @param {string} parentType\n * @return {string} Child type\n */\nexport function getChildType(parentType: string): string {\n  let parentTypeIndex = GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);\n  if (parentTypeIndex === -1) {\n    return '';\n  }\n  return GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];\n}\nexport async function createContext(\n  contextName: string\n): Promise<SpinalContext> {\n  if (typeof contextName !== 'string') {\n    throw Error('contextName must be a string');\n  }\n  const graph = getGraph();\n  const context = await graph.getContext(contextName);\n  if (typeof context !== 'undefined') return Promise.resolve(context);\n  const contextRes = new SpinalContext(contextName, CONTEXT_TYPE);\n  await graph.addContext(contextRes);\n  addNodeGraphService(contextRes);\n  return contextRes;\n}\nexport async function addAbstractElement(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n): Promise<SpinalNode> {\n  const parentType = parent.info.type.get();\n  const childType = getChildType(parentType);\n  if (!childType) {\n    throw Error(`${parentType} is not a valid type in geographic context`);\n  }\n  return getOrCreateElemFromReferenceContext(\n    childType,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addBuilding(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    BUILDING_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addFloor(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    FLOOR_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addSite(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    SITE_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addZone(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    ZONE_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addRoom(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    ROOM_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\n\nexport type TAddBimElementItem = {\n  dbId: number;\n  name: string;\n};\nexport function addBimElement(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elements: TAddBimElementItem | TAddBimElementItem[],\n  model: any\n): Promise<unknown[]> {\n  const elems = Array.isArray(elements) ? elements : [elements];\n  let contextId = context.info.id.get();\n  let parentId = parent.info.id.get();\n  addNodeGraphService(context);\n  addNodeGraphService(parent);\n  return Promise.all(\n    elems.map((element) => {\n      return window.spinal.BimObjectService.addBIMObject(\n        contextId,\n        parentId,\n        element.dbId,\n        element.name,\n        model\n      );\n    })\n  );\n}\nexport function _getReferenceContextName(nodeType: string): {\n  name: string;\n  relation: string;\n} {\n  switch (nodeType) {\n    case SITE_TYPE:\n      return {\n        name: SITE_REFERENCE_CONTEXT,\n        relation: SITE_RELATION,\n      };\n    case BUILDING_TYPE:\n      return {\n        name: BUILDING_REFERENCE_CONTEXT,\n        relation: BUILDING_RELATION,\n      };\n\n    case FLOOR_TYPE:\n      return {\n        name: FLOOR_REFERENCE_CONTEXT,\n        relation: FLOOR_RELATION,\n      };\n\n    case ZONE_TYPE:\n      return {\n        name: ZONE_REFERENCE_CONTEXT,\n        relation: ZONE_RELATION,\n      };\n\n    case ROOM_TYPE:\n      return {\n        name: ROOM_REFERENCE_CONTEXT,\n        relation: ROOM_RELATION,\n      };\n\n    default:\n      return undefined;\n  }\n}\n\nexport async function addToReferenceContext(node: SpinalNode): Promise<void> {\n  const obj = _getReferenceContextName(node.info.type.get());\n\n  if (typeof obj !== 'undefined') {\n    let context = await getOrCreateRefContext(obj.name);\n    await context.addChild(node, obj.relation, SPINAL_RELATION_PTR_LST_TYPE);\n  }\n}\n\nexport async function getOrCreateElemFromReferenceContext(\n  nodeType: string,\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n): Promise<SpinalNode> {\n  const obj = _getReferenceContextName(nodeType);\n  if (typeof obj === 'undefined')\n    throw new Error(`error unknonw node type : ${nodeType}`);\n\n  const refContext = await getOrCreateRefContext(obj.name);\n  let node;\n  if (typeof id !== 'undefined') {\n    const refNodes = await refContext.getChildren(obj.relation);\n    node = refNodes.find((itm) => itm.info.id.get() === id);\n  }\n  if (!node) {\n    node = new SpinalNode(elementName, nodeType);\n    if (typeof id !== 'undefined') node.info.id.set(id);\n    await refContext.addChild(node, obj.relation, SPINAL_RELATION_PTR_LST_TYPE);\n  }\n  await parent.addChildInContext(\n    node,\n    obj.relation,\n    SPINAL_RELATION_PTR_LST_TYPE,\n    context\n  );\n  return node;\n}\n\nasync function* _getOrCreateRefContext(\n  contextName: string\n): AsyncGenerator<SpinalNode<any>, never, never> {\n  const graph = getGraph();\n  let context = await graph.getContext(contextName);\n  if (!context) {\n    context = new SpinalContext(contextName, contextName.replace('.', ''));\n    await graph.addContext(context);\n  }\n  addNodeGraphService(context);\n  while (true) yield context;\n}\n\nexport async function getOrCreateRefContext(\n  contextName: string\n): Promise<SpinalNode> {\n  if (!dicoContextRef.has(contextName)) {\n    const gen = _getOrCreateRefContext(contextName);\n    dicoContextRef.set(contextName, gen);\n  }\n  return (await dicoContextRef.get(contextName)!.next()).value;\n}\n\nexport async function addContextToReference(\n  context: SpinalContext\n): Promise<void> {\n  if (typeof context !== 'undefined') {\n    await context.map(GEOGRAPHIC_RELATIONS, (node) => {\n      addNodeGraphService(node);\n      return addToReferenceContext(node);\n    });\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getInfoGraphService = exports.getRealNode = exports.getGraph = exports.addNodeGraphService = void 0;\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nfunction addNodeGraphService(node) {\n    // @ts-ignore\n    spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(node);\n}\nexports.addNodeGraphService = addNodeGraphService;\nfunction getGraph() {\n    return spinal_env_viewer_graph_service_1.SpinalGraphService.getGraph();\n}\nexports.getGraph = getGraph;\nfunction getRealNode(nodeId) {\n    return spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(nodeId);\n}\nexports.getRealNode = getRealNode;\nfunction getInfoGraphService(nodeId) {\n    return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(nodeId);\n}\nexports.getInfoGraphService = getInfoGraphService;\n//# sourceMappingURL=graphservice.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport {\n  SpinalGraphService,\n  SpinalNodeRef,\n} from 'spinal-env-viewer-graph-service';\nimport { SpinalGraph, SpinalNode } from 'spinal-model-graph';\n\nexport function addNodeGraphService(node: SpinalNode): void {\n  // @ts-ignore\n  SpinalGraphService._addNode(node);\n}\n\nexport function getGraph(): SpinalGraph {\n  return SpinalGraphService.getGraph();\n}\n\nexport function getRealNode(nodeId: string): SpinalNode {\n  return SpinalGraphService.getRealNode(nodeId);\n}\n\nexport function getInfoGraphService(nodeId: string): SpinalNodeRef {\n  return SpinalGraphService.getInfo(nodeId);\n}\n"],"names":[],"version":3,"file":"build.7dc8429d.js.map"}