{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A;ACAA;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,kB,A,I,I,I,C,mB,C,O,S,S,C,E,C,E,C,E,E;I,I,O,W,K;I,I,O,O,yB,G;I,I,C,Q,C,S,O,C,E,a,K,Y,K,Y,G,O;Q,Y;Q,K;Y,O,C,C,E;Q;I;I,O,e,G,I;A,I,S,C,E,C,E,C,E,E;I,I,O,W,K;I,C,C,G,G,C,C,E;A,C;A,I,e,A,I,I,I,C,gB,S,C,E,Q;I,I,I,K,E,I,M,a,C,O,U,e,K,U,I,gB,U,G;A;A,O,e,S,c;I,O;A;A,Q,qB,Q,c,K;AAEH,MAAA,gBAAA,QAAA;AAgBI,OAAA,eAAA,SAAA,sBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAhBK,cAAA;IAAkB;AAAA;AAC3B,MAAA,gBAAA,QAAA;AAcI,OAAA,eAAA,SAAA,eAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAdK,cAAA;IAAW;AAAA;AAEpB,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;AAEA,MAAM,aAAkB,OAAO,WAAW,cAAc,SAAS;AAEjE,IAAI,OAAO,WAAW,WAAW,aAAa,WAAW,SAAS,CAAA;AAElE,IAAI,OAAO,WAAW,OAAO,uBAAuB,aAChD,WAAW,OAAO,qBAAqB,cAAA;;;A;AEnC3C;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,Y,A,I,I,I,C,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;A,O,e,S,c;I,O;A;A,Q,qB,K;AAGH,MAAA,iCAAA,QAAA;AACA,MAAA,oCAAA,QAAA;AACA,MAAA,mDAAA,QAAA;AACA,MAAA,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","sources":["node_modules/spinal-env-viewer-task-service/dist/index.js","node_modules/spinal-env-viewer-task-service/src/index.ts","node_modules/spinal-env-viewer-task-service/dist/services/TaskService.js","node_modules/spinal-env-viewer-task-service/src/services/TaskService.ts","node_modules/spinal-env-viewer-task-service/dist/models/SpinalEvent.js","node_modules/spinal-env-viewer-task-service/src/models/SpinalEvent.ts","node_modules/spinal-env-viewer-task-service/dist/types/constants.js","node_modules/spinal-env-viewer-task-service/src/types/constants.ts","node_modules/spinal-env-viewer-task-service/dist/types/EventInterface.js","node_modules/spinal-env-viewer-task-service/src/types/EventInterface.ts","node_modules/spinal-env-viewer-context-geographic-service/build/constants.js","node_modules/spinal-env-viewer-context-geographic-service/src/constants.ts"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalEventService = exports.SpinalEvent = void 0;\nconst TaskService_1 = require(\"./services/TaskService\");\nObject.defineProperty(exports, \"SpinalEventService\", { enumerable: true, get: function () { return TaskService_1.SpinalEventService; } });\nconst SpinalEvent_1 = require(\"./models/SpinalEvent\");\nObject.defineProperty(exports, \"SpinalEvent\", { enumerable: true, get: function () { return SpinalEvent_1.SpinalEvent; } });\n__exportStar(require(\"./types/constants\"), exports);\n__exportStar(require(\"./types/EventInterface\"), exports);\nconst globalRoot = typeof window === \"undefined\" ? global : window;\nif (typeof globalRoot.spinal === 'undefined')\n    globalRoot.spinal = {};\nif (typeof globalRoot.spinal.SpinalEventService === 'undefined') {\n    globalRoot.spinal.SpinalEventService = TaskService_1.SpinalEventService;\n}\n//# sourceMappingURL=index.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { SpinalEventService } from \"./services/TaskService\";\nimport { SpinalEvent } from \"./models/SpinalEvent\";\n\nexport * from \"./types/constants\";\nexport * from \"./types/EventInterface\";\n\nconst globalRoot: any = typeof window === \"undefined\" ? global : window;\n\nif (typeof globalRoot.spinal === 'undefined') globalRoot.spinal = {};\n\nif (typeof globalRoot.spinal.SpinalEventService === 'undefined') {\n    globalRoot.spinal.SpinalEventService = SpinalEventService;\n}\n\nexport {\n    SpinalEvent,\n    SpinalEventService\n}","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalEventService = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_env_viewer_plugin_group_manager_service_1 = require(\"spinal-env-viewer-plugin-group-manager-service\");\nconst SpinalEvent_1 = require(\"../models/SpinalEvent\");\nconst constants_1 = require(\"../types/constants\");\nconst EventInterface_1 = require(\"../types/EventInterface\");\nconst spinal_env_viewer_plugin_documentation_service_1 = require(\"spinal-env-viewer-plugin-documentation-service\");\nconst moment = require(\"moment\");\nclass SpinalEventService {\n    ///////////////////////////////////////////////////////////////////////\n    //                          CONTEXTS                                 //\n    ///////////////////////////////////////////////////////////////////////\n    static createEventContext(name, steps, graph) {\n        steps = steps || [];\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.createGroupContext(name, SpinalEvent_1.SpinalEvent.EVENT_TYPE, graph).then((context) => {\n            context.info.add_attr({ steps: new spinal_core_connectorjs_type_1.Ptr(new spinal_core_connectorjs_type_1.Lst(steps)) });\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(context.getId().get());\n        });\n    }\n    static getEventContexts(graph) {\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.getGroupContexts(SpinalEvent_1.SpinalEvent.EVENT_TYPE, graph).then((contexts) => {\n            return contexts.map(el => spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(el.id));\n        });\n    }\n    ///////////////////////////////////////////////////////////////////////\n    //                          CATEGORIES                               //\n    ///////////////////////////////////////////////////////////////////////\n    static getEventsCategories(nodeId) {\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.getCategories(nodeId);\n    }\n    static createEventCategory(contextId, name, icon) {\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.addCategory(contextId, name, icon).then((node) => __awaiter(this, void 0, void 0, function* () {\n            spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(node);\n            const id = node.getId().get();\n            const steps = yield this._getSteps(id);\n            const promises = steps.map(el => this._createGroupNode(contextId, id, el.name, el.color, el.order));\n            return Promise.all(promises).then(() => spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(id));\n        }));\n    }\n    ///////////////////////////////////////////////////////////////////////\n    //                             STEPS                                 //\n    ///////////////////////////////////////////////////////////////////////\n    static createEventGroup(contextId, catgoryId, name, color) {\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.addGroup(contextId, catgoryId, name, color).then((node) => {\n            //@ts-ignore\n            spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(node);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(node.getId().get());\n        });\n    }\n    static getEventsGroups(nodeId) {\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.getGroups(nodeId);\n    }\n    static getFirstStep(nodeId) {\n        return this.getEventsGroups(nodeId).then((steps) => {\n            return steps.find((el) => el.order.get() === 0);\n        });\n    }\n    ///////////////////////////////////////////////////////////////////////\n    //                             Events                                 //\n    ///////////////////////////////////////////////////////////////////////\n    static createEventBetween(begin, end, periodicity, contextId, groupId, nodeId, eventInfo, userInfo) {\n        const dates = this._getDateInterval(begin, end, periodicity);\n        const reference = Date.now();\n        const isoEndDate = new Date(eventInfo.endDate).toISOString();\n        const isoStartDate = new Date(eventInfo.startDate).toISOString();\n        const diff = moment(isoEndDate).diff(moment(isoStartDate)).valueOf();\n        const promises = dates.map(el => {\n            const isoEl = new Date(el).toISOString();\n            const temp_obj = Object.assign(Object.assign({}, eventInfo), { startDate: moment(isoEl).format('LLLL'), endDate: moment(isoEl).add(diff, \"milliseconds\").format('LLLL'), reference });\n            return this.createEventNode(contextId, groupId, nodeId, temp_obj, userInfo);\n        });\n        return Promise.all(promises);\n    }\n    static createEvent(contextId, groupId, nodeId, eventInfo, userInfo) {\n        if (eventInfo.repeat) {\n            const periodicity = eventInfo.periodicity.count * eventInfo.periodicity.period;\n            return this.createEventBetween(eventInfo.startDate, eventInfo.repeatEnd, periodicity, contextId, groupId, nodeId, eventInfo, userInfo);\n        }\n        else {\n            return this.createEventNode(contextId, groupId, nodeId, eventInfo, userInfo);\n        }\n    }\n    static getEvents(nodeId, start, end) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const children = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(nodeId, [constants_1.RELATION_NAME]);\n            if (start && end) {\n                return children.filter(event => {\n                    const isoDate = new Date(event.startDate.get()).toISOString();\n                    const date = moment(isoDate);\n                    return date.isSameOrAfter(start.getTime()) && date.isSameOrBefore(end.getTime());\n                });\n            }\n            else if (start && !end) {\n                return children.filter(event => {\n                    const isoDate = new Date(event.startDate.get()).toISOString();\n                    const date = moment(isoDate);\n                    return date.isSameOrAfter(start.getTime());\n                });\n            }\n            else if (!start && end) {\n                return children.filter(event => {\n                    const isoDate = new Date(event.startDate.get()).toISOString();\n                    const date = moment(isoDate);\n                    return date.isSameOrBefore(end.getTime());\n                });\n            }\n            else {\n                return children;\n            }\n        });\n    }\n    static updateEvent(eventId, newEventInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._updateEventInformation(eventId, newEventInfo);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(eventId);\n        });\n    }\n    static removeEvent(eventId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const groupInfo = yield this._getGroupId(eventId);\n            if (groupInfo) {\n                return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.unLinkElementToGroup(groupInfo.id.get(), eventId).then(() => __awaiter(this, void 0, void 0, function* () {\n                    const nodeInfo = yield this._getNodeId(eventId);\n                    if (nodeInfo)\n                        return spinal_env_viewer_graph_service_1.SpinalGraphService.removeChild(nodeInfo.id.get(), eventId, constants_1.RELATION_NAME, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n                }));\n            }\n        });\n    }\n    static createOrgetDefaultTreeStructure(graph) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const context = yield spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.createGroupContext(constants_1.DEFAULT_CONTEXT_NAME, SpinalEvent_1.SpinalEvent.EVENT_TYPE, graph);\n            const contextId = context.getId().get();\n            const category = yield this.createEventCategory(contextId, constants_1.DEFAULT_CATEGORY_NAME, \"\");\n            const group = yield this.createEventGroup(contextId, category.id.get(), constants_1.DEFAULT_GROUP_NAME, \"#fff000\");\n            return {\n                context: spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(contextId),\n                category,\n                group\n            };\n        });\n    }\n    ///////////////////////////////////////////////////////////////////////\n    //                             LOGS                                  //\n    ///////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////\n    //                              PRIVATES                               //\n    /////////////////////////////////////////////////////////////////////////\n    static _updateEventInformation(eventId, newEventInfo) {\n        const event = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(eventId);\n        if (typeof event === \"undefined\")\n            return;\n        for (const key in newEventInfo) {\n            if (Object.prototype.hasOwnProperty.call(newEventInfo, key)) {\n                if (event.info[key]) {\n                    event.info.mod_attr(key, newEventInfo[key]);\n                }\n                else {\n                    event.info.add_attr({ [key]: newEventInfo[key] });\n                }\n            }\n        }\n    }\n    static _getSteps(contextId) {\n        return new Promise((resolve) => {\n            const info = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(contextId);\n            if (!info.steps)\n                return resolve([]);\n            info.steps.load((data) => {\n                resolve(data.get());\n            });\n        });\n    }\n    static _createGroupNode(contextId, categoryId, name, color, order) {\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.addGroup(contextId, categoryId, name, color);\n    }\n    static _getDateInterval(begin, end, interval) {\n        const dates = [];\n        const beginDate = new Date(begin).toISOString();\n        const endDate = new Date(end).toISOString();\n        let tempBegin = moment(beginDate);\n        let tempEnd = moment(endDate);\n        while (tempEnd.diff(tempBegin) >= 0) {\n            dates.push(tempBegin.valueOf());\n            tempBegin = tempBegin.add(interval, 'ms');\n        }\n        return dates;\n    }\n    static createEventNode(contextId, groupId, nodeId, eventInfo, userInfo) {\n        if (!eventInfo.repeat) {\n            delete eventInfo.periodicity;\n            delete eventInfo.repeatEnd;\n        }\n        if (eventInfo.startDate) {\n            let date = new Date(eventInfo.startDate).toISOString();\n            eventInfo.startDate = moment(date).format(\"LLLL\");\n        }\n        if (eventInfo.endDate) {\n            let date = new Date(eventInfo.endDate).toISOString();\n            eventInfo.endDate = moment(date).format(\"LLLL\");\n        }\n        if (eventInfo.creationDate) {\n            let date = new Date(eventInfo.creationDate).toISOString();\n            eventInfo.creationDate = moment(date).format(\"LLLL\");\n        }\n        if (eventInfo.repeatEnd) {\n            let date = new Date(eventInfo.repeatEnd).toISOString();\n            eventInfo.repeatEnd = moment(date).format(\"LLLL\");\n        }\n        eventInfo.contextId = contextId;\n        eventInfo.groupId = groupId;\n        eventInfo.nodeId = nodeId;\n        eventInfo.type = SpinalEvent_1.SpinalEvent.EVENT_TYPE;\n        eventInfo.user = userInfo;\n        // const taskModel = new SpinalEvent(eventInfo);\n        const eventId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(eventInfo, new spinal_core_connectorjs_type_1.Model());\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.linkElementToGroup(contextId, groupId, eventId).then((result) => __awaiter(this, void 0, void 0, function* () {\n            yield spinal_env_viewer_graph_service_1.SpinalGraphService.addChild(nodeId, eventId, constants_1.RELATION_NAME, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            yield this.createAttribute(eventId);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(eventId);\n        }));\n    }\n    static createAttribute(nodeId) {\n        const categoryName = \"default\";\n        const realNode = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(nodeId);\n        return spinal_env_viewer_plugin_documentation_service_1.serviceDocumentation.addCategoryAttribute(realNode, categoryName).then((attributeCategory) => {\n            const promises = [];\n            promises.push(spinal_env_viewer_plugin_documentation_service_1.serviceDocumentation.addAttributeByCategory(realNode, attributeCategory, \"name\", realNode.info.name));\n            const attributes = [\"startDate\", \"endDate\", \"creationDate\", \"repeatEnd\"];\n            for (const key of attributes) {\n                if (realNode.info[key]) {\n                    // const date = moment(realNode.info[key].get()).format('LL')\n                    promises.push(spinal_env_viewer_plugin_documentation_service_1.serviceDocumentation.addAttributeByCategory(realNode, attributeCategory, key, realNode.info[key]));\n                }\n            }\n            if (realNode.info.periodicity) {\n                const value = `${realNode.info.periodicity.count.get()} ${EventInterface_1.invers_period[realNode.info.periodicity.period.get()]}`;\n                promises.push(spinal_env_viewer_plugin_documentation_service_1.serviceDocumentation.addAttributeByCategory(realNode, attributeCategory, \"periodicity\", value));\n            }\n            return Promise.all(promises);\n        });\n    }\n    static _getGroupId(eventId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(eventId);\n            let groupInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(info.groupId);\n            if (groupInfo) {\n                return groupInfo;\n            }\n            const parents = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getParents(eventId, [`groupHas${constants_1.EVENT_TYPE}`]);\n            return parents.find(el => el.id.get() === info.groupId.get());\n        });\n    }\n    static _getNodeId(eventId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(eventId);\n            let nodeInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(info.nodeId);\n            if (nodeInfo) {\n                return nodeInfo;\n            }\n            const parents = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getParents(eventId, [constants_1.RELATION_NAME]);\n            return parents.find(el => el.id.get() === info.nodeId.get());\n        });\n    }\n}\nexports.SpinalEventService = SpinalEventService;\n//# sourceMappingURL=TaskService.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n * \n * This file is part of SpinalCore.\n * \n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n * \n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n * \n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\n\nimport { Ptr, Lst, Model } from \"spinal-core-connectorjs_type\";\nimport { SpinalGraph, SpinalGraphService, SpinalNode, SpinalNodeRef, SPINAL_RELATION_PTR_LST_TYPE } from \"spinal-env-viewer-graph-service\";\nimport { groupManagerService } from \"spinal-env-viewer-plugin-group-manager-service\";\nimport { SpinalEvent } from '../models/SpinalEvent';\nimport { DEFAULT_CATEGORY_NAME, DEFAULT_CONTEXT_NAME, DEFAULT_GROUP_NAME, EVENT_TYPE, RELATION_NAME } from \"../types/constants\";\nimport { EventInterface, invers_period } from \"../types/EventInterface\";\nimport { serviceDocumentation } from \"spinal-env-viewer-plugin-documentation-service\";\n\nimport * as moment from 'moment';\nimport { SpinalAttribute } from \"spinal-model-timeseries\";\n\nexport class SpinalEventService {\n\n    ///////////////////////////////////////////////////////////////////////\n    //                          CONTEXTS                                 //\n    ///////////////////////////////////////////////////////////////////////\n    public static createEventContext(name: string, steps?: Array<{ name: string, order, color }>, graph?: SpinalGraph): Promise<SpinalNodeRef> {\n        steps = steps || [];\n        return groupManagerService.createGroupContext(name, SpinalEvent.EVENT_TYPE, graph).then((context) => {\n            context.info.add_attr({ steps: new Ptr(new Lst(steps)) });\n            return SpinalGraphService.getInfo(context.getId().get());\n        })\n    }\n\n    public static getEventContexts(graph?: SpinalGraph<any>): Promise<SpinalNodeRef[]> {\n        return groupManagerService.getGroupContexts(SpinalEvent.EVENT_TYPE, graph).then((contexts) => {\n            return contexts.map(el => SpinalGraphService.getInfo(el.id));\n        })\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    //                          CATEGORIES                               //\n    ///////////////////////////////////////////////////////////////////////\n\n    public static getEventsCategories(nodeId: string): Promise<SpinalNodeRef[]> {\n        return groupManagerService.getCategories(nodeId);\n    }\n\n    public static createEventCategory(contextId: string, name: string, icon: string): Promise<SpinalNodeRef> {\n        return groupManagerService.addCategory(contextId, name, icon).then(async (node) => {\n            (<any>SpinalGraphService)._addNode(node);\n            const id = node.getId().get();\n            const steps: any = await this._getSteps(id);\n\n            const promises = steps.map(el => this._createGroupNode(contextId, id, el.name, el.color, el.order));\n\n            return Promise.all(promises).then(() => SpinalGraphService.getInfo(id));\n        })\n    }\n\n\n\n    ///////////////////////////////////////////////////////////////////////\n    //                             STEPS                                 //\n    ///////////////////////////////////////////////////////////////////////\n\n    public static createEventGroup(contextId: string, catgoryId: string, name: string, color: string): Promise<SpinalNodeRef> {\n        return groupManagerService.addGroup(contextId, catgoryId, name, color).then((node) => {\n            //@ts-ignore\n            SpinalGraphService._addNode(node)\n            return SpinalGraphService.getInfo(node.getId().get());\n        })\n    }\n\n    public static getEventsGroups(nodeId: string): Promise<SpinalNodeRef[]> {\n        return groupManagerService.getGroups(nodeId);\n    }\n\n    public static getFirstStep(nodeId: string): Promise<SpinalNodeRef> {\n        return this.getEventsGroups(nodeId).then((steps) => {\n            return steps.find((el: any) => el.order.get() === 0);\n        })\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    //                             Events                                 //\n    ///////////////////////////////////////////////////////////////////////\n\n    public static createEventBetween(begin: string, end: string, periodicity: number, contextId: string, groupId, nodeId: string, eventInfo: EventInterface, userInfo: any): Promise<SpinalNodeRef[]> {\n        const dates = this._getDateInterval(begin, end, periodicity);\n        const reference = Date.now()\n        const isoEndDate = new Date(eventInfo.endDate).toISOString();\n        const isoStartDate = new Date(eventInfo.startDate).toISOString();\n\n        const diff = moment(isoEndDate).diff(moment(isoStartDate)).valueOf();\n\n        const promises = dates.map(el => {\n            const isoEl = new Date(el).toISOString();\n\n            const temp_obj = { ...eventInfo, startDate: moment(isoEl).format('LLLL'), endDate: moment(isoEl).add(diff, \"milliseconds\").format('LLLL'), reference };\n            return this.createEventNode(contextId, groupId, nodeId, temp_obj, userInfo);\n        })\n\n        return Promise.all(promises);\n    }\n\n    public static createEvent(contextId: string, groupId, nodeId: string, eventInfo: EventInterface, userInfo: any): Promise<SpinalNodeRef | SpinalNodeRef[]> {\n        if (eventInfo.repeat) {\n            const periodicity = eventInfo.periodicity.count * eventInfo.periodicity.period;\n            return this.createEventBetween(eventInfo.startDate, eventInfo.repeatEnd, periodicity, contextId, groupId, nodeId, eventInfo, userInfo);\n        } else {\n            return this.createEventNode(contextId, groupId, nodeId, eventInfo, userInfo);\n        }\n    }\n\n    public static async getEvents(nodeId: string, start?: Date, end?: Date): Promise<SpinalNodeRef[]> {\n        const children = await SpinalGraphService.getChildren(nodeId, [RELATION_NAME]);\n\n        if (start && end) {\n            return children.filter(event => {\n                const isoDate = new Date(event.startDate.get()).toISOString();\n                const date = moment(isoDate);\n                return date.isSameOrAfter(start.getTime()) && date.isSameOrBefore(end.getTime());\n            })\n\n        } else if (start && !end) {\n            return children.filter(event => {\n                const isoDate = new Date(event.startDate.get()).toISOString();\n                const date = moment(isoDate);\n                return date.isSameOrAfter(start.getTime());\n            })\n        } else if (!start && end) {\n            return children.filter(event => {\n                const isoDate = new Date(event.startDate.get()).toISOString();\n                const date = moment(isoDate);\n                return date.isSameOrBefore(end.getTime());\n            })\n        } else {\n            return children;\n        }\n    }\n\n    public static async updateEvent(eventId: string, newEventInfo: EventInterface): Promise<SpinalNodeRef> {\n\n        this._updateEventInformation(eventId, newEventInfo);\n\n        return SpinalGraphService.getInfo(eventId);\n    }\n\n    public static async removeEvent(eventId: string): Promise<boolean> {\n\n        const groupInfo = await this._getGroupId(eventId);\n\n        if (groupInfo) {\n            return groupManagerService.unLinkElementToGroup(groupInfo.id.get(), eventId).then(async () => {\n\n                const nodeInfo = await this._getNodeId(eventId);\n                if (nodeInfo) return SpinalGraphService.removeChild(nodeInfo.id.get(), eventId, RELATION_NAME, SPINAL_RELATION_PTR_LST_TYPE);\n            })\n        }\n\n    }\n\n    public static async createOrgetDefaultTreeStructure(graph?: SpinalGraph<any>): Promise<{ context: SpinalNodeRef; category: SpinalNodeRef; group: SpinalNodeRef; }> {\n        const context = await groupManagerService.createGroupContext(DEFAULT_CONTEXT_NAME, SpinalEvent.EVENT_TYPE, graph);\n        const contextId = context.getId().get();\n        const category = await this.createEventCategory(contextId, DEFAULT_CATEGORY_NAME, \"\");\n        const group = await this.createEventGroup(contextId, (<any>category).id.get(), DEFAULT_GROUP_NAME, \"#fff000\");\n        return {\n            context: SpinalGraphService.getInfo(contextId),\n            category,\n            group\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    //                             LOGS                                  //\n    ///////////////////////////////////////////////////////////////////////\n\n\n    /////////////////////////////////////////////////////////////////////////\n    //                              PRIVATES                               //\n    /////////////////////////////////////////////////////////////////////////\n\n    private static _updateEventInformation(eventId: string, newEventInfo: EventInterface) {\n        const event = SpinalGraphService.getRealNode(eventId);\n        if (typeof event === \"undefined\") return;\n\n        for (const key in newEventInfo) {\n            if (Object.prototype.hasOwnProperty.call(newEventInfo, key)) {\n                if (event.info[key]) {\n                    event.info.mod_attr(key, newEventInfo[key]);\n                } else {\n                    event.info.add_attr({ [key]: newEventInfo[key] });\n                }\n            }\n        }\n\n\n    }\n\n    private static _getSteps(contextId: string): Promise<{ name: string; order: number; color: string }[]> {\n        return new Promise((resolve) => {\n            const info = SpinalGraphService.getInfo(contextId);\n            if (!info.steps) return resolve([]);\n            info.steps.load((data) => {\n                resolve(data.get());\n            })\n        });\n    }\n\n    private static _createGroupNode(contextId: string, categoryId: string, name: string, color: string, order?: number): Promise<SpinalNode<any>> {\n        return groupManagerService.addGroup(contextId, categoryId, name, color);\n    }\n\n    private static _getDateInterval(begin: string, end: string, interval: number): number[] {\n        const dates = [];\n\n        const beginDate = new Date(begin).toISOString();\n        const endDate = new Date(end).toISOString();\n\n        let tempBegin = moment(beginDate);\n        let tempEnd = moment(endDate);\n\n        while (tempEnd.diff(tempBegin) >= 0) {\n            dates.push(tempBegin.valueOf());\n\n            tempBegin = tempBegin.add(interval, 'ms');\n        }\n\n        return dates;\n    }\n\n    private static createEventNode(contextId: string, groupId, nodeId: string, eventInfo: EventInterface, userInfo: any): Promise<SpinalNodeRef> {\n        if (!eventInfo.repeat) {\n            delete eventInfo.periodicity;\n            delete eventInfo.repeatEnd;\n        }\n\n        if (eventInfo.startDate) {\n            let date = new Date(eventInfo.startDate).toISOString();\n            eventInfo.startDate = moment(date).format(\"LLLL\");\n        }\n        if (eventInfo.endDate) {\n            let date = new Date(eventInfo.endDate).toISOString();\n            eventInfo.endDate = moment(date).format(\"LLLL\");\n        }\n        if (eventInfo.creationDate) {\n            let date = new Date(eventInfo.creationDate).toISOString();\n            eventInfo.creationDate = moment(date).format(\"LLLL\");\n        }\n        if (eventInfo.repeatEnd) {\n            let date = new Date(eventInfo.repeatEnd).toISOString();\n            eventInfo.repeatEnd = moment(date).format(\"LLLL\");\n        }\n\n        eventInfo.contextId = contextId;\n        eventInfo.groupId = groupId;\n        eventInfo.nodeId = nodeId;\n        eventInfo.type = SpinalEvent.EVENT_TYPE;\n        eventInfo.user = userInfo;\n\n\n        // const taskModel = new SpinalEvent(eventInfo);\n        const eventId = SpinalGraphService.createNode(eventInfo, new Model());\n        return groupManagerService.linkElementToGroup(contextId, groupId, eventId).then(async (result) => {\n            await SpinalGraphService.addChild(nodeId, eventId, RELATION_NAME, SPINAL_RELATION_PTR_LST_TYPE);\n            await this.createAttribute(eventId);\n\n            return SpinalGraphService.getInfo(eventId);\n        })\n    }\n\n    private static createAttribute(nodeId: string): Promise<SpinalAttribute[]> {\n        const categoryName: string = \"default\";\n        const realNode = SpinalGraphService.getRealNode(nodeId);\n        return serviceDocumentation.addCategoryAttribute(realNode, categoryName).then((attributeCategory) => {\n            const promises = []\n\n            promises.push(serviceDocumentation.addAttributeByCategory(realNode, attributeCategory, \"name\", <any>realNode.info.name));\n            const attributes = [\"startDate\", \"endDate\", \"creationDate\", \"repeatEnd\"];\n\n            for (const key of attributes) {\n                if (realNode.info[key]) {\n                    // const date = moment(realNode.info[key].get()).format('LL')\n                    promises.push(serviceDocumentation.addAttributeByCategory(realNode, attributeCategory, key, realNode.info[key]));\n                }\n            }\n\n            if (realNode.info.periodicity) {\n                const value = `${realNode.info.periodicity.count.get()} ${invers_period[realNode.info.periodicity.period.get()]}`\n                promises.push(serviceDocumentation.addAttributeByCategory(realNode, attributeCategory, \"periodicity\", value));\n            }\n\n            return Promise.all(promises);\n        })\n    }\n\n    private static async _getGroupId(eventId: string): Promise<SpinalNodeRef> {\n        const info = SpinalGraphService.getInfo(eventId);\n        let groupInfo = SpinalGraphService.getInfo(info.groupId);\n        if (groupInfo) {\n            return groupInfo;\n        }\n\n        const parents = await SpinalGraphService.getParents(eventId, [`groupHas${EVENT_TYPE}`]);\n        return parents.find(el => el.id.get() === info.groupId.get());\n    }\n\n    private static async _getNodeId(eventId): Promise<SpinalNodeRef> {\n        const info = SpinalGraphService.getInfo(eventId);\n        let nodeInfo = SpinalGraphService.getInfo(info.nodeId);\n        if (nodeInfo) {\n            return nodeInfo;\n        }\n\n        const parents = await SpinalGraphService.getParents(eventId, [RELATION_NAME]);\n        return parents.find(el => el.id.get() === info.nodeId.get());\n    }\n}","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalEvent = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst moment = require(\"moment\");\nclass SpinalEvent extends spinal_core_connectorjs_type_1.Model {\n    constructor(task) {\n        super();\n        if (!!task) {\n            task.creationDate = moment(Date.now()).format(\"LLLL\");\n            task.done = false;\n            this.add_attr(task);\n        }\n    }\n}\nexports.SpinalEvent = SpinalEvent;\nSpinalEvent.EVENT_TYPE = \"SpinalEvent\";\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalEvent);\n//# sourceMappingURL=SpinalEvent.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { Model, spinalCore } from \"spinal-core-connectorjs_type\";\nimport { EventInterface } from \"../types/EventInterface\";\nimport * as moment from \"moment\"\n\nexport class SpinalEvent extends Model {\n\n    public static EVENT_TYPE: string = \"SpinalEvent\";\n\n    constructor(task: EventInterface) {\n        super();\n        if (!!task) {\n            task.creationDate = moment(Date.now()).format(\"LLLL\");\n            task.done = false;\n            this.add_attr(task);\n        }\n    }\n}\n\nspinalCore.register_models(SpinalEvent);","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RELATION_NAME = exports.EVENT_TYPE = exports.CONTEXT_TYPE = exports.DEFAULT_GROUP_NAME = exports.DEFAULT_CATEGORY_NAME = exports.DEFAULT_CONTEXT_NAME = void 0;\nconst SpinalEvent_1 = require(\"../models/SpinalEvent\");\nexports.DEFAULT_CONTEXT_NAME = \"Default_event_context\";\nexports.DEFAULT_CATEGORY_NAME = \"Default_category\";\nexports.DEFAULT_GROUP_NAME = \"Default_group\";\nexports.CONTEXT_TYPE = `${SpinalEvent_1.SpinalEvent.EVENT_TYPE}GroupContext`;\nexports.EVENT_TYPE = \"SpinalEvent\";\nexports.RELATION_NAME = \"hasEvent\";\n//# sourceMappingURL=constants.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { SpinalEvent } from \"../models/SpinalEvent\";\n\nexport const DEFAULT_CONTEXT_NAME: string = \"Default_event_context\";\nexport const DEFAULT_CATEGORY_NAME: string = \"Default_category\";\nexport const DEFAULT_GROUP_NAME: string = \"Default_group\";\n\nexport const CONTEXT_TYPE: string = `${SpinalEvent.EVENT_TYPE}GroupContext`;\nexport const EVENT_TYPE: string = \"SpinalEvent\";\nexport const RELATION_NAME: string = \"hasEvent\";\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.invers_period = exports.Period = void 0;\nexports.Period = Object.freeze({\n    day: 86400000,\n    week: 604800000,\n    month: 2629800000,\n    year: 31557600000\n});\nexports.invers_period = Object.freeze({\n    86400000: \"day\",\n    604800000: \"week\",\n    2629800000: \"month\",\n    31557600000: \"year\"\n});\n//# sourceMappingURL=EventInterface.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nexport const Period = Object.freeze({\n    day: 86400000,\n    week: 604800000,\n    month: 2629800000,\n    year: 31557600000\n})\n\nexport const invers_period = Object.freeze({\n    86400000: \"day\",\n    604800000: \"week\",\n    2629800000: \"month\",\n    31557600000: \"year\"\n})\n\nexport interface EventInterface {\n    contextId?: string;\n    groupId?: string;\n    categoryId?: string;\n    nodeId: string;\n    assignedTo?: any;\n    startDate?: string;\n    user?: any;\n    description?: string;\n    endDate?: string;\n    periodicity: { count: number, period: number };\n    repeat: boolean;\n    name: string;\n    done?: Boolean;\n    creationDate?: string;\n    repeatEnd?: string;\n    [key: string]: any;\n}","\"use strict\";\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.REFERENCE_ROOM_RELATION = exports.ROOM_REFERENCE_CONTEXT = exports.ZONE_REFERENCE_CONTEXT = exports.FLOOR_REFERENCE_CONTEXT = exports.BUILDING_REFERENCE_CONTEXT = exports.SITE_REFERENCE_CONTEXT = exports.REFERENCE_RELATION = exports.REFERENCE_TYPE = exports.MAP_RELATION_TYPE = exports.MAP_TYPE_RELATION = exports.GEOGRAPHIC_RELATIONS_ORDER = exports.EQUIPMENT_RELATION = exports.GEOGRAPHIC_RELATIONS = exports.ROOM_RELATION = exports.ZONE_RELATION = exports.FLOOR_RELATION = exports.BUILDING_RELATION = exports.SITE_RELATION = exports.GEOGRAPHIC_TYPES_ORDER = exports.EQUIPMENT_TYPE = exports.GEOGRAPHIC_TYPES = exports.ROOM_TYPE = exports.ZONE_TYPE = exports.FLOOR_TYPE = exports.BUILDING_TYPE = exports.SITE_TYPE = exports.CONTEXT_TYPE = void 0;\nconst CONTEXT_TYPE = 'geographicContext';\nexports.CONTEXT_TYPE = CONTEXT_TYPE;\nconst SITE_TYPE = 'geographicSite';\nexports.SITE_TYPE = SITE_TYPE;\nconst BUILDING_TYPE = 'geographicBuilding';\nexports.BUILDING_TYPE = BUILDING_TYPE;\nconst FLOOR_TYPE = 'geographicFloor';\nexports.FLOOR_TYPE = FLOOR_TYPE;\nconst ZONE_TYPE = 'geographicZone';\nexports.ZONE_TYPE = ZONE_TYPE;\nconst ROOM_TYPE = 'geographicRoom';\nexports.ROOM_TYPE = ROOM_TYPE;\nconst EQUIPMENT_TYPE = 'BIMObject';\nexports.EQUIPMENT_TYPE = EQUIPMENT_TYPE;\nconst REFERENCE_TYPE = 'geographicReference';\nexports.REFERENCE_TYPE = REFERENCE_TYPE;\nconst SITE_RELATION = 'hasGeographicSite';\nexports.SITE_RELATION = SITE_RELATION;\nconst BUILDING_RELATION = 'hasGeographicBuilding';\nexports.BUILDING_RELATION = BUILDING_RELATION;\nconst FLOOR_RELATION = 'hasGeographicFloor';\nexports.FLOOR_RELATION = FLOOR_RELATION;\nconst ZONE_RELATION = 'hasGeographicZone';\nexports.ZONE_RELATION = ZONE_RELATION;\nconst ROOM_RELATION = 'hasGeographicRoom';\nexports.ROOM_RELATION = ROOM_RELATION;\nconst EQUIPMENT_RELATION = 'hasBimObject';\nexports.EQUIPMENT_RELATION = EQUIPMENT_RELATION;\nconst REFERENCE_RELATION = 'hasReferenceObject';\nexports.REFERENCE_RELATION = REFERENCE_RELATION;\nconst REFERENCE_ROOM_RELATION = 'hasReferenceObject.ROOM';\nexports.REFERENCE_ROOM_RELATION = REFERENCE_ROOM_RELATION;\nconst SITE_REFERENCE_CONTEXT = '.SiteContext';\nexports.SITE_REFERENCE_CONTEXT = SITE_REFERENCE_CONTEXT;\nconst BUILDING_REFERENCE_CONTEXT = '.BuildingContext';\nexports.BUILDING_REFERENCE_CONTEXT = BUILDING_REFERENCE_CONTEXT;\nconst FLOOR_REFERENCE_CONTEXT = '.FloorContext';\nexports.FLOOR_REFERENCE_CONTEXT = FLOOR_REFERENCE_CONTEXT;\nconst ZONE_REFERENCE_CONTEXT = '.ZoneContext';\nexports.ZONE_REFERENCE_CONTEXT = ZONE_REFERENCE_CONTEXT;\nconst ROOM_REFERENCE_CONTEXT = '.RoomContext';\nexports.ROOM_REFERENCE_CONTEXT = ROOM_REFERENCE_CONTEXT;\nconst GEOGRAPHIC_TYPES = Object.freeze([\n    SITE_TYPE,\n    BUILDING_TYPE,\n    FLOOR_TYPE,\n    ZONE_TYPE,\n    ROOM_TYPE,\n]);\nexports.GEOGRAPHIC_TYPES = GEOGRAPHIC_TYPES;\nconst GEOGRAPHIC_TYPES_ORDER = Object.freeze([\n    CONTEXT_TYPE,\n    SITE_TYPE,\n    BUILDING_TYPE,\n    FLOOR_TYPE,\n    ZONE_TYPE,\n    ROOM_TYPE,\n    EQUIPMENT_TYPE,\n]);\nexports.GEOGRAPHIC_TYPES_ORDER = GEOGRAPHIC_TYPES_ORDER;\nconst GEOGRAPHIC_RELATIONS = Object.freeze([\n    SITE_RELATION,\n    BUILDING_RELATION,\n    FLOOR_RELATION,\n    ZONE_RELATION,\n    ROOM_RELATION,\n    EQUIPMENT_RELATION,\n]);\nexports.GEOGRAPHIC_RELATIONS = GEOGRAPHIC_RELATIONS;\nconst GEOGRAPHIC_RELATIONS_ORDER = Object.freeze([\n    SITE_RELATION,\n    BUILDING_RELATION,\n    FLOOR_RELATION,\n    ZONE_RELATION,\n    ROOM_RELATION,\n    EQUIPMENT_RELATION,\n]);\nexports.GEOGRAPHIC_RELATIONS_ORDER = GEOGRAPHIC_RELATIONS_ORDER;\nconst MAP_TYPE_RELATION = Object.freeze(new Map([\n    [SITE_TYPE, SITE_RELATION],\n    [BUILDING_TYPE, BUILDING_RELATION],\n    [FLOOR_TYPE, FLOOR_RELATION],\n    [ZONE_TYPE, ZONE_RELATION],\n    [ROOM_TYPE, ROOM_RELATION],\n    [EQUIPMENT_TYPE, EQUIPMENT_RELATION],\n]));\nexports.MAP_TYPE_RELATION = MAP_TYPE_RELATION;\nconst MAP_RELATION_TYPE = Object.freeze(new Map([\n    [SITE_RELATION, SITE_TYPE],\n    [BUILDING_RELATION, BUILDING_TYPE],\n    [FLOOR_RELATION, FLOOR_TYPE],\n    [ZONE_RELATION, ZONE_TYPE],\n    [ROOM_RELATION, ROOM_TYPE],\n    [EQUIPMENT_RELATION, EQUIPMENT_TYPE],\n]));\nexports.MAP_RELATION_TYPE = MAP_RELATION_TYPE;\n//# sourceMappingURL=constants.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nconst CONTEXT_TYPE = 'geographicContext';\nconst SITE_TYPE = 'geographicSite';\nconst BUILDING_TYPE = 'geographicBuilding';\nconst FLOOR_TYPE = 'geographicFloor';\nconst ZONE_TYPE = 'geographicZone';\nconst ROOM_TYPE = 'geographicRoom';\nconst EQUIPMENT_TYPE = 'BIMObject';\nconst REFERENCE_TYPE = 'geographicReference';\n\nconst SITE_RELATION = 'hasGeographicSite';\nconst BUILDING_RELATION = 'hasGeographicBuilding';\nconst FLOOR_RELATION = 'hasGeographicFloor';\nconst ZONE_RELATION = 'hasGeographicZone';\nconst ROOM_RELATION = 'hasGeographicRoom';\nconst EQUIPMENT_RELATION = 'hasBimObject';\nconst REFERENCE_RELATION = 'hasReferenceObject';\nconst REFERENCE_ROOM_RELATION = 'hasReferenceObject.ROOM';\n\nconst SITE_REFERENCE_CONTEXT = '.SiteContext';\nconst BUILDING_REFERENCE_CONTEXT = '.BuildingContext';\nconst FLOOR_REFERENCE_CONTEXT = '.FloorContext';\nconst ZONE_REFERENCE_CONTEXT = '.ZoneContext';\nconst ROOM_REFERENCE_CONTEXT = '.RoomContext';\n\nconst GEOGRAPHIC_TYPES = Object.freeze([\n  SITE_TYPE,\n  BUILDING_TYPE,\n  FLOOR_TYPE,\n  ZONE_TYPE,\n  ROOM_TYPE,\n]) as string[];\n\nconst GEOGRAPHIC_TYPES_ORDER = Object.freeze([\n  CONTEXT_TYPE,\n  SITE_TYPE,\n  BUILDING_TYPE,\n  FLOOR_TYPE,\n  ZONE_TYPE,\n  ROOM_TYPE,\n  EQUIPMENT_TYPE,\n]) as string[];\n\nconst GEOGRAPHIC_RELATIONS = Object.freeze([\n  SITE_RELATION,\n  BUILDING_RELATION,\n  FLOOR_RELATION,\n  ZONE_RELATION,\n  ROOM_RELATION,\n  EQUIPMENT_RELATION,\n]) as string[];\n\nconst GEOGRAPHIC_RELATIONS_ORDER = Object.freeze([\n  SITE_RELATION,\n  BUILDING_RELATION,\n  FLOOR_RELATION,\n  ZONE_RELATION,\n  ROOM_RELATION,\n  EQUIPMENT_RELATION,\n]) as string[];\n\nconst MAP_TYPE_RELATION = Object.freeze(\n  new Map([\n    [SITE_TYPE, SITE_RELATION],\n    [BUILDING_TYPE, BUILDING_RELATION],\n    [FLOOR_TYPE, FLOOR_RELATION],\n    [ZONE_TYPE, ZONE_RELATION],\n    [ROOM_TYPE, ROOM_RELATION],\n    [EQUIPMENT_TYPE, EQUIPMENT_RELATION],\n  ])\n) as Map<string, string>;\n\nconst MAP_RELATION_TYPE = Object.freeze(\n  new Map([\n    [SITE_RELATION, SITE_TYPE],\n    [BUILDING_RELATION, BUILDING_TYPE],\n    [FLOOR_RELATION, FLOOR_TYPE],\n    [ZONE_RELATION, ZONE_TYPE],\n    [ROOM_RELATION, ROOM_TYPE],\n    [EQUIPMENT_RELATION, EQUIPMENT_TYPE],\n  ])\n) as Map<string, string>;\n\nexport {\n  CONTEXT_TYPE,\n  SITE_TYPE,\n  BUILDING_TYPE,\n  FLOOR_TYPE,\n  ZONE_TYPE,\n  ROOM_TYPE,\n  GEOGRAPHIC_TYPES,\n  EQUIPMENT_TYPE,\n  GEOGRAPHIC_TYPES_ORDER,\n  SITE_RELATION,\n  BUILDING_RELATION,\n  FLOOR_RELATION,\n  ZONE_RELATION,\n  ROOM_RELATION,\n  GEOGRAPHIC_RELATIONS,\n  EQUIPMENT_RELATION,\n  GEOGRAPHIC_RELATIONS_ORDER,\n  MAP_TYPE_RELATION,\n  MAP_RELATION_TYPE,\n  REFERENCE_TYPE,\n  REFERENCE_RELATION,\n  SITE_REFERENCE_CONTEXT,\n  BUILDING_REFERENCE_CONTEXT,\n  FLOOR_REFERENCE_CONTEXT,\n  ZONE_REFERENCE_CONTEXT,\n  ROOM_REFERENCE_CONTEXT,\n  REFERENCE_ROOM_RELATION\n};\n"],"names":[],"version":3,"file":"dist.58795e0e.js.map"}