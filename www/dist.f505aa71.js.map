{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A;ACAA;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,e,S,c;I,O;A;A,Q,4B,K;AAEH,MAAA,qBAAA,QAAA;AACA,MAAA,WAAA,QAAA;AAEA,MAAM,aAAkB,OAAO,WAAW,cAAc,SAAS;AAEjE,SAAS,YAAY,kBAAuB,EAAE,gBAAuB;IACjE,iBAAiB,QAAQ,CAAA;QACrB,OAAO,oBAAoB,gBAAgB,WACtC,QAAQ,CAAA;YACL,OAAO,eAAe,mBAAmB,WACrC,MACA,OACI,yBACI,gBAAgB,WAChB;QAGhB;IACR;AACJ;AAEA,MAAM;IAAN,aAAA;QACW,IAAA,CAAA,kBAA0B;QAC1B,IAAA,CAAA,qBAA6B;IACxC;AAAC;AAID,YAAY,2BAA2B;IAAC,mBAAA;IAAkB,SAAA;CAAmB;AAE7E,MAAM,4BAA4B,IAAI;AAI7B,QAAA,4BAAA;AAFT,WAAW,4BAA4B;AAIvC,QAAA,UAAe;;;A;AE5Df;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,Y,A,I,I,I,C,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;A,O,e,S,c;I,O;A;A,Q,mB,K;AAEH,MAAA,mDAAA,QAAA;AACA,MAAA,oCAAA,QAAA;AAGA,MAAa;IAKV,aAAA;QAHO,IAAA,CAAA,kBAA0B;QAC1B,IAAA,CAAA,qBAA6B;IAEb;IAEvB;;;;;KAKG,GACU,mBAAmB,WAAoB,EAAvC;Q,O,U,I,E,K,G,K,G;YACV,IAAI,YAAY;YAChB,IAAI,CAAC,eAAe,AAAA,CAAA,gBAAW,QAAX,gBAAW,KAAA,IAAA,KAAA,IAAX,Y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","sources":["node_modules/spinal-env-viewer-plugin-nomenclature-service/dist/index.js","node_modules/spinal-env-viewer-plugin-nomenclature-service/src/index.ts","node_modules/spinal-env-viewer-plugin-nomenclature-service/dist/modules/NomenclatureTree.js","node_modules/spinal-env-viewer-plugin-nomenclature-service/src/modules/NomenclatureTree.ts","node_modules/spinal-env-viewer-plugin-nomenclature-service/dist/modules/Profil.js","node_modules/spinal-env-viewer-plugin-nomenclature-service/src/modules/Profil.ts"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2022 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.spinalNomenclatureService = void 0;\nconst NomenclatureTree_1 = require(\"./modules/NomenclatureTree\");\nconst Profil_1 = require(\"./modules/Profil\");\nconst globalType = typeof window === \"undefined\" ? global : window;\nfunction applyMixins(derivedConstructor, baseConstructors) {\n    baseConstructors.forEach(baseConstructor => {\n        Object.getOwnPropertyNames(baseConstructor.prototype)\n            .forEach(name => {\n            Object.defineProperty(derivedConstructor.prototype, name, Object.\n                getOwnPropertyDescriptor(baseConstructor.prototype, name));\n        });\n    });\n}\nclass SpinalNomenclatureService {\n    constructor() {\n        this.profileNodeType = \"AttributeConfiguration\";\n        this.defaultContextName = \"NomenclatureConfiguration\";\n    }\n}\n;\n;\napplyMixins(SpinalNomenclatureService, [NomenclatureTree_1.NomenclatureTree, Profil_1.NomenclatureProfil]);\nconst spinalNomenclatureService = new SpinalNomenclatureService();\nexports.spinalNomenclatureService = spinalNomenclatureService;\nglobalType.spinalNomenclatureService = spinalNomenclatureService;\nexports.default = spinalNomenclatureService;\n//# sourceMappingURL=index.js.map","/*\n * Copyright 2022 SpinalCom - www.spinalcom.com\n * \n * This file is part of SpinalCore.\n * \n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n * \n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n * \n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { NomenclatureTree } from \"./modules/NomenclatureTree\";\nimport { NomenclatureProfil } from \"./modules/Profil\";\n\nconst globalType: any = typeof window === \"undefined\" ? global : window;\n\nfunction applyMixins(derivedConstructor: any, baseConstructors: any[]) {\n    baseConstructors.forEach(baseConstructor => {\n        Object.getOwnPropertyNames(baseConstructor.prototype)\n            .forEach(name => {\n                Object.defineProperty(derivedConstructor.prototype,\n                    name,\n                    Object.\n                        getOwnPropertyDescriptor(\n                            baseConstructor.prototype,\n                            name\n                        )\n                );\n            });\n    });\n}\n\nclass SpinalNomenclatureService {\n    public profileNodeType: string = \"AttributeConfiguration\";\n    public defaultContextName: string = \"NomenclatureConfiguration\";\n};\n\ninterface SpinalNomenclatureService extends NomenclatureProfil, NomenclatureTree { };\n\napplyMixins(SpinalNomenclatureService, [NomenclatureTree, NomenclatureProfil]);\n\nconst spinalNomenclatureService = new SpinalNomenclatureService();\n\nglobalType.spinalNomenclatureService = spinalNomenclatureService;\n\nexport { spinalNomenclatureService };\n\nexport default spinalNomenclatureService;\n","\"use strict\";\n/*\n * Copyright 2022 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NomenclatureTree = void 0;\nconst spinal_env_viewer_plugin_group_manager_service_1 = require(\"spinal-env-viewer-plugin-group-manager-service\");\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nclass NomenclatureTree {\n    constructor() {\n        this.profileNodeType = \"AttributeConfiguration\";\n        this.defaultContextName = \"NomenclatureConfiguration\";\n    }\n    /**\n     * This method takes a context name as a parameter (not required),\n     * If no name is passed it creates or returns the default context (NomenclatureConfiguration)\n     * @param contextName - string - not required\n     * @returns Promise<SpinalContext>\n     */\n    createOrGetContext(contextName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let isDefault = false;\n            if (!contextName || (contextName === null || contextName === void 0 ? void 0 : contextName.trim().length) === 0) {\n                const defaultContext = yield this.getDefaultContext();\n                if (defaultContext)\n                    return defaultContext;\n                isDefault = true;\n                contextName = this.defaultContextName;\n            }\n            ;\n            const context = yield spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.createGroupContext(contextName.trim(), this.profileNodeType);\n            if (!isDefault)\n                return context;\n            if (context.info.isDefault)\n                context.info.isDefault.set(isDefault);\n            else\n                context.info.add_attr({ isDefault: true });\n            return context;\n        });\n    }\n    getDefaultContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const contexts = yield this.getContexts();\n            const found = contexts.find(el => typeof el.info.isDefault !== \"undefined\");\n            if (found)\n                return found;\n        });\n    }\n    /**\n     * This method returns a context (if contextName or id is passed) or all profil contexts\n     * @param contextName - string - contextName not required\n     * @returns Promise<SpinalContext | SpinalContext[]>\n     */\n    getContexts(contextName, graph) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const contexts = yield spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.getGroupContexts(this.profileNodeType, graph);\n            if (contextName && contextName.trim().length > 0) {\n                const context = contexts.find(el => el.name === contextName || el.id === contextName);\n                return spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(context === null || context === void 0 ? void 0 : context.id);\n            }\n            return contexts.map(el => spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(el === null || el === void 0 ? void 0 : el.id));\n        });\n    }\n    /**\n     * This method updates a contextName, it takes as parameter two strings (contextId and context new Name)\n     * @param contextId - string - the context id\n     * @param newName  - string - new context name\n     * @returns SpinalContext\n     */\n    updateContext(contextId, newName) {\n        const spinalContext = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(contextId);\n        if (!spinalContext || !(spinalContext instanceof spinal_env_viewer_graph_service_1.SpinalContext) || spinalContext.getType().get() !== `${this.profileNodeType}GroupContext`)\n            throw new Error(`${contextId} must be an id of profil SpinalContext`);\n        if (typeof newName !== \"string\" || newName.trim().length === 0)\n            throw new Error(\"newName is required and must be a string at less 1 character\");\n        spinalContext.info.name.set(newName.trim());\n        return spinalContext;\n    }\n    /**\n     * This method creates and links category to a profil context, it takes as parameters contextName, iconName (not required) and contextId (not required)\n     * @param categoryName - string (required)\n     * @param iconName - string (not required default value = settings)\n     * @param contextId - string (not required default value = default contextId)\n     * @returns Promise<SpinalNode>\n     */\n    createCategory(categoryName, iconName = \"settings\", contextId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!contextId) {\n                const context = yield this.getDefaultContext();\n                contextId = context.getId().get();\n            }\n            return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.addCategory(contextId, categoryName.trim(), iconName.trim());\n        });\n    }\n    /**\n     * This method returns a category of context (if category name or id is passed) or all categories of context\n     * @param contextId - contextId\n     * @param categoryName  - category name or id (not required)\n     * @returns\n     */\n    getCategories(categoryName, contextId) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof contextId === \"undefined\") {\n                const context = yield this.getDefaultContext();\n                contextId = context.getId().get();\n            }\n            const categories = yield spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.getCategories(contextId);\n            if (categoryName && categoryName.trim().length > 0) {\n                const category = categories.find(el => el.name.get() === categoryName || el.id.get() === categoryName);\n                return spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode((_a = category === null || category === void 0 ? void 0 : category.id) === null || _a === void 0 ? void 0 : _a.get());\n            }\n            return categories.map(el => { var _a; return spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode((_a = el === null || el === void 0 ? void 0 : el.id) === null || _a === void 0 ? void 0 : _a.get()); });\n        });\n    }\n    /**\n     * This method updates a category, it takes as parameter two strings (categoryId and category new Values)\n     * @param categoryId - string - the category Id\n     * @param newValues - {name?: string; icon?: string } - object of new values (name and icon)\n     * @returns\n     */\n    updateCategory(categoryId, newValues) {\n        const node = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(categoryId);\n        const { name, icon } = newValues;\n        if (node && (name || icon)) {\n            if (typeof name === \"string\" && name.trim().length > 0)\n                node.info.name.set(name.trim());\n            if (typeof icon === \"string\" && icon.trim().length > 0) {\n                if (node.info.icon)\n                    node.info.icon.set(icon.trim());\n                else\n                    node.info.add_attr({ icon });\n            }\n            return node;\n        }\n    }\n    /**\n     * It takes as parameters a contextId, categoryId, groupName et groupColor in hexadecimal (not required) and returns a spinalNode of group\n     * @param contextId - contextId\n     * @param categoryId - categoryId\n     * @param groupName - group name\n     * @param groupColor - group color (not required)\n     * @returns\n     */\n    createGroup(contextId, categoryId, groupName, groupColor = \"#fff000\") {\n        if (typeof groupName !== \"string\" || groupName.trim().length === 0)\n            throw new Error(\"group name must be a string less than 1 character\");\n        if (!groupColor || groupColor.trim().length === 0)\n            groupColor = \"#fff000\";\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.addGroup(contextId, categoryId, groupName, groupColor);\n    }\n    /**\n     * This method updates a group, it takes as parameter two strings (groupId and new values)\n     * @param groupId - string - the group Id\n     * @param newValues - {name?: string; color?: string } - object of new values (name and color)\n     * @returns\n     */\n    updateGroup(groupId, newValues) {\n        const node = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(groupId);\n        const { name, color } = newValues;\n        if (node && (name || color)) {\n            if (typeof name === \"string\" && name.trim().length > 0)\n                node.info.name.set(name.trim());\n            if (typeof color === \"string\" && color.trim().length > 0) {\n                if (node.info.color)\n                    node.info.color.set(color.trim());\n                else\n                    node.info.add_attr({ color });\n            }\n            return node;\n        }\n    }\n    /**\n     * This methods takes as parameters a contextId and category id (not required), it returns all groups in category (or categories if not category id is set) in context\n     * @param contextId - context id\n     * @param categoryId - category id (not required)\n     * @returns\n     */\n    getGroups(contextId, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let categories = yield this.getCategories(categoryId, contextId);\n            if (categories) {\n                if (!Array.isArray(categories))\n                    categories = [categories];\n                const promises = categories.map((category) => __awaiter(this, void 0, void 0, function* () {\n                    const info = category.info.get();\n                    info.groups = yield spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.getGroups(category.getId().get());\n                    return info;\n                }));\n                return Promise.all(promises).then((cats) => {\n                    return cats.map(category => {\n                        category.groups = category.groups.map(el => spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(el.id.get()));\n                        return category;\n                    });\n                });\n            }\n            return [];\n        });\n    }\n}\nexports.NomenclatureTree = NomenclatureTree;\n//# sourceMappingURL=NomenclatureTree.js.map","/*\n * Copyright 2022 SpinalCom - www.spinalcom.com\n * \n * This file is part of SpinalCore.\n * \n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n * \n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n * \n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { groupManagerService } from \"spinal-env-viewer-plugin-group-manager-service\";\nimport { SpinalContext, SpinalGraph, SpinalGraphService, SpinalNode } from \"spinal-env-viewer-graph-service\";\nimport { IGroups } from \"../interfaces/IGroups\";\n\nexport class NomenclatureTree {\n\n   public profileNodeType: string = \"AttributeConfiguration\";\n   public defaultContextName: string = \"NomenclatureConfiguration\";\n\n   public constructor() { }\n\n   /**\n    * This method takes a context name as a parameter (not required),\n    * If no name is passed it creates or returns the default context (NomenclatureConfiguration)\n    * @param contextName - string - not required\n    * @returns Promise<SpinalContext>\n    */\n   public async createOrGetContext(contextName?: string): Promise<SpinalContext<any>> {\n      let isDefault = false;\n      if (!contextName || contextName?.trim().length === 0) {\n         const defaultContext = await this.getDefaultContext();\n         if (defaultContext) return defaultContext;\n\n         isDefault = true;\n         contextName = this.defaultContextName\n      };\n\n      const context = await groupManagerService.createGroupContext(contextName.trim(), this.profileNodeType);\n      if (!isDefault) return context;\n\n      if (context.info.isDefault) context.info.isDefault.set(isDefault);\n      else context.info.add_attr({ isDefault: true });\n\n      return context;\n   }\n\n\n   public async getDefaultContext(): Promise<SpinalContext<any>> {\n      const contexts = await this.getContexts();\n      const found = (<any>contexts).find(el => typeof (<any>el).info.isDefault !== \"undefined\");\n      if (found) return found;\n\n   }\n\n\n   /**\n    * This method returns a context (if contextName or id is passed) or all profil contexts\n    * @param contextName - string - contextName not required\n    * @returns Promise<SpinalContext | SpinalContext[]>\n    */\n   public async getContexts(contextName?: string, graph?: SpinalGraph<any>): Promise<SpinalContext<any>[] | SpinalContext<any>> {\n      const contexts = await groupManagerService.getGroupContexts(this.profileNodeType, graph);\n      if (contextName && contextName.trim().length > 0) {\n         const context = contexts.find(el => el.name === contextName || el.id === contextName);\n         return SpinalGraphService.getRealNode(context?.id);\n      }\n\n      return contexts.map(el => SpinalGraphService.getRealNode(el?.id));\n   }\n\n   /**\n    * This method updates a contextName, it takes as parameter two strings (contextId and context new Name)\n    * @param contextId - string - the context id \n    * @param newName  - string - new context name\n    * @returns SpinalContext\n    */\n   public updateContext(contextId: string, newName: string): SpinalContext<any> {\n      const spinalContext = SpinalGraphService.getRealNode(contextId);\n      if (!spinalContext || !(spinalContext instanceof SpinalContext) || spinalContext.getType().get() !== `${this.profileNodeType}GroupContext`) throw new Error(`${contextId} must be an id of profil SpinalContext`);\n      if (typeof newName !== \"string\" || newName.trim().length === 0) throw new Error(\"newName is required and must be a string at less 1 character\");\n\n      spinalContext.info.name.set(newName.trim());\n      return spinalContext;\n   }\n\n\n   /**\n    * This method creates and links category to a profil context, it takes as parameters contextName, iconName (not required) and contextId (not required)\n    * @param categoryName - string (required)\n    * @param iconName - string (not required default value = settings) \n    * @param contextId - string (not required default value = default contextId)\n    * @returns Promise<SpinalNode>\n    */\n   public async createCategory(categoryName: string, iconName: string = \"settings\", contextId?: string): Promise<SpinalNode<any>> {\n      if (!contextId) {\n         const context = await this.getDefaultContext();\n         contextId = context.getId().get();\n      }\n\n      return groupManagerService.addCategory(contextId, categoryName.trim(), iconName.trim());\n   }\n\n\n   /**\n    * This method returns a category of context (if category name or id is passed) or all categories of context\n    * @param contextId - contextId\n    * @param categoryName  - category name or id (not required)\n    * @returns \n    */\n   public async getCategories(categoryName?: string, contextId?: string): Promise<SpinalNode<any> | SpinalNode<any>[]> {\n      if (typeof contextId === \"undefined\") {\n         const context = await this.getDefaultContext()\n         contextId = context.getId().get();\n      }\n\n      const categories = await groupManagerService.getCategories(contextId);\n\n      if (categoryName && categoryName.trim().length > 0) {\n         const category = categories.find(el => el.name.get() === categoryName || el.id.get() === categoryName);\n         return SpinalGraphService.getRealNode(category?.id?.get());\n      }\n\n      return categories.map(el => SpinalGraphService.getRealNode(el?.id?.get()));\n   }\n\n\n   /**\n    * This method updates a category, it takes as parameter two strings (categoryId and category new Values)\n    * @param categoryId - string - the category Id\n    * @param newValues - {name?: string; icon?: string } - object of new values (name and icon)\n    * @returns \n    */\n   public updateCategory(categoryId: string, newValues: { name?: string; icon?: string }): SpinalNode<any> | void {\n      const node = SpinalGraphService.getRealNode(categoryId);\n      const { name, icon } = newValues;\n      if (node && (name || icon)) {\n         if (typeof name === \"string\" && name.trim().length > 0) node.info.name.set(name.trim());\n         if (typeof icon === \"string\" && icon.trim().length > 0) {\n            if (node.info.icon) node.info.icon.set(icon.trim());\n            else node.info.add_attr({ icon });\n         }\n\n         return node;\n      }\n   }\n\n   /**\n    * It takes as parameters a contextId, categoryId, groupName et groupColor in hexadecimal (not required) and returns a spinalNode of group\n    * @param contextId - contextId\n    * @param categoryId - categoryId\n    * @param groupName - group name \n    * @param groupColor - group color (not required)\n    * @returns \n    */\n   public createGroup(contextId: string, categoryId: string, groupName: string, groupColor: string = \"#fff000\"): Promise<SpinalNode<any>> {\n      if (typeof groupName !== \"string\" || groupName.trim().length === 0) throw new Error(\"group name must be a string less than 1 character\");\n      if (!groupColor || groupColor.trim().length === 0) groupColor = \"#fff000\";\n\n      return groupManagerService.addGroup(contextId, categoryId, groupName, groupColor);\n   }\n\n\n   /**\n    * This method updates a group, it takes as parameter two strings (groupId and new values)\n    * @param groupId - string - the group Id\n    * @param newValues - {name?: string; color?: string } - object of new values (name and color)\n    * @returns \n    */\n   public updateGroup(groupId: string, newValues: { name?: string; color?: string }): SpinalNode<any> | void {\n      const node = SpinalGraphService.getRealNode(groupId);\n      const { name, color } = newValues;\n      if (node && (name || color)) {\n         if (typeof name === \"string\" && name.trim().length > 0) node.info.name.set(name.trim());\n         if (typeof color === \"string\" && color.trim().length > 0) {\n            if (node.info.color) node.info.color.set(color.trim());\n            else node.info.add_attr({ color });\n         }\n\n         return node;\n      }\n   }\n\n   /**\n    * This methods takes as parameters a contextId and category id (not required), it returns all groups in category (or categories if not category id is set) in context\n    * @param contextId - context id\n    * @param categoryId - category id (not required)\n    * @returns \n    */\n   public async getGroups(contextId: string, categoryId?: string): Promise<IGroups[]> {\n      let categories = await this.getCategories(categoryId, contextId);\n      if (categories) {\n         if (!Array.isArray(categories)) categories = [categories];\n         const promises = categories.map(async category => {\n            const info = category.info.get();\n            info.groups = await groupManagerService.getGroups(category.getId().get());\n            return info;\n         })\n\n         return Promise.all(promises).then((cats) => {\n            return cats.map(category => {\n               category.groups = category.groups.map(el => SpinalGraphService.getRealNode(el.id.get()));\n               return category\n            })\n         })\n      }\n\n      return []\n   }\n\n}","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NomenclatureProfil = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_env_viewer_plugin_group_manager_service_1 = require(\"spinal-env-viewer-plugin-group-manager-service\");\nclass NomenclatureProfil {\n    constructor() {\n        this.profileNodeType = \"AttributeConfiguration\";\n    }\n    /**\n     * This methods takes as params th context id, group id, profile name and list of categories. Creates and return the profile SpinalNode.\n     * @param contextId - ContextId - String\n     * @param groupId - GroupId - String\n     * @param profileName - profileName\n     * @param categories - Array of category : {show: boolean; name : string}\n     * @returns\n     */\n    createProfile(contextId, groupId, profileName, categories = []) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode({ name: profileName, type: this.profileNodeType }, new spinal_core_connectorjs_type_1.Model({\n                name: profileName,\n                categories\n            }));\n            yield spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.linkElementToGroup(contextId, groupId, id);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(id);\n        });\n    }\n    /**\n     * This methods updates the profile cateregories return false\n     * @param profileId - string profile node id\n     * @param profilElement - profil new Element IProfile\n     * @returns\n     */\n    updateProfile(profileId, newValues) {\n        let realNode = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(profileId);\n        if (realNode) {\n            if (newValues.name && newValues.name.trim().length > 0) {\n                realNode.info.name.set(newValues.name);\n            }\n            if (newValues.categories) {\n                return realNode.getElement().then((element) => {\n                    element.set(newValues.categories);\n                    return true;\n                }).catch(err => false);\n            }\n            return Promise.resolve(true);\n        }\n        return Promise.resolve(false);\n    }\n    /**\n     * This methods finds a profile (passed in parameter) or return all profiles in the contexte from the started node\n     * @param contextId - string - Context id\n     * @param startId  - string - start node id\n     * @param profileId - string - not required\n     * @returns\n     */\n    findOrGetProfiles(contextId, startId, profileId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!startId || startId.length === 0)\n                startId = contextId;\n            const profiles = yield spinal_env_viewer_graph_service_1.SpinalGraphService.findInContextByType(startId, contextId, this.profileNodeType);\n            if (profileId) {\n                const profile = profiles.filter(el => el.getId().get() === profileId);\n                if (profile) {\n                    return this._getProfileElement(profile);\n                }\n                return;\n            }\n            const promises = profiles.map(el => this._getProfileElement(el));\n            return Promise.all(promises);\n        });\n    }\n    /**\n     * This methods takes as parameters a contextId and profileId and set the profile as a current profile in the contexte\n     * @param contextId - string\n     * @param profileId - string\n     * @returns\n     */\n    setAsCurrentProfile(contextId, profileId) {\n        const profileNode = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(profileId);\n        const context = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(contextId);\n        if (profileNode && context) {\n            if (context.info.currentConfiguration) {\n                context.info.rem_attr(\"currentConfiguration\");\n            }\n            context.info.add_attr({\n                currentConfiguration: new spinal_core_connectorjs_type_1.Ptr(profileNode)\n            });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * This methods takes as parameter a contextId and returns the current profile in the Context\n     * @param contextId - string\n     * @returns\n     */\n    getCurrentProfile(contextId) {\n        const context = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(contextId);\n        const confPtr = context.info.currentConfiguration;\n        if (typeof confPtr !== \"undefined\") {\n            return new Promise((resolve, reject) => {\n                confPtr.load((realNode) => {\n                    spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(realNode);\n                    return realNode.getElement().then((el) => {\n                        let element = el.get();\n                        element.id = realNode.info.id.get();\n                        resolve(element);\n                    });\n                });\n            });\n        }\n    }\n    /**\n     * This methods takes as parameters a contextId and remove the current profile\n     * @param contextId - string\n     * @returns\n     */\n    deleteCurrentAsCurrentProfile(contextId) {\n        const context = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(contextId);\n        if (context && context.info.currentConfiguration) {\n            context.info.rem_attr(\"currentConfiguration\");\n            return true;\n        }\n        return false;\n    }\n    _getProfileElement(profileInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // (<any>SpinalGraphService)._addNode(profileNode);\n            const realNode = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(profileInfo.id.get());\n            const element = yield realNode.getElement();\n            const el = element.get();\n            el.id = realNode.getId().get();\n            return el;\n        });\n    }\n}\nexports.NomenclatureProfil = NomenclatureProfil;\n//# sourceMappingURL=Profil.js.map","import { Model, Ptr } from 'spinal-core-connectorjs_type';\nimport { SpinalGraphService, SpinalNode, SpinalNodeRef } from \"spinal-env-viewer-graph-service\";\nimport { groupManagerService } from \"spinal-env-viewer-plugin-group-manager-service\";\nimport { IAttribute } from '../interfaces/IAttribute';\nimport { IProfile } from '../interfaces/IProfile';\n\n\nexport class NomenclatureProfil {\n   public profileNodeType: string = \"AttributeConfiguration\";\n\n   constructor() {}\n\n   /**\n    * This methods takes as params th context id, group id, profile name and list of categories. Creates and return the profile SpinalNode.\n    * @param contextId - ContextId - String\n    * @param groupId - GroupId - String\n    * @param profileName - profileName\n    * @param categories - Array of category : {show: boolean; name : string}\n    * @returns \n    */\n   public async createProfile(contextId: string, groupId: string, profileName: string, categories: Array<IAttribute> = []) : Promise<SpinalNode<any>> {\n      \n      const id = SpinalGraphService.createNode({name : profileName, type : this.profileNodeType}, new Model({\n         name : profileName,\n         categories\n      }));\n\n      await groupManagerService.linkElementToGroup(contextId,groupId,id);\n\n      return SpinalGraphService.getRealNode(id);\n\n   }\n\n   /**\n    * This methods updates the profile cateregories return false\n    * @param profileId - string profile node id\n    * @param profilElement - profil new Element IProfile \n    * @returns \n    */\n   public updateProfile(profileId: string, newValues : {name?: string; categories? : Array<IAttribute>}) : Promise<boolean> {\n      let realNode = SpinalGraphService.getRealNode(profileId);\n   \n      if (realNode) {\n         if (newValues.name && newValues.name.trim().length > 0) {\n            realNode.info.name.set(newValues.name);\n         }\n\n         if(newValues.categories) {\n            return realNode.getElement().then((element) => {\n               element.set(newValues.categories);\n               return true;\n            }).catch(err => false)\n         }\n\n         return Promise.resolve(true);\n      }\n\n      return Promise.resolve(false);\n   }\n\n\n   /**\n    * This methods finds a profile (passed in parameter) or return all profiles in the contexte from the started node\n    * @param contextId - string - Context id\n    * @param startId  - string - start node id\n    * @param profileId - string - not required\n    * @returns \n    */\n   public async findOrGetProfiles(contextId: string,startId?: string ,profileId?: string): Promise<IProfile[]| IProfile> {\n      if(!startId || startId.length === 0) startId = contextId;\n\n      const profiles = await SpinalGraphService.findInContextByType(startId,contextId,this.profileNodeType);\n      if(profileId) {\n         const profile = profiles.filter(el => el.getId().get() === profileId);\n         if(profile) {\n            return this._getProfileElement(profile);\n         }\n\n         return\n      }\n\n      const promises = profiles.map(el => this._getProfileElement(el));\n\n      return Promise.all(promises);\n   }\n\n\n\n   /**\n    * This methods takes as parameters a contextId and profileId and set the profile as a current profile in the contexte\n    * @param contextId - string\n    * @param profileId - string\n    * @returns \n    */\n   public setAsCurrentProfile(contextId: string, profileId: string): boolean {\n      const profileNode = SpinalGraphService.getRealNode(profileId);\n      const context = SpinalGraphService.getRealNode(contextId);\n\n      if(profileNode && context) {\n         if(context.info.currentConfiguration) {\n            context.info.rem_attr(\"currentConfiguration\");\n         }\n\n         context.info.add_attr({\n            currentConfiguration: new Ptr(profileNode)\n         })\n\n         return true\n      }\n\n      return false;\n   }\n\n\n   /**\n    * This methods takes as parameter a contextId and returns the current profile in the Context\n    * @param contextId - string\n    * @returns \n    */\n   public getCurrentProfile(contextId : string) : Promise<{name: string; id: string; type: string;}> | void {\n      const context = SpinalGraphService.getRealNode(contextId);\n      const confPtr = context.info.currentConfiguration;\n      if(typeof confPtr !== \"undefined\") {\n         return new Promise((resolve, reject) => {\n            confPtr.load((realNode) => {\n               (<any>SpinalGraphService)._addNode(realNode);\n               return realNode.getElement().then((el) => {\n                  let element = el.get();\n                  element.id = realNode.info.id.get();\n                  resolve(element);\n               });\n             });\n         });\n      }\n   }\n\n   /**\n    * This methods takes as parameters a contextId and remove the current profile\n    * @param contextId - string\n    * @returns \n    */\n   public deleteCurrentAsCurrentProfile(contextId: string) : boolean {\n      const context = SpinalGraphService.getRealNode(contextId);\n      if(context && context.info.currentConfiguration) {\n         context.info.rem_attr(\"currentConfiguration\");\n         return true;\n      }\n\n      return false;\n   }\n   \n\n   public async _getProfileElement(profileInfo: SpinalNodeRef) {\n      // (<any>SpinalGraphService)._addNode(profileNode);\n      const realNode = SpinalGraphService.getRealNode(profileInfo.id.get());\n      const element = await realNode.getElement();\n      const el = element.get();\n      el.id = realNode.getId().get();\n\n      return el;\n   }\n\n}"],"names":[],"version":3,"file":"dist.f505aa71.js.map"}