{"mappings":"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,EAAjB;QACJ,OAAQ;YACJ,KAAK,+CAAA,OAAiB,CAAC,SAAS,CAAC,SAAS;gBACtC,OAAO,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,mBAAmB;YAEhE,KAAK,+CAAA,OAAiB,CAAC,SAAS,CAAC,cAAc;gBAC3C,OAAO,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,wBAAwB;YAErE,KAAK,0BAAA,iBAAiB,CAAC,YAAY;gBAC/B,OAAO,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,uBAAuB;QACxE;IACJ;IAGQ,aAAa,KAAwB,EAArC;QACJ,QAAQ,SAAS,kCAAA,kBAAkB,CAAC,QAAQ;QAC5C,YAAY;QACZ,kCAAA,kBAAkB,CAAC,QAAQ,CAAC;QAC5B,IAAI,UAAU,MAAM,KAAK,GAAG,GAAG;QAE/B,OAAO,kCAAA,kBAAkB,CAAC,WAAW,CAAC,SAAS,IAAI,CAAC,CAAA;YAChD,OAAO;QACX;IACJ;AAEH;AA1LD,QAAA,OAAA,GAAA;;;A;A,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,O,c,C,S,c;I,O;A;A,Q,0B,G,Q,uB,G,Q,gB,G,Q,uB,G,Q,sB,G,Q,iB,G,Q,gB,G,Q,e,G,Q,yB,G,Q,qB,G,Q,c,G,K;AE9CA;;;;;;;;;;;;;;;;;;;;;;CAsBG,GACH,MAAA,iCAAA,QAAA;AAEA,MAAA,oCAAA,QAAA;AAQA,MAAA,4BAAA,QAAA;AAkmBE,OAAA,cAAA,CAAA,SAAA,2BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OA/lBA,0BAAA,uBAAuB;IAAA;AAAA;AAgmBvB,OAAA,cAAA,CAAA,SAAA,oBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OA/lBA,0BAAA,gBAAgB;IAAA;AAAA;AAgmBhB,OAAA,cAAA,CAAA,SAAA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BAAA;;;A;AEtCA;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,O,c,C,S,c;I,O;A;A,Q,uB,G,K;AAEH,MAAA,oCAAA,QAAA;AAIA,MAAA,mDAAA,QAAA;AAEA,MAAA,qBAAA,QAAA;AACA,MAAA,2BAAA,QAAA;AACA,MAAA,oBAAA,QAAA;AAOA;;CAEG,GACH,MAAa;IAEX;;;KAGG,GACH,aAAA;QACE,IAAI,CAAC,qBAAqB,GAAG,IAAI;IACnC;IAEA;;;;;KAKG,GACU,iBACX,cAA0B,EAC1B,KAAuB,EAFZ;Q,O,U,I,E,K,G,K,G;YAIX,IAAI;gBACF,MAAM,aAAa,MAAM,IAAI,CAAC,qBAAqB,CAAC;gBACpD,IAAI,cAAc;gBAClB,IAAI,OAAO,UAAU,WACnB,cAAc,QAAQ,IAAI;gBAE5B,MAAM,WAAW,IAAI,CAAS;YAC/B,EAAC,OAAO,OAAO;gBACd,OAAO;YACR;YACD,OAAO;QACT;IAAC;IAED;;;;;;KAMG,GACU,mBACX,cAA0B,EAC1B,KAAuB,EACvB,IAA4B,EAHjB;Q,O,U,I,E,K,G,K,G;YAKX,IAAI;gBACF,MAAM,aAAa,MAAM,IAAI,CAAC,qBAAqB,CAAC;gBACpD,IAAI,cAAc;gBAClB,IAAI,OAAO,UAAU,WACnB,cAAc,QAAQ,IAAI;gBAE5B,MAAM,WAAW,MAAM,CAAS,aAAa;YAC9C,EAAC,OAAO,OAAO;gBACd,OAAO;YACR;YACD,OAAO;QACT;IAAC;IAED;;;;KAIG,GACU,cAAc,cAA0B,EAAxC;Q,O,U,I,E,K,G,K,G;YACX,IAAI,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,iBACjC,OAAO;YAET,MAAM,WAAW,MAAM,kCAAA,kBAAkB,CAAC,WAAW,CAAC,gBAAgB;gBACpE,mBAAA,gBAAgB,CAAC,YAAY;aAC9B;YACD,IAAI,SAAS,MAAM,KAAK,GACtB,OAAO;YAET,OAAO;QACT;IAAC;IAED;;;;KAIG,GACU,sBACX,cAA0B,EADf;Q,O,U,I,E,K,G,K,G;YAGX,IAAI,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,iBACjC,OAAO,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC;YAExC,MAAM,MAAM,MAAM,IAAI,CAAC,qBAAqB,CAAC;YAC7C,MAAM,UAAqC,IAAI,QAC7C,IAAI,CAAC,yBAAyB,CAAC,gBAAgB;YAEjD,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,gBAAgB;YAC/C,OAAO;QACT;IAAC;IACa,sBACZ,cAA0B,EADd;Q,O,U,I,E,K,G,K,G;YAGZ,IAAI;gBACF,MAAM,OAAO,kCAAA,kBAAkB,CAAC,WAAW,CAAC;gBAC5C,MAAM,MAAM,MAAM,iDAAA,gBAAgB,CAAC,iBAAiB,CAAC,MAAM;gBAE3D,MAAM,QACJ,MAAM,iDAAA,gBAAgB,CAAC,uBAAuB,CAAC,MAAM;gBACvD,IAAI,SAAiB;gBACrB,IAAI,mBAA2B;gBAC/B,KAAK,MAAM,QAAQ,MACjB,OAAQ,KAAK,KAAK,CAAC,GAAG;oBACpB,KAAK;wBACH,SAAS,SAAS,KAAK,KAAK,CAAC,GAAG,GAAG,QAAQ;wBAC3C;oBACF,KAAK;wBACH,mBAAmB,SAAS,KAAK,KAAK,CAAC,GAAG,GAAG,QAAQ;wBACrD;oBACF;wBACE;gBACH;gBAEH,SAAS,WAAW,OAAO,yBAAA,sBAAsB,CAAC,OAAO,GAAG;gBAC5D,mBACE,qBAAqB,OACjB,yBAAA,sBAAsB,CAAC,eAAe,GACtC;gBACN,EAAE;gBACF,MAAM,iDAAA,gBAAgB,CAAC,0BAA0B,CAC/C,MACA,WACA,qBACA,OAAO,QAAQ;gBAEjB,MAAM,iDAAA,gBAAgB,CAAC,0BAA0B,CAC/C,MACA,WACA,+BACA,iBAAiB,QAAQ;gBAG3B,OAAO;oBACL,QAAQ;oBACR,kBAAkB;gBACnB;YACF,EAAC,OAAO,GAAG;gBACV,OAAO;oBACL,QAAQ,yBAAA,sBAAsB,CAAC,OAAO;oBACtC,kBAAkB,yBAAA,sBAAsB,CAAC,eAAe;gBACzD;YACF;QACH;IAAC;IAEO,0BACN,cAAsB,EACtB,GAA0B,EAFpB;QAON,OAAO,CAAO,UAAd,UAAA,IAAA,EAAA,KAAA,GAAA,KAAA,GAAA;gBACE,MAAM,WAAW,MAAM,kCAAA,kBAAkB,CAAC,WAAW,CAAC,gBAAgB;oBACpE,mBAAA,gBAAgB,CAAC,YAAY;iBAC9B;gBACD,IAAI;gBACJ,IAAI,SAAS,MAAM,KAAK,GAAG;oBACzB,iBAAiB;oBACjB,MAAM,aAAa,IAAI,mBAAA,gBAAgB,CACrC,IAAI,gBAAgB,EACpB,IAAI,MAAM;oBAEZ,iBAAiB;oBACjB,cAAc;oBACd,MAAM,OAAO,kCAAA,kBAAkB,CAAC,UAAU,CACxC;wBAAE,cAAc,WAAW,EAAE,CAAC,GAAG;oBAAE,GACnC;oBAEF,sBAAsB;oBACtB,MAAM,kCAAA,kBAAkB,CAAC,QAAQ,CAC/B,gBACA,MACA,mBAAA,gBAAgB,CAAC,YAAY,EAC7B,kCAAA,4BAA4B;gBAE/B,OAAM;oBACL,MAAM,aAAa,MACjB,QAAQ,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI;oBAE1B,MAAM,WAAW,SAAS,CAAC,IAAI,gBAAgB,EAAE,IAAI,MAAM;oBAC3D,iBAAiB;gBAClB;gBACD,QAAQ;gBACR,OAAO;YACT;IACF;IAEA;;;;KAIG,GACI,WAAW,UAA4B,EAAvC;QACL,OAAO,WAAW,UAAU;IAC9B;IAEA;;;;KAIG,GACI,uBACL,UAA4B,EADvB;QAGL,OAAO,WAAW,sBAAsB;IAC1C;IAEA;;;;;KAKG,GACI,qBACL,UAA4B,EAC5B,gBAAwB,CAAC,EAFpB;QAIL,OAAO,WAAW,oBAAoB,CAAC;IACzC;IAEA;;;;KAIG,GACI,qBACL,UAA4B,EADvB;QAGL,OAAO,WAAW,oBAAoB;IACxC;IAEA;;;;;;KAMG,GACI,oBACL,UAA4B,EAC5B,QAAgC,CAAC,EACjC,MAA8B,KAAK,GAAG,EAAE,EAHnC;QAKL,OAAO,WAAW,mBAAmB,CAAC,OAAO;IAC/C;IAEA;;;;;;KAMG,GACI,uBACL,UAA4B,EAC5B,QAAgC,CAAC,EACjC,MAA8B,KAAK,GAAG,EAAE,EAHnC;QAKL,OAAO,WAAW,sBAAsB,CAAC,OAAO;IAClD;IAEA;;;;KAIG,GACG,cAAc,cAA0B,EAAxC;Q,O,U,I,E,K,G,K,G;YACJ,IAAI,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,iBACjC,OAAO,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC;YAExC,MAAM,WAAW,MAAM,kCAAA,kBAAkB,CAAC,WAAW,CAAC,gBAAgB;gBACpE,mBAAA,gBAAgB,CAAC,YAAY;aAC9B;YACD,IAAI,SAAS,MAAM,KAAK,GACtB,OAAO;YAET,MAAM,OAAkC,QAAQ,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI;YAChE,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,gBAAgB;YAC/C,OAAO;QACT;IAAC;IAED;;;;KAIG,GACI,qBACL,gBAAwB,CAAC,EADpB;QAGL,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,QAAQ,IAAI;QAClB,MAAM,WAAW,CAAC,MAAM,WAAW,KAAK;QACxC,OAAO;YAAE;YAAO;QAAG;IACrB;IAEA;;;;KAIG,GACI,oBAAoB,eAAuB,CAAC,EAA5C;QACL,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,QAAQ,IAAI;QAClB,MAAM,OAAO,CAAC,MAAM,OAAO,KAAK;QAChC,OAAO;YAAE;YAAO;QAAG;IACrB;IAEA;;;;;KAKG,GACU,QACX,cAA0B,EAC1B,sBAA8C,EAFnC;Q,O,U,I,E,K,G,K,G;YAIX,MAAM,aAAa,MAAM,IAAI,CAAC,aAAa,CAAC;YAC5C,IAAI,CAAC,YAAY,MAAM,IAAI,MAAM;YACjC,OAAO,AAAA,CAAA,GAAA,kBAAA,eAAe,AAAf,EACL,CAAA,MAAM,IAAI,CAAC,sBAAsB,CAC/B,YACA,uBAAuB,KAAK,EAC5B,uBAAuB,GAAG,CAAA;QAGhC;IAAC;IAED;;;;;KAKG,GACG,QACJ,cAA0B,EAC1B,sBAA8C,EAF1C;Q,O,U,I,E,K,G,K,G;YAIJ,MAAM,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,gBAAgB;YAChD,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO;YAC9B,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK;YAC3C,IAAI,MAAM;YACV,MAAM,WAAW,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,IAAI;YAC1D,IAAK,IAAI,MAAM,GAAG,KAAK,IAAI,CAAC,EAAE,EAAE,MAAM,KAAK,MAAM,EAAE,KAAK,IAAI,CAAC,MAAM,CACjE,2CAA2C;YAC3C,OACE,AAAG,CAAA,GAAG,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,AAAL,IAAS,IAAM,CAAA,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,GAAG,IAAI,AAAJ,IAC3D;YAEJ,OAAO;QACT;IAAC;IAED;;;;;KAKG,GACG,6BACJ,cAA0B,EAC1B,sBAA8C,EAF1C;Q,O,U,I,E,K,G,K,G;YAIJ,MAAM,iBAAiB,MAAM,IAAI,CAAC,OAAO,CACvC,gBACA;YAEF,mCAAmC;YACnC,MAAM,OAAO,eAAe,MAAM,CAAC,CAAC;gBAClC,OAAO,EAAE,KAAK,IAAI;YACpB;YAEA,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO;YAC9B,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK;YAC3C,IAAI,MAAM;YACV,MAAM,WAAW,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,IAAI;YAC1D,IAAK,IAAI,MAAM,GAAG,KAAK,IAAI,CAAC,EAAE,EAAE,MAAM,KAAK,MAAM,EAAE,KAAK,IAAI,CAAC,MAAM,CACjE,2CAA2C;YAC3C,OACE,AAAG,CAAA,GAAG,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,AAAL,IAAS,IAAM,CAAA,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,GAAG,IAAI,AAAJ,IAC3D;YAEJ,OAAO;QACT;IAAC;IACD;;;;;;KAMG,GACG,YACJ,cAA0B,EAC1B,sBAA8C,EAF1C;Q,O,U,I,E,K,G,K,G;YAIJ,MAAM,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,gBAAgB;YAChD,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO;YAC9B,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK;YAC3C,IAAI,MAAM;YACV,IAAK,IAAI,MAAM,GAAG,KAAK,IAAI,CAAC,EAAE,EAAE,MAAM,KAAK,MAAM,EAAE,KAAK,IAAI,CAAC,MAAM,CACjE,8BAA8B;YAC9B,OAAO,AAAE,CAAA,GAAG,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,AAAL,IAAS,IAAM,CAAA,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,GAAG,IAAI,AAAJ;YAEnE,OAAO;QACT;IAAC;IAED;;;;;KAKG,GACG,OACJ,cAA0B,EAC1B,sBAA8C,EAF1C;Q,O,U,I,E,K,G,K,G;YAIJ,MAAM,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,gBAAgB;YAChD,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO;YAC9B,OAAO,KAAK,MAAM,CAAC,CAAC,GAAG,IAAO,IAAI,EAAE,KAAK,GAAG,EAAE,KAAK,GAAG,GAAI,IAAI,CAAC,EAAE,CAAC,KAAK;QACzE;IAAC;IAED;;;;;KAKG,GACG,OACJ,cAA0B,EAC1B,sBAA8C,EAF1C;Q,O,U,I,E,K,G,K,G;YAIJ,MAAM,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,gBAAgB;YAChD,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO;YAC9B,OAAO,KAAK,MAAM,CAAC,CAAC,GAAG,IAAO,IAAI,EAAE,KAAK,GAAG,EAAE,KAAK,GAAG,GAAI,IAAI,CAAC,EAAE,CAAC,KAAK;QACzE;IAAC;IAED;;;;;KAKG,GACG,OACJ,cAA0B,EAC1B,sBAA8C,EAF1C;Q,O,U,I,E,K,G,K,G;YAIJ,MAAM,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,gBAAgB;YAChD,OAAO,KAAK,MAAM,CAAC,CAAC,GAAG,IAAM,IAAI,EAAE,KAAK,EAAE;QAC5C;IAAC;AACF;AApcD,QAAA,uBAAA,GAAA;;;A;AE1CA;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,kB,A,I,I,I,C,e,I,C,O,M,G,S,C,E,C,E,C,E,E;I,I,O,W,K;I,I,O,O,wB,C,G;I,I,C,Q,C,S,O,C,E,U,G,K,Q,I,K,Y,A,G,O;Q,Y;Q,K;Y,O,C,C,E;Q;I;I,O,c,C,G,I;A,I,S,C,E,C,E,C,E,E;I,I,O,W,K;I,C,C,G,G,C,C,E;A,C;A,I,e,A,I,I,I,C,Y,I,S,C,E,Q;I,I,I,K,E,I,M,a,C,O,S,C,c,C,I,C,U,I,gB,U,G;A;A,O,c,C,S,c;I,O;A;AAEH,MAAA,yBAAA,QAAA;AAEA,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,oBAAA;AACA,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;AAEA,QAAA,OAAA,GAAe,uBAAA,oBAAoB;;;;A;AElCnC;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;A,Q,oB,G,Q,oB,G,K;AAEH,MAAA,qBAAA,QAAA;AACA,MAAA,gBAAA,QAAA;AACA,MAAA,eAAA,QAAA;AAEA,aAAa;AACb,MAAM,aAAkB,OAAO,WAAW,cAAc,SAAS;AAEjE,SAAS,YAAY,kBAAuB,EAAE,gBAAuB;IACnE,iBAAiB,OAAO,CAAC,CAAC;QACxB,OAAO,mBAAmB,CAAC,gBAAgB,SAAS,EAAE,OAAO,CAAC,CAAC;YAC7D,OAAO,cAAc,CACnB,mBAAmB,SAAS,EAC5B,MACA,OAAO,wBAAwB,CAAC,gBAAgB,SAAS,EAAE;QAE/D;IACF;AACF;AAEA,MAAM;AAAuB;AAapB,QAAA,oBAAA,GAAA;AANT,YAAY,sBAAsB;IAAC,mBAAA,gBAAgB;IAAE,cAAA,WAAW;IAAE,aAAA,UAAU;CAAC;AAE7E,MAAM,uBAAuB,IAAI;AAIF,QAAA,oBAAA,GAAA;AAF/B,WAAW,MAAM,CAAC,uBAAuB,GAAG,sBAI5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CE;;;A;AEvGF;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,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CtB,QAAA,OAAA,GAAe;;;A;A,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,O,c,C,S,c;I,O;A;A,Q,Y,G,K;AEndf;;;;;;;;;;;;;;;;;;;;;;CAsBG,GACH,MAAA,iCAAA,QAAA;AAKA,MAAA,oCAAA,QAAA;AAIA,MAAA,gCAAA,QAAA;AAEA,MAAa;IACX;;;;;KAKG,GACI,OAAa,aAClB,YAA6B,EADxB;Q,O,U,I,E,K,G,K,G;YAGL,IAAI,gBAAgB,WAAW;gBAC7B,MAAM,WAAW,MAAM,aAAa,WAAW,CAAC;gBAChD,IAAI,SAAS,MAAM,IAAI,GACrB,OAAO;qBACF;oBACL,IAAI,YAAY,MAAM,QAAQ,CAAC,EAAE,CAAC,UAAU;oBAC5C,OAAO;gBACR;YACF;QACH;IAAC;IAED;;;;;KAKG,GACI,OAAa,cAClB,YAA6B,EADxB;Q,O,U,I,E,K,G,K,G;YAGL,MAAM,WAAW,MAAM,aAAa,WAAW,CAAC;YAChD,OAAO,SAAS,MAAM;QACxB;IAAC;IAEM,OAAa,gBAClB,YAA6B,EADxB;Q,O,U,I,E,K,G,K,G;YAGL,IAAI,SAAS,MAAM,IAAI,CAAC,aAAa,CAAC;YACtC,IAAI,UAAU,GAAG;gBACf,IAAI,cAAc,IAAI,+BAAA,SAAS;gBAC/B,IAAI,OAAO,MAAM,aAAa,QAAQ,CACpC,aACA,YACA,kCAAA,4BAA4B;gBAE9B,KAAK,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;gBACnB,KAAK,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;gBACnB,OAAO;YACR,OACC,OAAO,IAAI,CAAC,YAAY,CAAC;QAE7B;IAAC;IAED;;;;;KAKG,GACI,OAAO,aAAa,IAAU,EAA9B;QACL,MAAM,kBAAkB;YACtB;YACA;YACA;YACA;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U;YACrC,MAAM,WAAW,QAAQ,GAAG,CAAC,CAAO,SAApC,UAAA,IAAA,EAAA,KAAA,GAAA,KAAA,GAAA;oBACE,IAAI,QAAQ,MAAM,IAAI,CAAC,MAAM,CAAC;oBAC9B,QAAQ,MAAM,OAAO,CAAC,SAAS,QAAQ;wBAAC;qBAAM;oBAC9C,OAAO;wBACL,MAAM;wBACN,MAAM,MAAM,GAAG,CAAC,CAAC,KAAO,GAAG,OAAO;oBACnC;gBACH;YAEA,OAAO,QAAQ,GAAG,CAAC;QACrB;IAAC;IAED,kFAAkF;IAClF,kFAAkF;IAClF,kFAAkF;IAElF;;;;;KAKG,GACU,YAAY,OAAY,EAAE,OAAgB,EAA1C;Q,O,U,I,E,K,G,K,G;YACX,MAAM,UAAU,MAAM,QAAQ,UAAU;YACxC,OAAO;gBACL,SAAS;gBACT,MAAM;YACP;QACH;IAAC;AACF;AAIQ,QAAA,UAAA,GAAA;AAFT,MAAM,aAAa,IAAI;AAEF,QAAA,UAAA,GAAA;AACrB,QAAA,OAAA,GAAe;;;A;AEhNf;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,kB,A,I,I,I,C,e,I,C,O,M,G,S,C,E,C,E,C,E,E;I,I,O,W,K;I,I,O,O,wB,C,G;I,I,C,Q,C,S,O,C,E,U,G,K,Q,I,K,Y,A,G,O;Q,Y;Q,K;Y,O,C,C,E;Q;I;I,O,c,C,G,I;A,I,S,C,E,C,E,C,E,E;I,I,O,W,K;I,C,C,G,G,C,C,E;A,C;A,I,e,A,I,I,I,C,Y,I,S,C,E,Q;I,I,I,K,E,I,M,a,C,O,S,C,c,C,I,C,U,I,gB,U,G;A;A,O,c,C,S,c;I,O;A;AAEH,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;;;A;AE1BA;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;;;A;A,O,c,C,S,c;I,O;A;;;A;AItBH;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;;;A;A,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O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,IAAI,IAAI,CAAC,KAAK,EAAE;QAExC,OAAO;IACR;IAED,IAAI,OAAO,IAAI,IAAI,CAAC,KAAK,KAAK,eAAe,IAAI,IAAI,CAAC,KAAK,KAAK,GAC9D,OAAO,QAAQ,MAAM,CAAC;IAGxB,IAAI,OAAO,0BAAA,UAAU,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,aAAa;QAC9D,MAAM,MAAM,QAAQ,OAAO,CAAI,0BAAA,UAAU,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC;QAClE,kBAAkB,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE;QACtC,OAAO,QAAQ,OAAO,CAAC;IACxB;IACD,MAAM,MAAkB,IAAI,IAAI;IAChC,kBAAkB,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE;IACtC,OAAO;AACT;AA/BA,QAAA,OAAA,GAAA;;;A;A,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,I,U,A,I,I,I,C,O,I,S,C;I,O,I,Y,U,C,I,C,C,G,G,I,A,I,I,Q;A;A,I,mB,A,I,I,I,C,gB,I,S,O,E,U,E,S;I,I,C,O,a,E,M,I,U;I,I,I,U,K,C,S,c,E,G,G,I,E;I,O,I,C,G,K,S,K,U,K,W,C,C,O,a,C,G;Q,O,I;I,G;I,S,K,C;Q,I,C,C,E,E,C,C,E,G,S,C;Y,O,I,Q,S,C,E,C;gB,E,I,C;oB;oB;oB;oB;iB,I,K,O,G;Y;Q;I;I,S,O,C,E,C;Q,I;Y,K,C,C,E,C;Q,E,O,G;Y,O,C,C,E,C,E,E;Q;I;I,S,K,C;Q,E,K,Y,U,Q,O,C,E,K,C,C,E,I,C,S,U,O,C,C,E,C,E,E;I;I,S,Q,K;Q,O,Q;I;I,S,O,K;Q,O,S;I;I,S,O,C,E,C;Q,I,E,I,E,K,I,E,M,E,O,C,C,E,C,E,E,C,C,E,C,E;I;A;A,I,gB,A,I,I,I,C,a,I,S,C;I,I,C,O,a,E,M,I,U;I,I,I,C,C,O,a,C,E;I,O,I,E,I,C,K,C,I,O,a,a,S,K,C,C,O,Q,C,I,I,C,G,K,S,K,U,K,W,C,C,O,a,C,G;Q,O,I;I,G,C;I,S,K,C;Q,C,C,E,G,C,C,E,I,S,C;Y,O,I,Q,S,O,E,M;gB,I,C,C,E,C,I,O,S,Q,E,I,E,E,K;Y;Q;I;I,S,O,O,E,M,E,C,E,C;Q,Q,O,C,G,I,C,S,C;Y,Q;gB,O;gB,M;Y;Q,G;I;A;A,O,c,C,S,c;I,O;A;A,Q,uB,G,K;AEzBA;;;;;;;;;;;;;;;;;;;;;;CAsBG,GACH,MAAA,4BAAA,QAAA;AAOA,MAAA,YAAA,QAAA;AACA,MAAA,+BAAA,QAAA;AACA,MAAA,2BAAA,QAAA;AAGA;;;CAGG,GACH,MAAa,gCAAgC,0BAAA,KAAK;IAahD;;;;KAIG,GACH,YACE,mBAA2B,yBAAA,sBAAsB,CAAC,eAAe,CADnE;QAGE,KAAK,CAAC;YACJ;YACA,SAAS,EAAE;YACX,SAAS,EAAE;QACZ;QAED,IAAI,CAAC,oBAAoB,GAAG,IAAI;QAChC,IAAI,CAAC,iBAAiB,GAAG,IAAI;IAC/B;IAEA;;;;;KAKG,GACI,OAAO,cAAc,IAA4B,EAAjD;QACL,OAAO,IAAI,KAAK,MAAM,WAAW,CAAC,GAAG,GAAG,GAAG;IAC7C;IAEA;;;KAGG,GACI,kBAAA;QACL,IAAI,CAAC,eAAe;QACpB,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,OAAO,wBAAwB,aAAa,CAAC;QACnD,MAAM,6BAA6B,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC;QAEjE,IAAI,+BAA+B,WACjC,OAAO;QAGT,IAAK,IAAI,QAAQ,GAAG,QAAQ,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,SAAS,EAAG;YAC3D,MAAM,UAAU,IAAI,CAAC,OAAO,CAAC,MAAM;YACnC,MAAM,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM;YAC/B,IAAI,QAAQ,GAAG,OAAO,MACpB,OAAO,AAAA,CAAA,GAAA,UAAA,OAAO,AAAP,EAAQ,IAAI,CAAC,iBAAiB,EAAE;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AAC,OAAO,CAAC,MAAM,CAAC,GAAG;YAC7B,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG;QAChC;IACH;IAEA;;;KAGG,GACI,sBAAA;QACL,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM;IAC5B;IAEA;;;KAGG,GACK,sBAAA;QACN,IAAI,CAAC,wBAAwB;QAC7B,IAAK,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,KAAK,GAAG,MAAO;YACpE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;YAClB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;QACpB;IACH;IAEQ,2BAAA;QACN,IAAI,IAAI,CAAC,OAAO,YAAY,0BAAA,UAAU,EAAE;YACtC,MAAM,UAAU,IAAI,CAAC,OAAO;YAC5B,MAAM,WAAW,IAAI,CAAC,QAAQ;YAC9B,IAAI,CAAC,QAAQ,CAAC,WAAW,QAAQ,GAAG;YACpC,IAAI,CAAC,QAAQ,CAAC,YAAY,SAAS,GAAG;QACvC;IACH;AACD;AA5KD,QAAA,0BAAA,GAAA;AA8KA,0BAAA,UAAU,CAAC,eAAe,CAAC;;;A;AEzN3B;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;A,Q,sB,G,K;AAEU,QAAA,sBAAsB,GAAG;IACpC,SAAS;IACT,iBAAiB;AAClB;;;A;AE3BD;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,I,gB,A,I,I,I,C,a,I,S,C;I,I,C,O,a,E,M,I,U;I,I,I,C,C,O,a,C,E;I,O,I,E,I,C,K,C,I,O,a,a,S,K,C,C,O,Q,C,I,I,C,G,K,S,K,U,K,W,C,C,O,a,C,G;Q,O,I;I,G,C;I,S,K,C;Q,C,C,E,G,C,C,E,I,S,C;Y,O,I,Q,S,O,E,M;gB,I,C,C,E,C,I,O,S,Q,E,I,E,E,K;Y;Q;I;I,S,O,O,E,M,E,C,E,C;Q,Q,O,C,G,I,C,S,C;Y,Q;gB,O;gB,M;Y;Q,G;I;A;A,O,c,C,S,c;I,O;A;A,Q,e,G,K;AAEH;;;;CAIG,GAEH,SAAsB,gBACpB,EAA4B;I,I,I,M;I,I,I,K,I;I,O,U,I,E,K,G,K,G;QAE5B,MAAM,MAAW,EAAE;Q,I;YACnB,IAAA,KAAA,MAAsB,OAAA,cAAA,KAAtB,SAAA,MAAA,KAAA,IAAA,IAAA,KAAA,OAAA,IAAA,EAAA,CAAA,IAAA;gBAAsB,KAAA,OAAA,KAAA;gBAAA,KAAA;gB,I;oBAAX,MAAM,IAAC;oBAChB,IAAI,IAAI,CAAC;gB,S;oB,K;gB;YACV;Q,E,O,O;Y,M;gB,O;Y;Q,S;Y,I;gB,I,C,M,C,M,C,K,K,M,A,G,M,G,I,C;Y,S;gB,I,K,M,I,K;Y;Q;QACD,OAAO;I;AACR;AARD,QAAA,eAAA,GAAA;;;A;AE9BA;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;;;A;AEtBH;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;;;A;AEtBH;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;;;A;AEtBH;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;;;A;AEtBH;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;A,Q,yB,G,Q,qB,G,K;AAIH,MAAA,8BAAA,QAAA;AAQE,OAAA,cAAA,CAAA,SAAA,6BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OARO,4BAAA,yBAAyB;IAAA;AAAA;AAClC,MAAA,0BAAA,QAAA;AAME,OAAA,cAAA,CAAA,SAAA,yBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OANO,wBAAA,qBAAqB;IAAA;AAAA;;;A;AE3B9B;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,O,c,C,S,c;I,O;A;A,Q,yB,G,K;AAEH;;CAEG,GACH,IAAY;AAAZ,CAAA,SAAY,yBAAyB;IACnC,yBAAA,CA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","sources":["node_modules/spinal-env-viewer-plugin-group-manager-service/dist/index.js","node_modules/spinal-env-viewer-plugin-group-manager-service/src/index.ts","node_modules/spinal-env-viewer-plugin-group-manager-service/dist/classes/constants.js","node_modules/spinal-env-viewer-plugin-group-manager-service/src/classes/constants.ts","node_modules/spinal-env-viewer-plugin-group-manager-service/dist/classes/GroupManagerService.js","node_modules/spinal-env-viewer-plugin-group-manager-service/src/classes/GroupManagerService.ts","node_modules/spinal-model-bmsnetwork/dist/NetworkService.js","node_modules/spinal-model-bmsnetwork/src/NetworkService.ts","node_modules/spinal-model-timeseries/dist/index.js","node_modules/spinal-model-timeseries/src/index.ts","node_modules/spinal-model-timeseries/dist/timeseries/SpinalServiceTimeseries.js","node_modules/spinal-model-timeseries/src/timeseries/SpinalServiceTimeseries.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/index.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/index.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/Models/ServiceDocumentation.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/Models/ServiceDocumentation.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/Models/AttributeService.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/Models/AttributeService.ts","node_modules/spinal-models-documentation/dist/index.js","node_modules/spinal-models-documentation/src/index.ts","node_modules/spinal-models-documentation/dist/SpinalAttribute.js","node_modules/spinal-models-documentation/src/SpinalAttribute.ts","node_modules/spinal-models-documentation/dist/SpinalFile.js","node_modules/spinal-models-documentation/src/SpinalFile.ts","node_modules/spinal-models-documentation/dist/SpinalNote.js","node_modules/spinal-models-documentation/src/SpinalNote.ts","node_modules/spinal-models-documentation/dist/constants.js","node_modules/spinal-models-documentation/src/constants.ts","node_modules/spinal-models-documentation/dist/SpinalURL.js","node_modules/spinal-models-documentation/src/SpinalURL.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/Models/constants.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/Models/constants.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/Models/NoteService.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/Models/NoteService.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/Models/FileExplorer.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/Models/FileExplorer.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/Models/UrlService.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/Models/UrlService.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/interfaces/index.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/interfaces/index.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/interfaces/attributes/ICategory.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/interfaces/attributes/ICategory.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/interfaces/attributes/IUrl.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/interfaces/attributes/IUrl.ts","node_modules/spinal-env-viewer-plugin-documentation-service/dist/interfaces/notes/IFileNote.js","node_modules/spinal-env-viewer-plugin-documentation-service/src/interfaces/notes/IFileNote.ts","node_modules/spinal-model-timeseries/dist/timeseries/SpinalTimeSeries.js","node_modules/spinal-model-timeseries/src/timeseries/SpinalTimeSeries.ts","node_modules/spinal-model-timeseries/dist/utils/genUID.js","node_modules/spinal-model-timeseries/src/utils/genUID.ts","node_modules/spinal-model-timeseries/dist/utils/loadPtr.js","node_modules/spinal-model-timeseries/src/utils/loadPtr.ts","node_modules/spinal-model-timeseries/dist/timeseries/SpinalTimeSeriesArchive.js","node_modules/spinal-model-timeseries/src/timeseries/SpinalTimeSeriesArchive.ts","node_modules/spinal-model-timeseries/dist/timeseries/SpinalTimeSeriesArchiveDay.js","node_modules/spinal-model-timeseries/src/timeseries/SpinalTimeSeriesArchiveDay.ts","node_modules/spinal-model-timeseries/dist/SpinalTimeSeriesConfig.js","node_modules/spinal-model-timeseries/src/SpinalTimeSeriesConfig.ts","node_modules/spinal-model-timeseries/dist/utils/asyncGenToArray.js","node_modules/spinal-model-timeseries/src/utils/asyncGenToArray.ts","node_modules/spinal-model-timeseries/dist/interfaces/SpinalDateValueArray.js","node_modules/spinal-model-timeseries/src/interfaces/SpinalDateValueArray.ts","node_modules/spinal-model-timeseries/dist/interfaces/SpinalDateValue.js","node_modules/spinal-model-timeseries/src/interfaces/SpinalDateValue.ts","node_modules/spinal-model-timeseries/dist/interfaces/TimeSeriesEndpointCfg.js","node_modules/spinal-model-timeseries/src/interfaces/TimeSeriesEndpointCfg.ts","node_modules/spinal-model-timeseries/dist/interfaces/TimeSeriesIntervalDate.js","node_modules/spinal-model-timeseries/src/interfaces/TimeSeriesIntervalDate.ts","node_modules/spinal-model-bmsnetwork/dist/InputDataModel/InputDataModel.js","node_modules/spinal-model-bmsnetwork/src/InputDataModel/InputDataModel.ts","node_modules/spinal-model-bmsnetwork/dist/InputDataModel/InputDataEndpointDataType.js","node_modules/spinal-model-bmsnetwork/src/InputDataModel/InputDataEndpointDataType.ts","node_modules/spinal-model-bmsnetwork/dist/InputDataModel/InputDataEndpointType.js","node_modules/spinal-model-bmsnetwork/src/InputDataModel/InputDataEndpointType.ts","node_modules/spinal-model-bmsnetwork/dist/SpinalBms.js","node_modules/spinal-model-bmsnetwork/src/SpinalBms.ts","node_modules/spinal-model-bmsnetwork/dist/bms-network/SpinalBmsDevice.js","node_modules/spinal-model-bmsnetwork/src/bms-network/SpinalBmsDevice.ts","node_modules/spinal-model-bmsnetwork/dist/Utils/genUID.js","node_modules/spinal-model-bmsnetwork/src/Utils/genUID.ts","node_modules/spinal-model-bmsnetwork/dist/bms-network/SpinalBmsNetwork.js","node_modules/spinal-model-bmsnetwork/src/bms-network/SpinalBmsNetwork.ts","node_modules/spinal-model-bmsnetwork/dist/bms-network/SpinalBmsEndpoint.js","node_modules/spinal-model-bmsnetwork/src/bms-network/SpinalBmsEndpoint.ts","node_modules/spinal-model-bmsnetwork/dist/bms-network/SpinalBmsEndpointGroup.js","node_modules/spinal-model-bmsnetwork/src/bms-network/SpinalBmsEndpointGroup.ts","node_modules/lodash.throttle/index.js","node_modules/spinal-env-viewer-plugin-group-manager-service/dist/classes/SpinalGroup.js","node_modules/spinal-env-viewer-plugin-group-manager-service/src/classes/SpinalGroup.ts","node_modules/spinal-env-viewer-plugin-group-manager-service/dist/classes/SpinalCategory.js","node_modules/spinal-env-viewer-plugin-group-manager-service/src/classes/SpinalCategory.ts"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.constants = exports.spinalCategory = exports.spinalGroup = exports.groupManagerService = void 0;\nconst constants_1 = require(\"./classes/constants\");\nexports.constants = constants_1.default;\nconst GroupManagerService_1 = require(\"./classes/GroupManagerService\");\nObject.defineProperty(exports, \"spinalGroup\", { enumerable: true, get: function () { return GroupManagerService_1.spinalGroup; } });\nObject.defineProperty(exports, \"spinalCategory\", { enumerable: true, get: function () { return GroupManagerService_1.spinalCategory; } });\nlet groupManagerService = new GroupManagerService_1.default();\nexports.groupManagerService = groupManagerService;\nexports.default = groupManagerService;\n//# sourceMappingURL=index.js.map",null,"\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OLD_RELATIONS_TYPES = exports.OLD_GROUPS_TYPES = exports.OLD_CONTEXTS_TYPES = exports.ELEMENT_UNLINKED_TO_GROUP_EVENT = exports.ELEMENT_LINKED_TO_GROUP_EVENT = exports.GROUP_TYPE_END = exports.CONTEXTGROUP_TYPE_END = exports.GROUP_RELATION_BEGIN = exports.CATEGORY_TO_GROUP_RELATION = exports.CONTEXT_TO_CATEGORY_RELATION = exports.CATEGORY_TYPE = void 0;\n///////////////////////////////////////////\n//            NEW DATA TYPE              //\n///////////////////////////////////////////\nexports.CATEGORY_TYPE = \"groupingCategory\";\nexports.CONTEXT_TO_CATEGORY_RELATION = \"hasCategory\";\nexports.CATEGORY_TO_GROUP_RELATION = \"hasGroup\";\nexports.GROUP_RELATION_BEGIN = \"groupHas\";\nexports.CONTEXTGROUP_TYPE_END = \"GroupContext\";\nexports.GROUP_TYPE_END = \"Group\";\n///////////////////////////////////////////\n//            EVENT TYPE                 //\n///////////////////////////////////////////\nexports.ELEMENT_LINKED_TO_GROUP_EVENT = \"elementLinked\";\nexports.ELEMENT_UNLINKED_TO_GROUP_EVENT = \"elementUnLinked\";\n///////////////////////////////////////////\n//            OLD DATA TYPE              //\n///////////////////////////////////////////\nexports.OLD_CONTEXTS_TYPES = Object.freeze({\n    ROOMS_GROUP_CONTEXT: \"RoomsGroupContext\",\n    EQUIPMENTS_GROUP_CONTEXT: \"EquipmentGroupContext\",\n    ENDPOINTS_GROUP_CONTEXT: \"EndpointGroupContext\"\n});\nexports.OLD_GROUPS_TYPES = Object.freeze({\n    ROOMS_GROUP: \"roomsGroup\",\n    EQUIPMENTS_GROUP: \"equipmentGroup\",\n    ENDPOINT_GROUP: \"endpointGroup\"\n});\nexports.OLD_RELATIONS_TYPES = Object.freeze({\n    GROUP_TO_ROOMS_RELATION: \"groupHasRooms\",\n    GROUP_TO_EQUIPMENTS_RELATION: \"groupHasEquipments\",\n    GROUP_TO_ENDPOINT_RELATION: \"groupHasEndpoints\"\n});\n///////////////////////////////////////////\n//            EXPORT ALL                 //\n///////////////////////////////////////////\nexports.default = {\n    CATEGORY_TYPE: exports.CATEGORY_TYPE,\n    CONTEXT_TO_CATEGORY_RELATION: exports.CONTEXT_TO_CATEGORY_RELATION,\n    CATEGORY_TO_GROUP_RELATION: exports.CATEGORY_TO_GROUP_RELATION,\n    OLD_CONTEXTS_TYPES: exports.OLD_CONTEXTS_TYPES,\n    OLD_GROUPS_TYPES: exports.OLD_GROUPS_TYPES,\n    OLD_RELATIONS_TYPES: exports.OLD_RELATIONS_TYPES,\n    ELEMENT_LINKED_TO_GROUP_EVENT: exports.ELEMENT_LINKED_TO_GROUP_EVENT,\n    ELEMENT_UNLINKED_TO_GROUP_EVENT: exports.ELEMENT_UNLINKED_TO_GROUP_EVENT,\n    GROUP_RELATION_BEGIN: exports.GROUP_RELATION_BEGIN\n};\n//# sourceMappingURL=constants.js.map",null,"\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.spinalCategory = exports.spinalGroup = void 0;\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst spinal_env_viewer_context_geographic_service_1 = require(\"spinal-env-viewer-context-geographic-service\");\nconst spinal_model_bmsnetwork_1 = require(\"spinal-model-bmsnetwork\");\nconst SpinalGroup_1 = require(\"./SpinalGroup\");\nconst SpinalCategory_1 = require(\"./SpinalCategory\");\nconst constants_1 = require(\"./constants\");\nconst spinal_env_viewer_plugin_event_emitter_1 = require(\"spinal-env-viewer-plugin-event-emitter\");\nexports.spinalGroup = new SpinalGroup_1.default();\n;\nexports.spinalCategory = new SpinalCategory_1.default();\n;\nclass GroupManagerService {\n    constructor() {\n        this.constants = constants_1.default;\n    }\n    createGroupContext(contextName, childrenType, graph) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const contexts = yield this._getContexts(graph);\n            let contextFound = contexts.find(context => context.name.get() === contextName);\n            if (typeof contextFound !== \"undefined\")\n                return Promise.resolve(spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(contextFound.id.get()));\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.addContext(contextName, `${childrenType}${constants_1.CONTEXTGROUP_TYPE_END}`, new spinal_core_connectorjs_type_1.Model({\n                name: contextName,\n                childType: childrenType\n            }));\n        });\n    }\n    getGroupContexts(childType, graph) {\n        graph = graph || spinal_env_viewer_graph_service_1.SpinalGraphService.getGraph();\n        //@ts-ignore\n        spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(graph);\n        let graphId = graph.getId().get();\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(graphId).then(contextsModel => {\n            let contexts = contextsModel.map(el => el.get());\n            let allGroupContexts = contexts.filter(el => {\n                return el.type.includes(constants_1.CONTEXTGROUP_TYPE_END);\n            });\n            if (typeof childType === \"undefined\")\n                return allGroupContexts;\n            const oldType = this._getOldTypes(childType);\n            return allGroupContexts.filter(el => {\n                return el.type.includes(childType) || el.type === oldType;\n            });\n        });\n    }\n    addCategory(contextId, categoryName, iconName) {\n        return exports.spinalCategory.addCategory(contextId, categoryName, iconName);\n    }\n    getCategories(nodeId) {\n        return exports.spinalCategory.getCategories(nodeId);\n    }\n    addGroup(contextId, categoryId, groupName, groupColor, groupIcon) {\n        return exports.spinalGroup.addGroup(contextId, categoryId, groupName, groupColor, groupIcon);\n    }\n    getGroups(nodeId) {\n        return exports.spinalGroup.getGroups(nodeId);\n    }\n    linkElementToGroup(contextId, groupId, elementId) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const category = yield this.getGroupCategory(groupId);\n            const group = yield this.elementIsInCategorie(category.id.get(), elementId);\n            const result = { old_group: (_a = group === null || group === void 0 ? void 0 : group.id) === null || _a === void 0 ? void 0 : _a.get(), newGroup: groupId };\n            if (result.old_group === result.newGroup)\n                return result;\n            if (typeof group !== \"undefined\") {\n                yield this.unLinkElementToGroup(group.id.get(), elementId);\n                result.old_group = group.id.get();\n            }\n            yield exports.spinalGroup.linkElementToGroup(contextId, groupId, elementId);\n            spinal_env_viewer_plugin_event_emitter_1.spinalEventEmitter.emit(constants_1.ELEMENT_LINKED_TO_GROUP_EVENT, { groupId, elementId });\n            return result;\n        });\n    }\n    elementIsLinkedToGroup(groupId, elementId) {\n        return exports.spinalGroup.elementIsLinkedToGroup(groupId, elementId);\n    }\n    elementIsInCategorie(categoryId, elementId) {\n        return exports.spinalCategory.elementIsInCategorie(categoryId, elementId);\n    }\n    unLinkElementToGroup(groupId, elementId) {\n        return exports.spinalGroup.unLinkElementToGroup(groupId, elementId).then((result) => {\n            spinal_env_viewer_plugin_event_emitter_1.spinalEventEmitter.emit(constants_1.ELEMENT_UNLINKED_TO_GROUP_EVENT, { groupId, elementId });\n            return result;\n        });\n    }\n    getElementsLinkedToGroup(groupId) {\n        return exports.spinalGroup.getElementsLinkedToGroup(groupId);\n    }\n    getGroupCategory(groupId) {\n        return exports.spinalGroup.getCategory(groupId);\n    }\n    isContext(type) {\n        return exports.spinalCategory._isContext(type);\n    }\n    isRoomGroupContext(type) {\n        return type == `${spinal_env_viewer_context_geographic_service_1.default.constants.ROOM_TYPE}${constants_1.CONTEXTGROUP_TYPE_END}` || constants_1.OLD_CONTEXTS_TYPES.ROOMS_GROUP_CONTEXT == type;\n    }\n    isEquipmentGroupContext(type) {\n        return type == `${spinal_env_viewer_context_geographic_service_1.default.constants.EQUIPMENT_TYPE}${constants_1.CONTEXTGROUP_TYPE_END}` || constants_1.OLD_CONTEXTS_TYPES.EQUIPMENTS_GROUP_CONTEXT == type;\n    }\n    isCategory(type) {\n        return exports.spinalCategory._isCategory(type);\n    }\n    isGroup(type) {\n        return exports.spinalGroup._isGroup(type);\n    }\n    isRoomsGroup(type) {\n        return type == `${spinal_env_viewer_context_geographic_service_1.default.constants.ROOM_TYPE}${constants_1.GROUP_TYPE_END}` || constants_1.OLD_CONTEXTS_TYPES.ROOMS_GROUP_CONTEXT.replace(\"Context\", \"\") == type || type === constants_1.OLD_GROUPS_TYPES.ROOMS_GROUP;\n    }\n    isEquipementGroup(type) {\n        return type == `${spinal_env_viewer_context_geographic_service_1.default.constants.EQUIPMENT_TYPE}${constants_1.GROUP_TYPE_END}` || constants_1.OLD_CONTEXTS_TYPES.EQUIPMENTS_GROUP_CONTEXT.replace(\"Context\", \"\") == type || type === constants_1.OLD_GROUPS_TYPES.EQUIPMENTS_GROUP;\n    }\n    checkGroupType(groupType, childrenType) {\n        return `${childrenType}${constants_1.GROUP_TYPE_END}` === groupType;\n    }\n    checkContextType(contextType, childrenType) {\n        return `${childrenType}${constants_1.CONTEXTGROUP_TYPE_END}` === contextType;\n    }\n    updateCategory(categoryId, newInfo) {\n        return exports.spinalCategory.updateCategory(categoryId, newInfo);\n    }\n    updateGroup(categoryId, newInfo) {\n        return exports.spinalGroup.updateGroup(categoryId, newInfo);\n    }\n    getChildrenType(type) {\n        if (this.isContext(type))\n            return type.replace(constants_1.CONTEXTGROUP_TYPE_END, \"\");\n        if (this.isGroup(type))\n            return type.replace(constants_1.GROUP_TYPE_END, \"\");\n    }\n    ////////////////////////////////////////////////////////////////////\n    //                      PRIVATES                                  //\n    ////////////////////////////////////////////////////////////////////\n    _getOldTypes(type) {\n        switch (type) {\n            case spinal_env_viewer_context_geographic_service_1.default.constants.ROOM_TYPE:\n                return this.constants.OLD_CONTEXTS_TYPES.ROOMS_GROUP_CONTEXT;\n            case spinal_env_viewer_context_geographic_service_1.default.constants.EQUIPMENT_TYPE:\n                return this.constants.OLD_CONTEXTS_TYPES.EQUIPMENTS_GROUP_CONTEXT;\n            case spinal_model_bmsnetwork_1.SpinalBmsEndpoint.nodeTypeName:\n                return this.constants.OLD_CONTEXTS_TYPES.ENDPOINTS_GROUP_CONTEXT;\n        }\n    }\n    _getContexts(graph) {\n        graph = graph || spinal_env_viewer_graph_service_1.SpinalGraphService.getGraph();\n        //@ts-ignore\n        spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(graph);\n        let graphId = graph.getId().get();\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(graphId).then(contextsModel => {\n            return contextsModel;\n        });\n    }\n}\nexports.default = GroupManagerService;\n//# sourceMappingURL=GroupManagerService.js.map",null,"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalTimeSeriesArchiveDay = exports.SpinalTimeSeriesArchive = exports.SpinalTimeSeries = exports.SpinalServiceTimeseries = exports.SpinalBmsEndpointGroup = exports.SpinalBmsEndpoint = exports.SpinalBmsNetwork = exports.SpinalBmsDevice = exports.InputDataEndpointDataType = exports.InputDataEndpointType = exports.NetworkService = void 0;\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_model_timeseries_1 = require(\"spinal-model-timeseries\");\nObject.defineProperty(exports, \"SpinalServiceTimeseries\", { enumerable: true, get: function () { return spinal_model_timeseries_1.SpinalServiceTimeseries; } });\nObject.defineProperty(exports, \"SpinalTimeSeries\", { enumerable: true, get: function () { return spinal_model_timeseries_1.SpinalTimeSeries; } });\nObject.defineProperty(exports, \"SpinalTimeSeriesArchive\", { enumerable: true, get: function () { return spinal_model_timeseries_1.SpinalTimeSeriesArchive; } });\nObject.defineProperty(exports, \"SpinalTimeSeriesArchiveDay\", { enumerable: true, get: function () { return spinal_model_timeseries_1.SpinalTimeSeriesArchiveDay; } });\nconst InputDataModel_1 = require(\"./InputDataModel/InputDataModel\");\nObject.defineProperty(exports, \"InputDataEndpointDataType\", { enumerable: true, get: function () { return InputDataModel_1.InputDataEndpointDataType; } });\nObject.defineProperty(exports, \"InputDataEndpointType\", { enumerable: true, get: function () { return InputDataModel_1.InputDataEndpointType; } });\nconst SpinalBms_1 = require(\"./SpinalBms\");\nObject.defineProperty(exports, \"SpinalBmsDevice\", { enumerable: true, get: function () { return SpinalBms_1.SpinalBmsDevice; } });\nObject.defineProperty(exports, \"SpinalBmsEndpoint\", { enumerable: true, get: function () { return SpinalBms_1.SpinalBmsEndpoint; } });\nObject.defineProperty(exports, \"SpinalBmsEndpointGroup\", { enumerable: true, get: function () { return SpinalBms_1.SpinalBmsEndpointGroup; } });\nObject.defineProperty(exports, \"SpinalBmsNetwork\", { enumerable: true, get: function () { return SpinalBms_1.SpinalBmsNetwork; } });\nconst spinal_env_viewer_plugin_documentation_service_1 = require(\"spinal-env-viewer-plugin-documentation-service\");\nconst throttle = require('lodash.throttle');\n/**\n * @export\n * @class NetworkService\n */\nclass NetworkService {\n    /**\n     *Creates an instance of NetworkService.\n     * @memberof NetworkService\n     */\n    constructor(useTimeseries = true) {\n        this.spinalServiceTimeseries = new spinal_model_timeseries_1.SpinalServiceTimeseries();\n        this.useTimeseries = useTimeseries;\n        this.useDelay = 0;\n    }\n    setupDelay(timeout) {\n        this.useDelay = timeout;\n    }\n    /**\n     * @param {spinal.Model} forgeFile\n     * @param {ConfigService} configService\n     * @param {boolean} [autoCreate=true]\n     * @returns {Promise<{contextId:string, networkId: string}>}\n     * @memberof NetworkService\n     */\n    init(forgeFile, configService, autoCreate = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield spinal_env_viewer_graph_service_1.SpinalGraphService.setGraph(forgeFile);\n            this.context = spinal_env_viewer_graph_service_1.SpinalGraphService.getContext(configService.contextName);\n            if (this.context === undefined) {\n                if (autoCreate === true) {\n                    this.context = yield spinal_env_viewer_graph_service_1.SpinalGraphService.addContext(configService.contextName, configService.contextType, new spinal_core_connectorjs_type_1.Model());\n                }\n                else {\n                    throw Error(`Context named \"${configService.contextName}\" is not found in the graph.`);\n                }\n            }\n            this.contextId = this.context.getId().get();\n            const childrenContext = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildrenInContext(this.contextId, this.contextId);\n            let childFoundId = '';\n            for (const childContext of childrenContext) {\n                if (typeof childContext.networkName !== 'undefined' &&\n                    childContext.networkName.get() === configService.networkName) {\n                    childFoundId = childContext.id.get();\n                    break;\n                }\n            }\n            if (childFoundId === '') {\n                childFoundId = yield this\n                    .createNewBmsNetwork(this.contextId, configService.networkType, configService.networkName)\n                    .then(res => res.id.get());\n            }\n            this.networkId = childFoundId;\n            return { contextId: this.contextId, networkId: childFoundId };\n        });\n    }\n    /**\n     * @param {string} parentId\n     * @param {string} typeName\n     * @param {string} networkName\n     * @returns {Promise<any>}\n     * @memberof NetworkService\n     */\n    createNewBmsNetwork(parentId, typeName, networkName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = new SpinalBms_1.SpinalBmsNetwork(networkName, typeName);\n            const tmpInfo = {\n                networkName,\n                typeName,\n                type: SpinalBms_1.SpinalBmsNetwork.nodeTypeName,\n                name: networkName,\n                idNetwork: res.id.get(),\n            };\n            const childId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(tmpInfo, res);\n            yield spinal_env_viewer_graph_service_1.SpinalGraphService.addChildInContext(parentId, childId, this.contextId, SpinalBms_1.SpinalBmsNetwork.relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(childId);\n        });\n    }\n    /**\n     * @param {string} parentId\n     * @param {InputDataDevice} obj\n     * @returns {Promise<any>}\n     * @memberof NetworkService\n     */\n    createNewBmsDevice(parentId, obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = new SpinalBms_1.SpinalBmsDevice(obj.name, obj.type, obj.path, obj.id);\n            const tmpInfo = {\n                type: SpinalBms_1.SpinalBmsDevice.nodeTypeName,\n                name: obj.name,\n                idNetwork: obj.id,\n            };\n            const childId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(tmpInfo, res);\n            yield spinal_env_viewer_graph_service_1.SpinalGraphService.addChildInContext(parentId, childId, this.contextId, SpinalBms_1.SpinalBmsDevice.relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            yield this._createAttributes(childId, res);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(childId);\n        });\n    }\n    /**\n     * @param {string} parentId\n     * @param {InputDataEndpointGroup} obj\n     * @returns {Promise<any>}\n     * @memberof NetworkService\n     */\n    createNewBmsEndpointGroup(parentId, obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = new SpinalBms_1.SpinalBmsEndpointGroup(obj.name, obj.type, obj.path, obj.id);\n            const tmpInfo = {\n                type: SpinalBms_1.SpinalBmsEndpointGroup.nodeTypeName,\n                name: obj.name,\n                idNetwork: obj.id,\n            };\n            const childId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(tmpInfo, res);\n            yield spinal_env_viewer_graph_service_1.SpinalGraphService.addChildInContext(parentId, childId, this.contextId, SpinalBms_1.SpinalBmsEndpointGroup.relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            yield this._createAttributes(childId, res);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(childId);\n        });\n    }\n    /**\n     * @param {string} parentId\n     * @param {InputDataEndpoint} obj\n     * @returns {Promise<any>}\n     * @memberof NetworkService\n     */\n    createNewBmsEndpoint(parentId, obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = new SpinalBms_1.SpinalBmsEndpoint(obj.name, obj.path, obj.currentValue, obj.unit, InputDataModel_1.InputDataEndpointDataType[obj.dataType], InputDataModel_1.InputDataEndpointType[obj.type], obj.id);\n            const tmpInfo = {\n                type: SpinalBms_1.SpinalBmsEndpoint.nodeTypeName,\n                name: obj.name,\n                idNetwork: obj.id,\n            };\n            const childId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(tmpInfo, res);\n            yield spinal_env_viewer_graph_service_1.SpinalGraphService.addChildInContext(parentId, childId, this.contextId, SpinalBms_1.SpinalBmsEndpoint.relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            yield this._createAttributes(childId, res);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(childId);\n        });\n    }\n    createNewBmsEndpointWithoutContext(parentId, obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = new SpinalBms_1.SpinalBmsEndpoint(obj.name, obj.path, obj.currentValue, obj.unit, InputDataModel_1.InputDataEndpointDataType[obj.dataType], InputDataModel_1.InputDataEndpointType[obj.type], obj.id);\n            const tmpInfo = {\n                type: SpinalBms_1.SpinalBmsEndpoint.nodeTypeName,\n                name: obj.name,\n                idNetwork: obj.id,\n            };\n            const childId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(tmpInfo, res);\n            yield spinal_env_viewer_graph_service_1.SpinalGraphService.addChild(parentId, childId, SpinalBms_1.SpinalBmsEndpoint.relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            yield this._createAttributes(childId, res);\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(childId);\n        });\n    }\n    /**\n     * @param {InputDataDevice} obj\n     * @param {*} [date=null]\n     * @returns {Promise<void>}\n     * @memberof NetworkService\n     */\n    updateData(obj, date = null) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const contextChildren = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildrenInContext(this.networkId, this.contextId);\n            for (const child of contextChildren) {\n                if (typeof child.idNetwork !== 'undefined' &&\n                    child.idNetwork.get() === obj.id) {\n                    return this.updateModel(child, obj, date);\n                }\n            }\n            return this.createNewBmsDevice(this.networkId, obj).then((child) => {\n                return this.updateModel(child, obj, date);\n            });\n        });\n    }\n    /**\n     * @private\n     * @param {*} node\n     * @param {(InputDataDevice|InputDataEndpointGroup)} reference\n     * @param {*} [date=null]\n     * @returns {Promise<void>}\n     * @memberof NetworkService\n     */\n    updateModel(node, reference, date = null) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const contextChildren = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildrenInContext(node.id.get(), this.contextId);\n            const notPresent = [];\n            const promises = [];\n            for (const refChild of reference.children) {\n                let childFound = false;\n                for (const child of contextChildren) {\n                    if (child.idNetwork.get() === refChild.id) {\n                        switch (child.type.get()) {\n                            case SpinalBms_1.SpinalBmsDevice.nodeTypeName:\n                                promises.push(this.updateModel(child, refChild, date));\n                                childFound = true;\n                                break;\n                            case SpinalBms_1.SpinalBmsEndpointGroup.nodeTypeName:\n                                promises.push(this.updateModel(child, refChild, date));\n                                childFound = true;\n                                break;\n                            case SpinalBms_1.SpinalBmsEndpoint.nodeTypeName:\n                                promises.push(this.updateEndpoint(child, refChild, date));\n                                childFound = true;\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                }\n                if (!childFound) {\n                    notPresent.push(refChild);\n                }\n            }\n            let prom;\n            for (const item of notPresent) {\n                switch (item.nodeTypeName) {\n                    case SpinalBms_1.SpinalBmsDevice.nodeTypeName:\n                        prom = this.createNewBmsDevice(node.id.get(), (item))\n                            .then((child) => {\n                            return this.updateModel(child, item, date);\n                        });\n                        promises.push(prom);\n                        break;\n                    case SpinalBms_1.SpinalBmsEndpointGroup.nodeTypeName:\n                        prom = this.createNewBmsEndpointGroup(node.id.get(), item)\n                            .then((child) => {\n                            return this.updateModel(child, item, date);\n                        });\n                        promises.push(prom);\n                        break;\n                    case SpinalBms_1.SpinalBmsEndpoint.nodeTypeName:\n                        prom =\n                            this.createNewBmsEndpoint(node.id.get(), (item))\n                                .then((child) => {\n                                return this.updateEndpoint(child, item, date);\n                            });\n                        promises.push(prom);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            yield Promise.all(promises);\n        });\n    }\n    /**\n     * @param {*} node\n     * @param {InputDataEndpoint} reference\n     * @param {*} [date=null]\n     * @returns {Promise<void>}\n     * @memberof NetworkService\n     */\n    updateEndpoint(node, reference, date = null) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const element = yield node.element.load();\n            // await this._createAttributes(node.id.get(), element);\n            element.currentValue.set(reference.currentValue);\n            if (typeof reference.currentValue === 'number' ||\n                typeof reference.currentValue === 'boolean') {\n                yield this.setEndpointValue(node.id.get(), reference.currentValue, date);\n            }\n        });\n    }\n    /**\n     * @returns {Promise<string[]>}\n     * @memberof NetworkService\n     */\n    getNetworks() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const childrenContext = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildrenInContext(this.contextId, this.contextId);\n            return childrenContext.map(element => element.id.get());\n        });\n    }\n    /**\n     * @private\n     * @param {string} idElement\n     * @param {string[]} relationNames\n     * @returns {Promise<string[]>}\n     * @memberof NetworkService\n     */\n    find(idElement, relationNames, nodeTypeName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const node = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(idElement);\n            const childrenContext = yield node.find(relationNames, (node) => {\n                if (node.getType().get() === nodeTypeName) {\n                    return true;\n                }\n                return false;\n            });\n            return childrenContext.map((element) => {\n                // hack, call private method while 'find' is not in service\n                const graphs = spinal_env_viewer_graph_service_1.SpinalGraphService;\n                graphs._addNode(element);\n                return element.getId().get();\n            });\n        });\n    }\n    /**\n     * @param {string} idDevice\n     * @returns {Promise<string[]>}\n     * @memberof NetworkService\n     */\n    getEndpoint(idDevice) {\n        const relationNames = [\n            SpinalBms_1.SpinalBmsEndpointGroup.relationName,\n            SpinalBms_1.SpinalBmsEndpoint.relationName,\n        ];\n        return this.find(idDevice, relationNames, SpinalBms_1.SpinalBmsEndpoint.nodeTypeName);\n    }\n    getDevices(idNetwork) {\n        const relationNames = [\n            SpinalBms_1.SpinalBmsDevice.relationName,\n            SpinalBms_1.SpinalBmsEndpointGroup.relationName,\n            SpinalBms_1.SpinalBmsEndpoint.relationName,\n        ];\n        return this.find(idNetwork, relationNames, SpinalBms_1.SpinalBmsDevice.nodeTypeName);\n    }\n    /**\n     * @param {string} idNode\n     * @returns {spinal.Model}\n     * @memberof NetworkService\n     */\n    getInfo(idNode) {\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(idNode);\n    }\n    /**\n     * @param {string} idNode\n     * @returns {Promise<spinal.Model>}\n     * @memberof NetworkService\n     */\n    getData(idNode) {\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(idNode).element.load();\n    }\n    /**\n     * @param {string} idEndpoint\n     * @returns {Promise<SpinalTimeSeries>}\n     * @memberof NetworkService\n     */\n    getTimeseries(idEndpoint) {\n        return this.spinalServiceTimeseries.getOrCreateTimeSeries(idEndpoint);\n    }\n    getTimeseriesProm(endpoint) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const timeseriesLst = yield endpoint.getChildren([spinal_model_timeseries_1.SpinalTimeSeries.relationName]);\n            if (timeseriesLst.length === 0)\n                return;\n            return timeseriesLst[0];\n        });\n    }\n    /**\n     * @param {string} idEndpoint\n     * @param {(string|boolean|number)} value\n     * @param {(number|string|Date)} [date=null]\n     * @returns {Promise<void>}\n     * @memberof NetworkService\n     */\n    setEndpointValue(idEndpoint, value, date = null) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const node = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(idEndpoint);\n            const element = (yield node.element.load());\n            element.currentValue.set(value);\n            if (this.useTimeseries === true && (typeof value === 'number' || typeof value === 'boolean')) {\n                if (this.useDelay === 0) {\n                    return pushData(this.spinalServiceTimeseries, idEndpoint, (element.currentValue), date);\n                }\n                if (dicEnd.has(idEndpoint)) {\n                    const fct = dicEnd.get(idEndpoint);\n                    fct(this.spinalServiceTimeseries, idEndpoint, element.currentValue, date);\n                }\n                else {\n                    const fct = throttle(pushData, 3 * 60 * 1000);\n                    dicEnd.set(idEndpoint, fct);\n                    fct(this.spinalServiceTimeseries, idEndpoint, element.currentValue, date);\n                }\n                // if (date === null) {\n                //   return this.spinalServiceTimeseries.pushFromEndpoint(idEndpoint, value);\n                // }\n                // return this.spinalServiceTimeseries.insertFromEndpoint(\n                //     idEndpoint,\n                //     value,\n                //     new Date(date),\n                // );\n            }\n        });\n    }\n    linkControlEndpointToEndPoint(controlEndPoint, endPoint) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // @ts-ignore\n            spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(endPoint);\n            const [endpointTimeseries, endPointElement, controlEndPointTimeseries, controlEndPointElement, controlEndPointCatAttr] = yield Promise.all([\n                this.getTimeseriesProm(endPoint),\n                endPoint.element.load(),\n                this.getTimeseriesProm(controlEndPoint).catch(() => undefined),\n                controlEndPoint.element.load(),\n                spinal_env_viewer_plugin_documentation_service_1.serviceDocumentation.getCategoryByName(controlEndPoint, 'default')\n            ]);\n            if (controlEndPointTimeseries) {\n                yield controlEndPoint.removeChild(controlEndPointTimeseries, spinal_model_timeseries_1.SpinalTimeSeries.relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            }\n            const endPointDataModel = endPointElement.currentValue;\n            controlEndPointElement.mod_attr(\"currentValue\", endPointDataModel);\n            const [attrs] = yield Promise.all([\n                spinal_env_viewer_plugin_documentation_service_1.serviceDocumentation.getAttributesByCategory(controlEndPoint, controlEndPointCatAttr),\n                controlEndPoint.addChild(endpointTimeseries, spinal_model_timeseries_1.SpinalTimeSeries.relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE),\n            ]);\n            for (const attr of attrs) {\n                if (attr.label.get() === \"currentValue\") {\n                    attr.mod_attr(\"value\", endPointDataModel);\n                    return;\n                }\n            }\n        });\n    }\n    _createAttributes(nodeId, elementModel) {\n        const categoryName = \"default\";\n        const realNode = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(nodeId);\n        return spinal_env_viewer_plugin_documentation_service_1.serviceDocumentation.addCategoryAttribute(realNode, categoryName).then((attributeCategory) => {\n            const promises = [];\n            for (const key of elementModel._attribute_names) {\n                promises.push(spinal_env_viewer_plugin_documentation_service_1.serviceDocumentation.addAttributeByCategory(realNode, attributeCategory, key, elementModel[key]));\n            }\n            return Promise.all(promises);\n        }).catch((err) => {\n        });\n    }\n}\nexports.NetworkService = NetworkService;\nconst dicEnd = new Map();\nfunction pushData(spinalServiceTimeseries, idEndpoint, value, date) {\n    if (date === null) {\n        return spinalServiceTimeseries.pushFromEndpoint(idEndpoint, value.get());\n    }\n    return spinalServiceTimeseries.insertFromEndpoint(idEndpoint, value.get(), new Date(date));\n}\nexports.default = NetworkService;\n//# sourceMappingURL=NetworkService.js.map",null,"\"use strict\";\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SpinalServiceTimeseries_1 = require(\"./timeseries/SpinalServiceTimeseries\");\nexports.default = SpinalServiceTimeseries_1.SpinalServiceTimeseries;\n__exportStar(require(\"./interfaces/SpinalDateValueArray\"), exports);\n__exportStar(require(\"./interfaces/SpinalDateValue\"), exports);\n__exportStar(require(\"./interfaces/TimeSeriesEndpointCfg\"), exports);\n__exportStar(require(\"./interfaces/TimeSeriesIntervalDate\"), exports);\n__exportStar(require(\"./timeseries/SpinalServiceTimeseries\"), exports);\n__exportStar(require(\"./timeseries/SpinalTimeSeriesArchiveDay\"), exports);\n__exportStar(require(\"./timeseries/SpinalTimeSeriesArchive\"), exports);\n__exportStar(require(\"./timeseries/SpinalTimeSeries\"), exports);\n__exportStar(require(\"./SpinalTimeSeriesConfig\"), exports);\n__exportStar(require(\"./utils/asyncGenToArray\"), exports);\n//# sourceMappingURL=index.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { SpinalServiceTimeseries } from './timeseries/SpinalServiceTimeseries';\n\nexport default SpinalServiceTimeseries;\nexport * from './interfaces/SpinalDateValueArray';\nexport * from './interfaces/SpinalDateValue';\nexport * from './interfaces/TimeSeriesEndpointCfg';\nexport * from './interfaces/TimeSeriesIntervalDate';\n\nexport * from './timeseries/SpinalServiceTimeseries';\nexport * from './timeseries/SpinalTimeSeriesArchiveDay';\nexport * from './timeseries/SpinalTimeSeriesArchive';\nexport * from './timeseries/SpinalTimeSeries';\nexport * from './SpinalTimeSeriesConfig';\n\nexport * from './utils/asyncGenToArray';\n","\"use strict\";\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalServiceTimeseries = void 0;\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_env_viewer_plugin_documentation_service_1 = require(\"spinal-env-viewer-plugin-documentation-service\");\nconst SpinalTimeSeries_1 = require(\"./SpinalTimeSeries\");\nconst SpinalTimeSeriesConfig_1 = require(\"../SpinalTimeSeriesConfig\");\nconst asyncGenToArray_1 = require(\"../utils/asyncGenToArray\");\n/**\n * @class SpinalServiceTimeseries\n */\nclass SpinalServiceTimeseries {\n    /**\n     *Creates an instance of SpinalServiceTimeseries.\n     * @memberof SpinalServiceTimeseries\n     */\n    constructor() {\n        this.timeSeriesDictionnary = new Map();\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @param {(number|boolean)} value\n     * @returns {Promise<boolean>}\n     * @memberof SpinalServiceTimeseries\n     */\n    pushFromEndpoint(endpointNodeId, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const timeseries = yield this.getOrCreateTimeSeries(endpointNodeId);\n                let valueToPush = value;\n                if (typeof value === 'boolean') {\n                    valueToPush = value ? 1 : 0;\n                }\n                yield timeseries.push(valueToPush);\n            }\n            catch (error) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @param {(number|boolean)} value\n     * @param {(number|string|Date)} date\n     * @returns {Promise<boolean>}\n     * @memberof SpinalServiceTimeseries\n     */\n    insertFromEndpoint(endpointNodeId, value, date) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const timeseries = yield this.getOrCreateTimeSeries(endpointNodeId);\n                let valueToPush = value;\n                if (typeof value === 'boolean') {\n                    valueToPush = value ? 1 : 0;\n                }\n                yield timeseries.insert(valueToPush, date);\n            }\n            catch (error) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @returns {Promise<boolean>}\n     * @memberof SpinalServiceTimeseries\n     */\n    hasTimeSeries(endpointNodeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.timeSeriesDictionnary.has(endpointNodeId)) {\n                return true;\n            }\n            const children = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(endpointNodeId, [\n                SpinalTimeSeries_1.SpinalTimeSeries.relationName,\n            ]);\n            if (children.length === 0) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @returns {Promise<SpinalTimeSeries>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getOrCreateTimeSeries(endpointNodeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.timeSeriesDictionnary.has(endpointNodeId)) {\n                return this.timeSeriesDictionnary.get(endpointNodeId);\n            }\n            const cfg = yield this.getConfigFormEndpoint(endpointNodeId);\n            const promise = new Promise(this.getOrCreateTimeSeriesProm(endpointNodeId, cfg));\n            this.timeSeriesDictionnary.set(endpointNodeId, promise);\n            return promise;\n        });\n    }\n    getConfigFormEndpoint(endpointNodeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const node = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(endpointNodeId);\n                const cat = yield spinal_env_viewer_plugin_documentation_service_1.attributeService.getCategoryByName(node, 'default');\n                const attrs = yield spinal_env_viewer_plugin_documentation_service_1.attributeService.getAttributesByCategory(node, cat);\n                let maxDay = null;\n                let initialBlockSize = null;\n                for (const attr of attrs) {\n                    switch (attr.label.get()) {\n                        case 'timeSeries maxDay':\n                            maxDay = parseInt(attr.value.get().toString());\n                            break;\n                        case 'timeSeries initialBlockSize':\n                            initialBlockSize = parseInt(attr.value.get().toString());\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                maxDay = maxDay === null ? SpinalTimeSeriesConfig_1.SpinalTimeSeriesConfig.MAX_DAY : maxDay;\n                initialBlockSize =\n                    initialBlockSize === null\n                        ? SpinalTimeSeriesConfig_1.SpinalTimeSeriesConfig.INIT_BLOCK_SIZE\n                        : initialBlockSize;\n                //\n                yield spinal_env_viewer_plugin_documentation_service_1.attributeService.addAttributeByCategoryName(node, 'default', 'timeSeries maxDay', maxDay.toString());\n                yield spinal_env_viewer_plugin_documentation_service_1.attributeService.addAttributeByCategoryName(node, 'default', 'timeSeries initialBlockSize', initialBlockSize.toString());\n                return {\n                    maxDay: maxDay,\n                    initialBlockSize: initialBlockSize,\n                };\n            }\n            catch (e) {\n                return {\n                    maxDay: SpinalTimeSeriesConfig_1.SpinalTimeSeriesConfig.MAX_DAY,\n                    initialBlockSize: SpinalTimeSeriesConfig_1.SpinalTimeSeriesConfig.INIT_BLOCK_SIZE,\n                };\n            }\n        });\n    }\n    getOrCreateTimeSeriesProm(endpointNodeId, cfg) {\n        return (resolve) => __awaiter(this, void 0, void 0, function* () {\n            const children = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(endpointNodeId, [\n                SpinalTimeSeries_1.SpinalTimeSeries.relationName,\n            ]);\n            let timeSeriesProm;\n            if (children.length === 0) {\n                // create element\n                const timeSeries = new SpinalTimeSeries_1.SpinalTimeSeries(cfg.initialBlockSize, cfg.maxDay);\n                timeSeriesProm = timeSeries;\n                // create node\n                const node = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode({ timeSeriesId: timeSeries.id.get() }, timeSeries);\n                // push node to parent\n                yield spinal_env_viewer_graph_service_1.SpinalGraphService.addChild(endpointNodeId, node, SpinalTimeSeries_1.SpinalTimeSeries.relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            }\n            else {\n                const timeSeries = yield (children[0].element.load());\n                yield timeSeries.setConfig(cfg.initialBlockSize, cfg.maxDay);\n                timeSeriesProm = timeSeries;\n            }\n            resolve(timeSeriesProm);\n            return timeSeriesProm;\n        });\n    }\n    /**\n     * @param {SpinalTimeSeries} timeseries\n     * @return {Promise<SpinalDateValue>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getCurrent(timeseries) {\n        return timeseries.getCurrent();\n    }\n    /**\n     * @param {SpinalTimeSeries} timeseries\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getDataFromLast24Hours(timeseries) {\n        return timeseries.getDataFromLast24Hours();\n    }\n    /**\n     * @param {SpinalTimeSeries} timeseries\n     * @param {number} [numberOfHours=1]\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getDataFromLastHours(timeseries, numberOfHours = 1) {\n        return timeseries.getDataFromLastHours(numberOfHours);\n    }\n    /**\n     * @param {SpinalTimeSeries} timeseries\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getDataFromYesterday(timeseries) {\n        return timeseries.getDataFromYesterday();\n    }\n    /**\n     * @param {SpinalTimeSeries} timeseries\n     * @param {(string|number|Date)} [start=0]\n     * @param {(string|number|Date)} [end=Date.now()]\n     * @returns {Promise<SpinalDateValue[]>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getFromIntervalTime(timeseries, start = 0, end = Date.now()) {\n        return timeseries.getFromIntervalTime(start, end);\n    }\n    /**\n     * @param {SpinalTimeSeries} timeseries\n     * @param {(string|number|Date)} [start=0]\n     * @param {(string|number|Date)} [end=Date.now()]\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getFromIntervalTimeGen(timeseries, start = 0, end = Date.now()) {\n        return timeseries.getFromIntervalTimeGen(start, end);\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @return {Promise<SpinalTimeSeries>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getTimeSeries(endpointNodeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.timeSeriesDictionnary.has(endpointNodeId)) {\n                return this.timeSeriesDictionnary.get(endpointNodeId);\n            }\n            const children = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(endpointNodeId, [\n                SpinalTimeSeries_1.SpinalTimeSeries.relationName,\n            ]);\n            if (children.length === 0) {\n                return undefined;\n            }\n            const prom = children[0].element.load();\n            this.timeSeriesDictionnary.set(endpointNodeId, prom);\n            return prom;\n        });\n    }\n    /**\n     * @param {number} [numberOfHours=1]\n     * @return {TimeSeriesIntervalDate}\n     * @memberof SpinalServiceTimeseries\n     */\n    getDateFromLastHours(numberOfHours = 1) {\n        const end = Date.now();\n        const start = new Date();\n        start.setUTCHours(start.getUTCHours() - numberOfHours);\n        return { start, end };\n    }\n    /**\n     * @param {number} [numberOfDays=1]\n     * @return {TimeSeriesIntervalDate}\n     * @memberof SpinalServiceTimeseries\n     */\n    getDateFromLastDays(numberOfDays = 1) {\n        const end = Date.now();\n        const start = new Date();\n        start.setDate(start.getDate() - numberOfDays);\n        return { start, end };\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n     * @return {Promise<SpinalDateValue[]>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getData(endpointNodeId, timeSeriesIntervalDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const timeSeries = yield this.getTimeSeries(endpointNodeId);\n            if (!timeSeries)\n                throw new Error('endpoint have no timeseries');\n            return (0, asyncGenToArray_1.asyncGenToArray)(yield this.getFromIntervalTimeGen(timeSeries, timeSeriesIntervalDate.start, timeSeriesIntervalDate.end));\n        });\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n     * @return {Promise<number>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getMean(endpointNodeId, timeSeriesIntervalDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.getData(endpointNodeId, timeSeriesIntervalDate);\n            if (data.length === 0)\n                return NaN;\n            if (data.length === 1)\n                return data[0].value;\n            let res = 0;\n            const fullTime = data[data.length - 1].date - data[0].date;\n            for (let idx = 1, d1 = data[0]; idx < data.length; d1 = data[idx++]) {\n                // (((d1 + d2) / 2) * (t2 - t1)) / fulltime\n                res +=\n                    (((d1.value + data[idx].value) / 2) * (data[idx].date - d1.date)) /\n                        fullTime;\n            }\n            return res;\n        });\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n     * @return {Promise<number>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getMeanWithoutNegativeValues(endpointNodeId, timeSeriesIntervalDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const dataNotFiltred = yield this.getData(endpointNodeId, timeSeriesIntervalDate);\n            //exclude negative values from data\n            const data = dataNotFiltred.filter((x) => {\n                return x.value >= 0;\n            });\n            if (data.length === 0)\n                return NaN;\n            if (data.length === 1)\n                return data[0].value;\n            let res = 0;\n            const fullTime = data[data.length - 1].date - data[0].date;\n            for (let idx = 1, d1 = data[0]; idx < data.length; d1 = data[idx++]) {\n                // (((d1 + d2) / 2) * (t2 - t1)) / fulltime\n                res +=\n                    (((d1.value + data[idx].value) / 2) * (data[idx].date - d1.date)) /\n                        fullTime;\n            }\n            return res;\n        });\n    }\n    /**\n     * getIntegral | time in ms\n     * @param {EndpointId} endpointNodeId\n     * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n     * @return {Promise<number>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getIntegral(endpointNodeId, timeSeriesIntervalDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.getData(endpointNodeId, timeSeriesIntervalDate);\n            if (data.length === 0)\n                return NaN;\n            if (data.length === 1)\n                return data[0].value;\n            let res = 0;\n            for (let idx = 1, d1 = data[0]; idx < data.length; d1 = data[idx++]) {\n                // ((d1 + d2) / 2) * (t2 - t1)\n                res += ((d1.value + data[idx].value) / 2) * (data[idx].date - d1.date);\n            }\n            return res;\n        });\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n     * @return  {Promise<number>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getMax(endpointNodeId, timeSeriesIntervalDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.getData(endpointNodeId, timeSeriesIntervalDate);\n            if (data.length === 0)\n                return 0;\n            return data.reduce((a, b) => (a < b.value ? b.value : a), data[0].value);\n        });\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n     * @return {Promise<number>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getMin(endpointNodeId, timeSeriesIntervalDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.getData(endpointNodeId, timeSeriesIntervalDate);\n            if (data.length === 0)\n                return 0;\n            return data.reduce((a, b) => (a > b.value ? b.value : a), data[0].value);\n        });\n    }\n    /**\n     * @param {EndpointId} endpointNodeId\n     * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n     * @return {Promise<number>}\n     * @memberof SpinalServiceTimeseries\n     */\n    getSum(endpointNodeId, timeSeriesIntervalDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.getData(endpointNodeId, timeSeriesIntervalDate);\n            return data.reduce((a, b) => a + b.value, 0);\n        });\n    }\n}\nexports.SpinalServiceTimeseries = SpinalServiceTimeseries;\n//# sourceMappingURL=SpinalServiceTimeseries.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport {\n  SpinalGraphService,\n  SPINAL_RELATION_PTR_LST_TYPE,\n} from 'spinal-env-viewer-graph-service';\nimport { attributeService } from 'spinal-env-viewer-plugin-documentation-service';\nimport { SpinalAttribute } from 'spinal-models-documentation';\nimport { SpinalTimeSeries } from './SpinalTimeSeries';\nimport { SpinalTimeSeriesConfig } from '../SpinalTimeSeriesConfig';\nimport { asyncGenToArray } from '../utils/asyncGenToArray';\nimport type { TimeSeriesEndpointCfg } from '../interfaces/TimeSeriesEndpointCfg';\nimport type { TimeSeriesIntervalDate } from '../interfaces/TimeSeriesIntervalDate';\nimport type { SpinalDateValue } from '../interfaces/SpinalDateValue';\n\ntype EndpointId = string;\n\n/**\n * @class SpinalServiceTimeseries\n */\nexport class SpinalServiceTimeseries {\n  private timeSeriesDictionnary: Map<EndpointId, Promise<SpinalTimeSeries>>;\n  /**\n   *Creates an instance of SpinalServiceTimeseries.\n   * @memberof SpinalServiceTimeseries\n   */\n  constructor() {\n    this.timeSeriesDictionnary = new Map();\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @param {(number|boolean)} value\n   * @returns {Promise<boolean>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public async pushFromEndpoint(\n    endpointNodeId: EndpointId,\n    value: number | boolean\n  ): Promise<boolean> {\n    try {\n      const timeseries = await this.getOrCreateTimeSeries(endpointNodeId);\n      let valueToPush = value;\n      if (typeof value === 'boolean') {\n        valueToPush = value ? 1 : 0;\n      }\n      await timeseries.push(<number>valueToPush);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @param {(number|boolean)} value\n   * @param {(number|string|Date)} date\n   * @returns {Promise<boolean>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public async insertFromEndpoint(\n    endpointNodeId: EndpointId,\n    value: number | boolean,\n    date: number | string | Date\n  ): Promise<boolean> {\n    try {\n      const timeseries = await this.getOrCreateTimeSeries(endpointNodeId);\n      let valueToPush = value;\n      if (typeof value === 'boolean') {\n        valueToPush = value ? 1 : 0;\n      }\n      await timeseries.insert(<number>valueToPush, date);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @returns {Promise<boolean>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public async hasTimeSeries(endpointNodeId: EndpointId): Promise<boolean> {\n    if (this.timeSeriesDictionnary.has(endpointNodeId)) {\n      return true;\n    }\n    const children = await SpinalGraphService.getChildren(endpointNodeId, [\n      SpinalTimeSeries.relationName,\n    ]);\n    if (children.length === 0) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @returns {Promise<SpinalTimeSeries>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public async getOrCreateTimeSeries(\n    endpointNodeId: EndpointId\n  ): Promise<SpinalTimeSeries> {\n    if (this.timeSeriesDictionnary.has(endpointNodeId)) {\n      return this.timeSeriesDictionnary.get(endpointNodeId);\n    }\n    const cfg = await this.getConfigFormEndpoint(endpointNodeId);\n    const promise: Promise<SpinalTimeSeries> = new Promise(\n      this.getOrCreateTimeSeriesProm(endpointNodeId, cfg)\n    );\n    this.timeSeriesDictionnary.set(endpointNodeId, promise);\n    return promise;\n  }\n  private async getConfigFormEndpoint(\n    endpointNodeId: EndpointId\n  ): Promise<TimeSeriesEndpointCfg> {\n    try {\n      const node = SpinalGraphService.getRealNode(endpointNodeId);\n      const cat = await attributeService.getCategoryByName(node, 'default');\n\n      const attrs: SpinalAttribute[] =\n        await attributeService.getAttributesByCategory(node, cat);\n      let maxDay: number = null;\n      let initialBlockSize: number = null;\n      for (const attr of attrs) {\n        switch (attr.label.get()) {\n          case 'timeSeries maxDay':\n            maxDay = parseInt(attr.value.get().toString());\n            break;\n          case 'timeSeries initialBlockSize':\n            initialBlockSize = parseInt(attr.value.get().toString());\n            break;\n          default:\n            break;\n        }\n      }\n      maxDay = maxDay === null ? SpinalTimeSeriesConfig.MAX_DAY : maxDay;\n      initialBlockSize =\n        initialBlockSize === null\n          ? SpinalTimeSeriesConfig.INIT_BLOCK_SIZE\n          : initialBlockSize;\n      //\n      await attributeService.addAttributeByCategoryName(\n        node,\n        'default',\n        'timeSeries maxDay',\n        maxDay.toString()\n      );\n      await attributeService.addAttributeByCategoryName(\n        node,\n        'default',\n        'timeSeries initialBlockSize',\n        initialBlockSize.toString()\n      );\n\n      return {\n        maxDay: maxDay,\n        initialBlockSize: initialBlockSize,\n      };\n    } catch (e) {\n      return {\n        maxDay: SpinalTimeSeriesConfig.MAX_DAY,\n        initialBlockSize: SpinalTimeSeriesConfig.INIT_BLOCK_SIZE,\n      };\n    }\n  }\n\n  private getOrCreateTimeSeriesProm(\n    endpointNodeId: string,\n    cfg: TimeSeriesEndpointCfg\n  ): (\n    resolve: (value: SpinalTimeSeries | PromiseLike<SpinalTimeSeries>) => void,\n    reject: (reason?: any) => void\n  ) => void {\n    return async (resolve) => {\n      const children = await SpinalGraphService.getChildren(endpointNodeId, [\n        SpinalTimeSeries.relationName,\n      ]);\n      let timeSeriesProm: SpinalTimeSeries | PromiseLike<SpinalTimeSeries>;\n      if (children.length === 0) {\n        // create element\n        const timeSeries = new SpinalTimeSeries(\n          cfg.initialBlockSize,\n          cfg.maxDay\n        );\n        timeSeriesProm = timeSeries;\n        // create node\n        const node = SpinalGraphService.createNode(\n          { timeSeriesId: timeSeries.id.get() },\n          timeSeries\n        );\n        // push node to parent\n        await SpinalGraphService.addChild(\n          endpointNodeId,\n          node,\n          SpinalTimeSeries.relationName,\n          SPINAL_RELATION_PTR_LST_TYPE\n        );\n      } else {\n        const timeSeries = await (<Promise<SpinalTimeSeries>>(\n          children[0].element.load()\n        ));\n        await timeSeries.setConfig(cfg.initialBlockSize, cfg.maxDay);\n        timeSeriesProm = timeSeries;\n      }\n      resolve(timeSeriesProm);\n      return timeSeriesProm;\n    };\n  }\n\n  /**\n   * @param {SpinalTimeSeries} timeseries\n   * @return {Promise<SpinalDateValue>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public getCurrent(timeseries: SpinalTimeSeries): Promise<SpinalDateValue> {\n    return timeseries.getCurrent();\n  }\n\n  /**\n   * @param {SpinalTimeSeries} timeseries\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public getDataFromLast24Hours(\n    timeseries: SpinalTimeSeries\n  ): Promise<AsyncIterableIterator<SpinalDateValue>> {\n    return timeseries.getDataFromLast24Hours();\n  }\n\n  /**\n   * @param {SpinalTimeSeries} timeseries\n   * @param {number} [numberOfHours=1]\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public getDataFromLastHours(\n    timeseries: SpinalTimeSeries,\n    numberOfHours: number = 1\n  ): Promise<AsyncIterableIterator<SpinalDateValue>> {\n    return timeseries.getDataFromLastHours(numberOfHours);\n  }\n\n  /**\n   * @param {SpinalTimeSeries} timeseries\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public getDataFromYesterday(\n    timeseries: SpinalTimeSeries\n  ): Promise<AsyncIterableIterator<SpinalDateValue>> {\n    return timeseries.getDataFromYesterday();\n  }\n\n  /**\n   * @param {SpinalTimeSeries} timeseries\n   * @param {(string|number|Date)} [start=0]\n   * @param {(string|number|Date)} [end=Date.now()]\n   * @returns {Promise<SpinalDateValue[]>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public getFromIntervalTime(\n    timeseries: SpinalTimeSeries,\n    start: string | number | Date = 0,\n    end: string | number | Date = Date.now()\n  ): Promise<SpinalDateValue[]> {\n    return timeseries.getFromIntervalTime(start, end);\n  }\n\n  /**\n   * @param {SpinalTimeSeries} timeseries\n   * @param {(string|number|Date)} [start=0]\n   * @param {(string|number|Date)} [end=Date.now()]\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public getFromIntervalTimeGen(\n    timeseries: SpinalTimeSeries,\n    start: string | number | Date = 0,\n    end: string | number | Date = Date.now()\n  ): Promise<AsyncIterableIterator<SpinalDateValue>> {\n    return timeseries.getFromIntervalTimeGen(start, end);\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @return {Promise<SpinalTimeSeries>}\n   * @memberof SpinalServiceTimeseries\n   */\n  async getTimeSeries(endpointNodeId: EndpointId): Promise<SpinalTimeSeries> {\n    if (this.timeSeriesDictionnary.has(endpointNodeId)) {\n      return this.timeSeriesDictionnary.get(endpointNodeId);\n    }\n    const children = await SpinalGraphService.getChildren(endpointNodeId, [\n      SpinalTimeSeries.relationName,\n    ]);\n    if (children.length === 0) {\n      return undefined;\n    }\n    const prom = <Promise<SpinalTimeSeries>>children[0].element.load();\n    this.timeSeriesDictionnary.set(endpointNodeId, prom);\n    return prom;\n  }\n\n  /**\n   * @param {number} [numberOfHours=1]\n   * @return {TimeSeriesIntervalDate}\n   * @memberof SpinalServiceTimeseries\n   */\n  public getDateFromLastHours(\n    numberOfHours: number = 1\n  ): TimeSeriesIntervalDate {\n    const end = Date.now();\n    const start = new Date();\n    start.setUTCHours(start.getUTCHours() - numberOfHours);\n    return { start, end };\n  }\n\n  /**\n   * @param {number} [numberOfDays=1]\n   * @return {TimeSeriesIntervalDate}\n   * @memberof SpinalServiceTimeseries\n   */\n  public getDateFromLastDays(numberOfDays: number = 1): TimeSeriesIntervalDate {\n    const end = Date.now();\n    const start = new Date();\n    start.setDate(start.getDate() - numberOfDays);\n    return { start, end };\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n   * @return {Promise<SpinalDateValue[]>}\n   * @memberof SpinalServiceTimeseries\n   */\n  public async getData(\n    endpointNodeId: EndpointId,\n    timeSeriesIntervalDate: TimeSeriesIntervalDate\n  ): Promise<SpinalDateValue[]> {\n    const timeSeries = await this.getTimeSeries(endpointNodeId);\n    if (!timeSeries) throw new Error('endpoint have no timeseries');\n    return asyncGenToArray<SpinalDateValue>(\n      await this.getFromIntervalTimeGen(\n        timeSeries,\n        timeSeriesIntervalDate.start,\n        timeSeriesIntervalDate.end\n      )\n    );\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n   * @return {Promise<number>}\n   * @memberof SpinalServiceTimeseries\n   */\n  async getMean(\n    endpointNodeId: EndpointId,\n    timeSeriesIntervalDate: TimeSeriesIntervalDate\n  ): Promise<number> {\n    const data = await this.getData(endpointNodeId, timeSeriesIntervalDate);\n    if (data.length === 0) return NaN;\n    if (data.length === 1) return data[0].value;\n    let res = 0;\n    const fullTime = data[data.length - 1].date - data[0].date;\n    for (let idx = 1, d1 = data[0]; idx < data.length; d1 = data[idx++]) {\n      // (((d1 + d2) / 2) * (t2 - t1)) / fulltime\n      res +=\n        (((d1.value + data[idx].value) / 2) * (data[idx].date - d1.date)) /\n        fullTime;\n    }\n    return res;\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n   * @return {Promise<number>}\n   * @memberof SpinalServiceTimeseries\n   */\n  async getMeanWithoutNegativeValues(\n    endpointNodeId: EndpointId,\n    timeSeriesIntervalDate: TimeSeriesIntervalDate\n  ): Promise<number> {\n    const dataNotFiltred = await this.getData(\n      endpointNodeId,\n      timeSeriesIntervalDate\n    );\n    //exclude negative values from data\n    const data = dataNotFiltred.filter((x) => {\n      return x.value >= 0;\n    });\n\n    if (data.length === 0) return NaN;\n    if (data.length === 1) return data[0].value;\n    let res = 0;\n    const fullTime = data[data.length - 1].date - data[0].date;\n    for (let idx = 1, d1 = data[0]; idx < data.length; d1 = data[idx++]) {\n      // (((d1 + d2) / 2) * (t2 - t1)) / fulltime\n      res +=\n        (((d1.value + data[idx].value) / 2) * (data[idx].date - d1.date)) /\n        fullTime;\n    }\n    return res;\n  }\n  /**\n   * getIntegral | time in ms\n   * @param {EndpointId} endpointNodeId\n   * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n   * @return {Promise<number>}\n   * @memberof SpinalServiceTimeseries\n   */\n  async getIntegral(\n    endpointNodeId: EndpointId,\n    timeSeriesIntervalDate: TimeSeriesIntervalDate\n  ): Promise<number> {\n    const data = await this.getData(endpointNodeId, timeSeriesIntervalDate);\n    if (data.length === 0) return NaN;\n    if (data.length === 1) return data[0].value;\n    let res = 0;\n    for (let idx = 1, d1 = data[0]; idx < data.length; d1 = data[idx++]) {\n      // ((d1 + d2) / 2) * (t2 - t1)\n      res += ((d1.value + data[idx].value) / 2) * (data[idx].date - d1.date);\n    }\n    return res;\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n   * @return  {Promise<number>}\n   * @memberof SpinalServiceTimeseries\n   */\n  async getMax(\n    endpointNodeId: EndpointId,\n    timeSeriesIntervalDate: TimeSeriesIntervalDate\n  ): Promise<number> {\n    const data = await this.getData(endpointNodeId, timeSeriesIntervalDate);\n    if (data.length === 0) return 0;\n    return data.reduce((a, b) => (a < b.value ? b.value : a), data[0].value);\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n   * @return {Promise<number>}\n   * @memberof SpinalServiceTimeseries\n   */\n  async getMin(\n    endpointNodeId: EndpointId,\n    timeSeriesIntervalDate: TimeSeriesIntervalDate\n  ): Promise<number> {\n    const data = await this.getData(endpointNodeId, timeSeriesIntervalDate);\n    if (data.length === 0) return 0;\n    return data.reduce((a, b) => (a > b.value ? b.value : a), data[0].value);\n  }\n\n  /**\n   * @param {EndpointId} endpointNodeId\n   * @param {TimeSeriesIntervalDate} timeSeriesIntervalDate\n   * @return {Promise<number>}\n   * @memberof SpinalServiceTimeseries\n   */\n  async getSum(\n    endpointNodeId: EndpointId,\n    timeSeriesIntervalDate: TimeSeriesIntervalDate\n  ): Promise<number> {\n    const data = await this.getData(endpointNodeId, timeSeriesIntervalDate);\n    return data.reduce((a, b) => a + b.value, 0);\n  }\n}\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ServiceDocumentation_1 = require(\"./Models/ServiceDocumentation\");\n__exportStar(require(\"./Models/constants\"), exports);\n__exportStar(require(\"./interfaces/index\"), exports);\n__exportStar(require(\"./Models/AttributeService\"), exports);\n__exportStar(require(\"./Models/FileExplorer\"), exports);\n__exportStar(require(\"./Models/NoteService\"), exports);\n__exportStar(require(\"./Models/UrlService\"), exports);\n__exportStar(require(\"./Models/ServiceDocumentation\"), exports);\nexports.default = ServiceDocumentation_1.serviceDocumentation;\n//# sourceMappingURL=index.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { serviceDocumentation } from './Models/ServiceDocumentation';\n\nexport * from './Models/constants';\nexport * from './interfaces/index';\nexport * from './Models/AttributeService';\nexport * from './Models/FileExplorer';\nexport * from './Models/NoteService';\nexport * from './Models/UrlService';\nexport * from './Models/ServiceDocumentation';\n\nexport default serviceDocumentation;\n","\"use strict\";\n/*\n * Copyright 2022 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serviceDocumentation = exports.ServiceDocumentation = void 0;\nconst AttributeService_1 = require(\"./AttributeService\");\nconst NoteService_1 = require(\"./NoteService\");\nconst UrlService_1 = require(\"./UrlService\");\n// @ts-ignore\nconst globalType = typeof window === 'undefined' ? global : window;\nfunction applyMixins(derivedConstructor, baseConstructors) {\n    baseConstructors.forEach((baseConstructor) => {\n        Object.getOwnPropertyNames(baseConstructor.prototype).forEach((name) => {\n            Object.defineProperty(derivedConstructor.prototype, name, Object.getOwnPropertyDescriptor(baseConstructor.prototype, name));\n        });\n    });\n}\nclass ServiceDocumentation {\n}\nexports.ServiceDocumentation = ServiceDocumentation;\napplyMixins(ServiceDocumentation, [AttributeService_1.AttributeService, NoteService_1.NoteService, UrlService_1.UrlService]);\nconst serviceDocumentation = new ServiceDocumentation();\nexports.serviceDocumentation = serviceDocumentation;\nglobalType.spinal['serviceDocumentation'] = serviceDocumentation;\n/*\n\nclass ServiceDocumentation implements AttributeService, NoteService, UrlService {\n\n    ///////////////////////////////////////////////////////////////////////\n    //                       Attribute Service                           //\n    ///////////////////////////////////////////////////////////////////////\n\n    addCategoryAttribute: (node: any, label: string) => Promise<any>;\n    getCategoryByName: (node: any, categoryName: string) => Promise<any>;\n    getCategory: (node: any) => Promise<any>;\n    getAttributesByCategory: (node: any, categoryName: string) => Promise<any[]>;\n    addAttributeByCategory: (node: any, category: any, label: string, value: string) => void;\n    addAttributeByCategoryName: (node: any, categoryName: string, label: string, value: string) => Promise<void>;\n    addAttribute: (node: any, label: string, value: string) => Promise<void>;\n    getAllAttributes: (node: any) => Promise<any>;\n    getAttributes: (node: any) => Promise<any>;\n    compareAttr: (listAttr1: any, listAttr2: any) => any[];\n    getAttributesShared: (listOfdbId: number[]) => Promise<any>;\n    getBuildingInformationAttributes: (node: any) => Promise<any[]>;\n    setBuildingInformationAttributes: (node: any) => Promise<any[]>;\n    findAttributesByLabel: (node: any, label: string, category?: any) => Promise<any>;\n    removeAttributesByLabel: (node: any, label: string) => void;\n\n    ///////////////////////////////////////////////////////////////////////\n    //                         NOTE Service                              //\n    ///////////////////////////////////////////////////////////////////////\n\n    addNote: (node: any, userInfo: { username: string; userId: number; }, note: string) => Promise<void>;\n    getNotes: (node: any) => Promise<any>;\n    editNote: (element: any, note: string) => void;\n    predicate: (node: any) => boolean;\n\n    ///////////////////////////////////////////////////////////////////////\n    //                          URL Service                              //\n    ///////////////////////////////////////////////////////////////////////\n\n    addURL: (node: any, urlName: string, urlLink: string) => Promise<any>;\n    getURL: (node: any, urlName?: string) => Promise<any>;\n    getParents: (node: any, relationNames: string[]) => Promise<any>;\n    getParentGroup: (node: any) => void;\n    deleteURL: (node: any, label: string) => Promise<void>;\n\n}\n\n*/\n//# sourceMappingURL=ServiceDocumentation.js.map","/*\n * Copyright 2022 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { AttributeService } from './AttributeService';\nimport { NoteService } from './NoteService';\nimport { UrlService } from './UrlService';\n\n// @ts-ignore\nconst globalType: any = typeof window === 'undefined' ? global : window;\n\nfunction applyMixins(derivedConstructor: any, baseConstructors: any[]) {\n  baseConstructors.forEach((baseConstructor) => {\n    Object.getOwnPropertyNames(baseConstructor.prototype).forEach((name) => {\n      Object.defineProperty(\n        derivedConstructor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(baseConstructor.prototype, name)\n      );\n    });\n  });\n}\n\nclass ServiceDocumentation {}\n\ninterface ServiceDocumentation\n  extends AttributeService,\n    NoteService,\n    UrlService {}\n\napplyMixins(ServiceDocumentation, [AttributeService, NoteService, UrlService]);\n\nconst serviceDocumentation = new ServiceDocumentation();\n\nglobalType.spinal['serviceDocumentation'] = serviceDocumentation;\n\nexport { ServiceDocumentation, serviceDocumentation };\n\n/*\n\nclass ServiceDocumentation implements AttributeService, NoteService, UrlService {\n\n    ///////////////////////////////////////////////////////////////////////\n    //                       Attribute Service                           //\n    ///////////////////////////////////////////////////////////////////////\n\n    addCategoryAttribute: (node: any, label: string) => Promise<any>;\n    getCategoryByName: (node: any, categoryName: string) => Promise<any>;\n    getCategory: (node: any) => Promise<any>;\n    getAttributesByCategory: (node: any, categoryName: string) => Promise<any[]>;\n    addAttributeByCategory: (node: any, category: any, label: string, value: string) => void;\n    addAttributeByCategoryName: (node: any, categoryName: string, label: string, value: string) => Promise<void>;\n    addAttribute: (node: any, label: string, value: string) => Promise<void>;\n    getAllAttributes: (node: any) => Promise<any>;\n    getAttributes: (node: any) => Promise<any>;\n    compareAttr: (listAttr1: any, listAttr2: any) => any[];\n    getAttributesShared: (listOfdbId: number[]) => Promise<any>;\n    getBuildingInformationAttributes: (node: any) => Promise<any[]>;\n    setBuildingInformationAttributes: (node: any) => Promise<any[]>;\n    findAttributesByLabel: (node: any, label: string, category?: any) => Promise<any>;\n    removeAttributesByLabel: (node: any, label: string) => void;\n\n    ///////////////////////////////////////////////////////////////////////\n    //                         NOTE Service                              //\n    ///////////////////////////////////////////////////////////////////////\n\n    addNote: (node: any, userInfo: { username: string; userId: number; }, note: string) => Promise<void>;\n    getNotes: (node: any) => Promise<any>;\n    editNote: (element: any, note: string) => void;\n    predicate: (node: any) => boolean;\n\n    ///////////////////////////////////////////////////////////////////////\n    //                          URL Service                              //\n    ///////////////////////////////////////////////////////////////////////\n\n    addURL: (node: any, urlName: string, urlLink: string) => Promise<any>;\n    getURL: (node: any, urlName?: string) => Promise<any>;\n    getParents: (node: any, relationNames: string[]) => Promise<any>;\n    getParentGroup: (node: any) => void;\n    deleteURL: (node: any, label: string) => Promise<void>;\n\n}\n\n*/\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attributeService = exports.AttributeService = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst spinal_env_viewer_context_geographic_service_1 = require(\"spinal-env-viewer-context-geographic-service\");\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_models_documentation_1 = require(\"spinal-models-documentation\");\nconst constants_1 = require(\"./constants\");\n/**\n * @class AttributeService\n */\nclass AttributeService {\n    constructor() { }\n    /**\n     * This method creates a category and link it to the node passed in parameter. It returs an object of category\n     * @param  {SpinalNode<any>} node - node on which the category must be linked\n     * @param  {string} categoryName - The category name\n     * @return {*}  {Promise<ICategory>}\n     * @memberof AttributeService\n     */\n    addCategoryAttribute(node, categoryName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            categoryName = categoryName.toString().trim();\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('Node must be a SpinalNode.');\n            if (categoryName.toString().trim().length === 0)\n                throw new Error('Category name must be a string and have at leat one character.');\n            const categoryExist = yield this.getCategoryByName(node, categoryName);\n            if (categoryExist)\n                return categoryExist;\n            const categoryModel = new spinal_env_viewer_graph_service_1.SpinalNode(categoryName, constants_1.CATEGORY_TYPE, new spinal_core_connectorjs_type_1.Lst());\n            const categoryFound = yield node.addChild(categoryModel, constants_1.NODE_TO_CATEGORY_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            return this._getCategoryElement(categoryFound);\n        });\n    }\n    /**\n     * This method deletes a category from the given node.\n     * @param  {SpinalNode<any>} node - node on which the category to be deleted is\n     * @param  {number} serverId - The server ID for the category to delete\n     * @return {*}  {Promise<void>}\n     * @memberof AttributeService\n     */\n    delCategoryAttribute(node, serverId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('Node must be a SpinalNode.');\n            if (serverId === 0)\n                throw new Error('Invalid server ID.');\n            const child = spinal_core_connectorjs_type_1.FileSystem._objects[serverId];\n            if (child instanceof spinal_env_viewer_graph_service_1.SpinalNode) {\n                yield node.removeChild(child, constants_1.NODE_TO_CATEGORY_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            }\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {(SpinalNode<any> | ICategory | string)} category\n     * @return {*}  {Promise<void>}\n     * @memberof AttributeService\n     */\n    deleteAttributeCategory(node, category) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let _category;\n            if (category instanceof spinal_env_viewer_graph_service_1.SpinalNode) {\n                _category = category;\n            }\n            else if (typeof category === 'string') {\n                let temp = yield this.getCategoryByName(node, category);\n                _category = temp.node;\n            }\n            else if (category.node instanceof spinal_env_viewer_graph_service_1.SpinalNode) {\n                _category = category.node;\n            }\n            if (_category instanceof spinal_env_viewer_graph_service_1.SpinalNode)\n                return node.removeChild(_category, constants_1.NODE_TO_CATEGORY_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            throw new Error('category not found');\n        });\n    }\n    /**\n     * This method changes the name of a category from the given node.\n     * @param  {SpinalNode<any>} node - node on which the category to be edited is\n     * @param  {number} serverId - The server ID for the category to edit\n     * @param  {string} categoryName - The new category name\n     * @return {*}  {Promise<void>}\n     * @memberof AttributeService\n     */\n    editCategoryAttribute(node, serverId, categoryName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            categoryName = categoryName.toString().trim();\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('Node must be a SpinalNode.');\n            if (serverId === 0)\n                throw new Error('Invalid server ID.');\n            if (categoryName.length === 0)\n                throw new Error('Category name must be a string and have at leat one character.');\n            const child = spinal_core_connectorjs_type_1.FileSystem._objects[serverId];\n            if (child instanceof spinal_env_viewer_graph_service_1.SpinalNode) {\n                child.info.name.set(categoryName);\n            }\n        });\n    }\n    /**\n     * This method takes as parameter a node and return an array of All categories of attributes linked to this node\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<ICategory[]>}\n     * @memberof AttributeService\n     */\n    getCategory(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('node must be a SpinalNode instance');\n            const categories = yield node.getChildren(constants_1.NODE_TO_CATEGORY_RELATION);\n            const promises = categories.map((el) => this._getCategoryElement(el));\n            return Promise.all(promises);\n        });\n    }\n    /**\n     * This method takes a node and string(category name) as parameters and check if the node has a categorie of attribute which matches the category name\n     * @param  {SpinalNode<any>} node\n     * @param  {string} categoryName\n     * @return {*}  {Promise<ICategory>}\n     * @memberof AttributeService\n     */\n    getCategoryByName(node, categoryName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            categoryName = categoryName.toString().trim();\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('node must be a spinalNode instance');\n            if (!categoryName || categoryName.length === 0)\n                throw new Error('category name must be a string and have at leat one character');\n            const categories = yield this.getCategory(node);\n            return categories.find((el) => {\n                return el.nameCat.toString().trim() === categoryName;\n            });\n        });\n    }\n    /**\n     * Updates the category name\n     * @param {SpinalNode<any>} node\n     * @param {(SpinalNode<any> | ICategory | string)} category\n     * @param {string} newName\n     * @return {*}  {Promise<ICategory>}\n     * @memberof AttributeService\n     */\n    updateCategoryName(node, category, newName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            newName = newName.toString().trim();\n            if (!newName || newName.length === 0)\n                throw new Error('category name must be a string and have at leat one character');\n            if (category instanceof spinal_env_viewer_graph_service_1.SpinalNode) {\n                category.info.name.set(newName);\n                return this._getCategoryElement(category);\n            }\n            else if (typeof category === 'string') {\n                let _category = yield this.getCategoryByName(node, category);\n                _category.node.info.name.set(newName);\n                return _category;\n            }\n            else if (category.node instanceof spinal_env_viewer_graph_service_1.SpinalNode) {\n                category.node.info.name.set(newName);\n                return category;\n            }\n            throw new Error('category not found');\n        });\n    }\n    /**\n     * This method adds(if not exists) an attribute in a category (creates the category if not exist)\n     * @param {SpinalNode<any>} node\n     * @param {string} [categoryName='']\n     * @param {string} [label='']\n     * @param {string} [value='']\n     * @param {string} [type='']\n     * @param {string} [unit='']\n     * @return {*}  {Promise<SpinalAttribute>}\n     * @memberof AttributeService\n     */\n    addAttributeByCategoryName(node, categoryName = '', label = '', value = '', type = '', unit = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            categoryName = categoryName.toString().trim();\n            label = label.toString().trim();\n            value = typeof value === 'string' ? value.toString().trim() : value;\n            type = type.toString().trim();\n            unit = unit.toString().trim();\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('node must be a spinalNode instance');\n            if (!label || label.toString().trim().length === 0)\n                throw new Error('attribute label must be a string and have at leat one character');\n            if (!categoryName || categoryName.toString().trim().length === 0)\n                throw new Error('category name must be a string and have at leat one character');\n            if (typeof value === 'undefined')\n                throw new Error('The attribute value is required');\n            let category = yield this.getCategoryByName(node, categoryName);\n            if (!category) {\n                category = yield this.addCategoryAttribute(node, categoryName);\n            }\n            return this.addAttributeByCategory(node, category, label, value, type, unit);\n        });\n    }\n    /**\n     * This method adds(if not exists) or update(if exists) an attribute in a category\n     * @param {SpinalNode<any>} node\n     * @param {ICategory} category\n     * @param {string} [label='']\n     * @param {string} [value='']\n     * @param {string} [type='']\n     * @param {string} [unit='']\n     * @return {*}  {SpinalAttribute}\n     * @memberof AttributeService\n     */\n    addAttributeByCategory(node, category, label = '', value = '', type = '', unit = '') {\n        label = label.toString().trim();\n        value = typeof value === 'string' ? value.toString().trim() : value;\n        type = type.toString().trim();\n        unit = unit.toString().trim();\n        if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n            throw new Error('node must be a spinalNode instance');\n        if (!label || label.toString().trim().length === 0)\n            throw new Error('attribute label must be a string and have at leat one character');\n        if (typeof value === 'undefined')\n            throw new Error('The attribute value is required');\n        const found = this._labelExistInCategory(category, label);\n        if (!found) {\n            const attributeModel = new spinal_models_documentation_1.SpinalAttribute(label, value, type, unit);\n            category.element.push(attributeModel);\n            return attributeModel;\n        }\n        else {\n            for (let index = 0; index < category.element.length; index++) {\n                const element = category.element[index];\n                const elementLabel = element.label.get();\n                if (elementLabel.toString().trim() === label) {\n                    element.value.set(value);\n                    return element;\n                }\n            }\n        }\n    }\n    /**\n     * Returns an array of all SpinalAttirbute with all categories\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<SpinalAttribute[]>}\n     * @memberof AttributeService\n     */\n    getAllAttributes(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const categories = yield this.getCategory(node);\n            const promises = categories.map((el) => {\n                return this.getAttributesByCategory(node, el.node.info.name.get());\n            });\n            return Promise.all(promises).then((res) => {\n                const result = [];\n                for (let index = 0; index < res.length; index++) {\n                    const element = res[index];\n                    result.push(...element);\n                }\n                return result;\n            });\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {(string | ICategory)} category\n     * @param {string} [label='']\n     * @return {*}  {(Promise<SpinalAttribute | -1>)} : -1 when not found\n     * @memberof AttributeService\n     */\n    findOneAttributeInCategory(node, category, label = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            label = label.toString().trim();\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('node must be a spinalNode instance');\n            const _category = typeof category === 'string'\n                ? yield this.getCategoryByName(node, category)\n                : category;\n            if (_category && _category.element) {\n                for (let index = 0; index < _category.element.length; index++) {\n                    const element = _category.element[index];\n                    if (!!label && element.label.get().toString().trim() === label) {\n                        return element;\n                    }\n                }\n            }\n            return -1;\n        });\n    }\n    /**\n     * Takes as parmaters a node and a string(category name) and return all attributes of the category.\n     * @param {SpinalNode<any>} node\n     * @param {(string | ICategory)} category\n     * @param {string} [label]\n     * @return {*}  {Promise<SpinalAttribute[]>}\n     * @memberof AttributeService\n     */\n    getAttributesByCategory(node, category, label) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('node must be a spinalNode instance');\n            const _category = typeof category === 'string'\n                ? yield this.getCategoryByName(node, category)\n                : category;\n            if (!_category || !_category.element || _category.element.length === 0)\n                return [];\n            if (label) {\n                const labelFound = this._findInLst(_category.element, label);\n                return labelFound ? [labelFound] : [];\n            }\n            const res = [];\n            for (let index = 0; index < _category.element.length; index++) {\n                const element = _category.element[index];\n                res.push(element);\n            }\n            return res;\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {(string | ICategory)} category\n     * @param {string} label\n     * @param {{ label?: string; value?: string; type?: string; unit?: string }} newValues\n     * @param {boolean} [createIt=false]\n     * @return {*}  {Promise<SpinalAttribute>}\n     * @memberof AttributeService\n     */\n    updateAttribute(node, category, label, newValues, createIt = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [attribute] = yield this.getAttributesByCategory(node, category, label);\n            if (!attribute && !createIt)\n                throw new Error('no attribute found');\n            else if (!attribute && createIt && newValues.value) {\n                const _category = typeof category === 'string'\n                    ? yield this.getCategoryByName(node, category)\n                    : category;\n                const lab = newValues.label || label;\n                return this.addAttributeByCategory(node, _category, label, newValues.value);\n            }\n            for (const key in newValues) {\n                if (Object.prototype.hasOwnProperty.call(newValues, key)) {\n                    const value = newValues[key];\n                    if (attribute[key])\n                        attribute[key].set(value);\n                }\n            }\n            return attribute;\n        });\n    }\n    /**\n     * This methods updates all attributes which have the old_label as label\n     * @param {SpinalNode<any>} node\n     * @param {string} old_label\n     * @param {string} old_value\n     * @param {string} new_label\n     * @param {string} new_value\n     * @return {*}  {Promise<void>}\n     * @memberof AttributeService\n     */\n    setAttribute(node, old_label, old_value, new_label, new_value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            old_label = old_label.toString().trim();\n            old_value =\n                typeof old_value === 'string' ? old_value.toString().trim() : old_value;\n            new_label = new_label.toString().trim();\n            new_value =\n                typeof new_value === 'string' ? new_value.toString().trim() : new_value;\n            if (!old_label || old_label.length === 0)\n                throw new Error('old_label must be a string and have at leat one character');\n            if (!new_label || new_label.length === 0)\n                throw new Error('new_label must be a string and have at leat one character');\n            if (typeof old_value === 'undefined')\n                throw new Error('old_value is required');\n            if (typeof new_value === 'undefined')\n                throw new Error('new_value is required');\n            let allAttributes = yield this.getAllAttributes(node);\n            for (let i = 0; i < allAttributes.length; i++) {\n                const element = allAttributes[i];\n                if (element.label.get() == old_label) {\n                    if (new_label != '') {\n                        element.label.set(new_label);\n                    }\n                    if (new_value != '') {\n                        element.value.set(new_value);\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * This methods updates the attribute with the given id from the given node\n     * @param  {SpinalNode<any>} node\n     * @param  {number} serverId\n     * @param  {string} new_label\n     * @param  {string} new_value\n     * @param  {string} new_type\n     * @param  {string} new_unit\n     * @return {*}  {Promise<void>}\n     * @memberof AttributeService\n     */\n    setAttributeById(node, serverId, new_label, new_value, new_type, new_unit) {\n        return __awaiter(this, void 0, void 0, function* () {\n            new_label = new_label.toString().trim();\n            new_value =\n                typeof new_value === 'string' ? new_value.toString().trim() : new_value;\n            new_type = new_type.toString().trim();\n            new_unit = new_unit.toString().trim();\n            const labelIsValid = new_label && new_label.toString().trim().length > 0;\n            const valueIsValid = typeof new_value !== 'undefined';\n            if (!(labelIsValid && valueIsValid))\n                return;\n            let allAttributes = yield this.getAllAttributes(node);\n            for (let i = 0; i < allAttributes.length; i++) {\n                const element = allAttributes[i];\n                if (element._server_id == serverId) {\n                    element.label.set(new_label);\n                    element.value.set(new_value);\n                    element.type.set(new_type);\n                    element.unit.set(new_unit);\n                }\n            }\n        });\n    }\n    /**\n     * Get all attribute shared with other nodes.\n     * @param  {SpinalNode<any>} node\n     * @param  {string} categoryName?\n     * @return {*}  {Promise<{ parentNode: SpinalNode<any>; categories: ICategory[] }[]>}\n     * @memberof AttributeService\n     */\n    getAttributesShared(node, categoryName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            categoryName = categoryName.toString().trim();\n            const parents = yield node.getParents();\n            const promises = parents.map((parent) => __awaiter(this, void 0, void 0, function* () {\n                const categories = yield this.getCategory(parent);\n                const filterCategory = !categoryName || categoryName.length === 0\n                    ? categories\n                    : categories.filter((el) => el.nameCat.toString().trim() === categoryName);\n                return {\n                    parentNode: parent,\n                    categories: filterCategory,\n                };\n            }));\n            return Promise.all(promises);\n        });\n    }\n    /**\n     * Get all attribute shared with other nodes.\n     * @param {ICategory} category\n     * @param {string} label\n     * @return {*}  {Promise<boolean>}\n     * @memberof AttributeService\n     */\n    removeAttributesByLabel(category, label) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listAttributes = yield category.element.load();\n            for (let i = 0; i < listAttributes.length; i++) {\n                const element = listAttributes[i];\n                const elementLabel = element.label.get();\n                if (elementLabel.toString().trim() == label.toString().trim()) {\n                    listAttributes.splice(i, 1);\n                    return true;\n                }\n            }\n            return false;\n        });\n    }\n    /**\n     * Get all attribute shared with other nodes.\n     * @param {ICategory} category\n     * @param {number} serverId\n     * @return {*}  {Promise<boolean>}\n     * @memberof AttributeService\n     */\n    removeAttributesById(category, serverId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listAttributes = yield category.element.load();\n            for (let i = 0; i < listAttributes.length; i++) {\n                const element = listAttributes[i];\n                if (element._server_id == serverId) {\n                    listAttributes.splice(i, 1);\n                    return true;\n                }\n            }\n            return false;\n        });\n    }\n    /**\n     * Takes a node of Building and return all attributes\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<SpinalAttribute[]>}\n     * @memberof AttributeService\n     */\n    getBuildingInformationAttributes(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                return [];\n            if (node.getType().get() === spinal_env_viewer_context_geographic_service_1.default.constants.BUILDING_TYPE) {\n                let lst = [];\n                lst = constants_1.BUILDINGINFORMATION.map((el) => {\n                    return this.findAttributesByLabel(node, el);\n                });\n                return Promise.all(lst).then((element) => element.filter((el) => typeof el !== 'undefined'));\n            }\n            return [];\n        });\n    }\n    /**\n     * Takes a node of Building and creates all attributes\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<SpinalAttribute[]>}\n     * @memberof AttributeService\n     */\n    setBuildingInformationAttributes(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                node = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(node);\n            if (node &&\n                node.getType().get() === spinal_env_viewer_context_geographic_service_1.default.constants.BUILDING_TYPE) {\n                const category = yield this.addCategoryAttribute(node, constants_1.BUILDINGINFORMATIONCATNAME);\n                const promises = constants_1.BUILDINGINFORMATION.map((el) => {\n                    return this.addAttributeByCategory(node, category, el, 'To configure');\n                });\n                yield Promise.all(promises);\n                return this.getBuildingInformationAttributes(node);\n            }\n            return [];\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {string} label\n     * @param {ICategory} [category]\n     * @return {*}  {Promise<SpinalAttribute>}\n     * @memberof AttributeService\n     */\n    findAttributesByLabel(node, label, category) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let data = [];\n            if (typeof category !== 'undefined') {\n                // const categoryName = this._getCategoryName(category);\n                data = yield this.getAttributesByCategory(node, category.nameCat);\n            }\n            else {\n                data = yield this.getAllAttributes(node);\n            }\n            return data.find((el) => el.label.get() === label);\n        });\n    }\n    ///////////////////////////////////////////////////////////////////\n    //              ATTRIBUTES LINKED DIRECTLY TO NODE               //\n    ///////////////////////////////////////////////////////////////////\n    /**\n     * This methods link directily the attribute to the node without use category.\n     * @param {SpinalNode<any>} node\n     * @param {string} label\n     * @param {string} value\n     * @param {string} [type='']\n     * @param {string} [unit='']\n     * @return {*}  {Promise<SpinalNode<any>>}\n     * @memberof AttributeService\n     */\n    addAttribute(node, label, value, type = '', unit = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            // const labelIsValid = label && label.toString().trim().length > 0;\n            // const valueIsValid = typeof value !== \"undefined\";\n            // if (!(labelIsValid && valueIsValid)) return;\n            label = label.toString().trim();\n            value = typeof value === 'string' ? value.toString().trim() : value;\n            type = type.toString().trim();\n            unit = unit.toString().trim();\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('node must be a spinalNode instance');\n            if (!label || label.length === 0)\n                throw new Error('attribute label must be a string and have at leat one character');\n            if (typeof value === 'undefined')\n                throw new Error('The attribute value is required');\n            const attributeExist = yield this._attributeExist(node, label);\n            if (attributeExist) {\n                return attributeExist;\n            }\n            const attributeModel = new spinal_models_documentation_1.SpinalAttribute(label, value, type, unit);\n            const attributeNode = new spinal_env_viewer_graph_service_1.SpinalNode(`[Attributes] ${label}`, constants_1.ATTRIBUTE_TYPE, attributeModel);\n            yield node.addChild(attributeNode, constants_1.NODE_TO_ATTRIBUTE, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            return attributeNode;\n        });\n    }\n    /**\n     * get and returns all attribute linked directely to the node\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<{ node: SpinalNode<any>; element: SpinalAttribute }[]>}\n     * @memberof AttributeService\n     */\n    getAttributes(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const attributes = yield node.getChildren(constants_1.NODE_TO_ATTRIBUTE);\n            const promises = attributes.map((el) => __awaiter(this, void 0, void 0, function* () {\n                return {\n                    node: el,\n                    element: yield el.getElement(),\n                };\n            }));\n            return Promise.all(promises);\n        });\n    }\n    ///////////////////////////////////////////////////////////////////\n    //                          PRIVATES                             //\n    ///////////////////////////////////////////////////////////////////\n    /**\n     * Check if category is linked to node and return it.\n     * @param {SpinalNode<any>} node\n     * @param {string} categoryName\n     * @return {*}  {Promise<SpinalNode<any>>}\n     * @memberof AttributeService\n     */\n    _categoryExist(node, categoryName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // const categories = await node.getChildren(NODE_TO_CATEGORY_RELATION);\n            const categories = yield this.getCategory(node);\n            const found = categories\n                .map((el) => el.node)\n                .find((el) => {\n                return el.getName().get() === categoryName;\n            });\n            return found;\n        });\n    }\n    /**\n     * Takes a category node and format it like an ICategory type;\n     * @param {SpinalNode<any>} categoryNode\n     * @return {*}  {Promise<ICategory>}\n     * @memberof AttributeService\n     */\n    _getCategoryElement(categoryNode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const element = yield categoryNode.getElement();\n            return {\n                element: element,\n                nameCat: categoryNode.getName().get(),\n                node: categoryNode,\n            };\n        });\n    }\n    /**\n     * Check if an attribute exists in a category\n     * @param {ICategory} category\n     * @param {string} argAttributeName\n     * @return {*}  {boolean}\n     * @memberof AttributeService\n     */\n    _labelExistInCategory(category, argAttributeName) {\n        let found = false;\n        if (category && category.element) {\n            const attributes = category.element instanceof spinal_core_connectorjs_type_1.Model\n                ? category.element.get()\n                : category.element;\n            found = attributes.find((el) => {\n                if (el instanceof spinal_core_connectorjs_type_1.Model) {\n                    return el.label.get() === argAttributeName;\n                }\n                else {\n                    return el.label === argAttributeName;\n                }\n            });\n        }\n        return found;\n    }\n    /**\n     * Check if an attribute is directely link to the node\n     * @param {SpinalNode<any>} node\n     * @param {string} argAttributeName\n     * @return {*}  {Promise<SpinalNode<any>>}\n     * @memberof AttributeService\n     */\n    _attributeExist(node, argAttributeName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const attributes = yield node.getChildren([constants_1.NODE_TO_ATTRIBUTE]);\n            return attributes.find((el) => {\n                return el.getName().get() === `[Attributes] ${argAttributeName}`;\n            });\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<void>}\n     * @memberof AttributeService\n     */\n    removeNode(node) {\n        return node.removeFromGraph();\n    }\n    /**\n     * @private\n     * @param {spinal.Lst<SpinalAttribute>} Lst\n     * @param {string} value\n     * @return {*}  {SpinalAttribute}\n     * @memberof AttributeService\n     */\n    _findInLst(Lst, value) {\n        for (let index = 0; index < Lst.length; index++) {\n            const element = Lst[index];\n            if (element.label.get() == value)\n                return element;\n        }\n    }\n}\nexports.AttributeService = AttributeService;\nconst attributeService = new AttributeService();\nexports.attributeService = attributeService;\nexports.default = AttributeService;\n//# sourceMappingURL=AttributeService.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { FileSystem, Lst, Model } from 'spinal-core-connectorjs_type';\nimport geographicService from 'spinal-env-viewer-context-geographic-service';\nimport {\n  SpinalGraphService,\n  SPINAL_RELATION_PTR_LST_TYPE,\n  SpinalNode,\n} from 'spinal-env-viewer-graph-service';\nimport { SpinalAttribute } from 'spinal-models-documentation';\nimport type { ICategory } from '../interfaces';\nimport {\n  ATTRIBUTE_TYPE,\n  BUILDINGINFORMATION,\n  BUILDINGINFORMATIONCATNAME,\n  CATEGORY_TYPE,\n  NODE_TO_ATTRIBUTE,\n  NODE_TO_CATEGORY_RELATION,\n} from './constants';\n\n/**\n * @class AttributeService\n */\nclass AttributeService {\n  constructor() {}\n\n  /**\n   * This method creates a category and link it to the node passed in parameter. It returs an object of category\n   * @param  {SpinalNode<any>} node - node on which the category must be linked\n   * @param  {string} categoryName - The category name\n   * @return {*}  {Promise<ICategory>}\n   * @memberof AttributeService\n   */\n  public async addCategoryAttribute(\n    node: SpinalNode<any>,\n    categoryName: string\n  ): Promise<ICategory> {\n    categoryName = categoryName.toString().trim();\n    if (!(node instanceof SpinalNode))\n      throw new Error('Node must be a SpinalNode.');\n    if (categoryName.toString().trim().length === 0)\n      throw new Error(\n        'Category name must be a string and have at leat one character.'\n      );\n\n    const categoryExist = await this.getCategoryByName(node, categoryName);\n    if (categoryExist) return categoryExist;\n\n    const categoryModel = new SpinalNode(\n      categoryName,\n      CATEGORY_TYPE,\n      new Lst()\n    );\n    const categoryFound = await node.addChild(\n      categoryModel,\n      NODE_TO_CATEGORY_RELATION,\n      SPINAL_RELATION_PTR_LST_TYPE\n    );\n    return this._getCategoryElement(categoryFound);\n  }\n\n  /**\n   * This method deletes a category from the given node.\n   * @param  {SpinalNode<any>} node - node on which the category to be deleted is\n   * @param  {number} serverId - The server ID for the category to delete\n   * @return {*}  {Promise<void>}\n   * @memberof AttributeService\n   */\n  public async delCategoryAttribute(\n    node: SpinalNode<any>,\n    serverId: number\n  ): Promise<void> {\n    if (!(node instanceof SpinalNode))\n      throw new Error('Node must be a SpinalNode.');\n    if (serverId === 0) throw new Error('Invalid server ID.');\n\n    const child = FileSystem._objects[serverId];\n    if (child instanceof SpinalNode) {\n      await node.removeChild(\n        child,\n        NODE_TO_CATEGORY_RELATION,\n        SPINAL_RELATION_PTR_LST_TYPE\n      );\n    }\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {(SpinalNode<any> | ICategory | string)} category\n   * @return {*}  {Promise<void>}\n   * @memberof AttributeService\n   */\n  public async deleteAttributeCategory(\n    node: SpinalNode<any>,\n    category: SpinalNode<any> | ICategory | string\n  ): Promise<void> {\n    let _category;\n    if (category instanceof SpinalNode) {\n      _category = category;\n    } else if (typeof category === 'string') {\n      let temp = await this.getCategoryByName(node, category);\n      _category = temp.node;\n    } else if (category.node instanceof SpinalNode) {\n      _category = category.node;\n    }\n\n    if (_category instanceof SpinalNode)\n      return node.removeChild(\n        _category,\n        NODE_TO_CATEGORY_RELATION,\n        SPINAL_RELATION_PTR_LST_TYPE\n      );\n\n    throw new Error('category not found');\n  }\n\n  /**\n   * This method changes the name of a category from the given node.\n   * @param  {SpinalNode<any>} node - node on which the category to be edited is\n   * @param  {number} serverId - The server ID for the category to edit\n   * @param  {string} categoryName - The new category name\n   * @return {*}  {Promise<void>}\n   * @memberof AttributeService\n   */\n  public async editCategoryAttribute(\n    node: SpinalNode<any>,\n    serverId: number,\n    categoryName: string\n  ): Promise<void> {\n    categoryName = categoryName.toString().trim();\n\n    if (!(node instanceof SpinalNode))\n      throw new Error('Node must be a SpinalNode.');\n    if (serverId === 0) throw new Error('Invalid server ID.');\n    if (categoryName.length === 0)\n      throw new Error(\n        'Category name must be a string and have at leat one character.'\n      );\n\n    const child = FileSystem._objects[serverId];\n    if (child instanceof SpinalNode) {\n      child.info.name.set(categoryName);\n    }\n  }\n\n  /**\n   * This method takes as parameter a node and return an array of All categories of attributes linked to this node\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<ICategory[]>}\n   * @memberof AttributeService\n   */\n  public async getCategory(node: SpinalNode<any>): Promise<ICategory[]> {\n    if (!(node instanceof SpinalNode))\n      throw new Error('node must be a SpinalNode instance');\n\n    const categories = await node.getChildren(NODE_TO_CATEGORY_RELATION);\n\n    const promises = categories.map((el) => this._getCategoryElement(el));\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * This method takes a node and string(category name) as parameters and check if the node has a categorie of attribute which matches the category name\n   * @param  {SpinalNode<any>} node\n   * @param  {string} categoryName\n   * @return {*}  {Promise<ICategory>}\n   * @memberof AttributeService\n   */\n  public async getCategoryByName(\n    node: SpinalNode<any>,\n    categoryName: string\n  ): Promise<ICategory> {\n    categoryName = categoryName.toString().trim();\n    if (!(node instanceof SpinalNode))\n      throw new Error('node must be a spinalNode instance');\n    if (!categoryName || categoryName.length === 0)\n      throw new Error(\n        'category name must be a string and have at leat one character'\n      );\n\n    const categories = await this.getCategory(node);\n\n    return categories.find((el) => {\n      return el.nameCat.toString().trim() === categoryName;\n    });\n  }\n\n  /**\n   * Updates the category name\n   * @param {SpinalNode<any>} node\n   * @param {(SpinalNode<any> | ICategory | string)} category\n   * @param {string} newName\n   * @return {*}  {Promise<ICategory>}\n   * @memberof AttributeService\n   */\n  public async updateCategoryName(\n    node: SpinalNode<any>,\n    category: SpinalNode<any> | ICategory | string,\n    newName: string\n  ): Promise<ICategory> {\n    newName = newName.toString().trim();\n\n    if (!newName || newName.length === 0)\n      throw new Error(\n        'category name must be a string and have at leat one character'\n      );\n\n    if (category instanceof SpinalNode) {\n      category.info.name.set(newName);\n      return this._getCategoryElement(category);\n    } else if (typeof category === 'string') {\n      let _category = await this.getCategoryByName(node, category);\n      _category.node.info.name.set(newName);\n      return _category;\n    } else if (category.node instanceof SpinalNode) {\n      category.node.info.name.set(newName);\n      return category;\n    }\n\n    throw new Error('category not found');\n  }\n\n  /**\n   * This method adds(if not exists) an attribute in a category (creates the category if not exist)\n   * @param {SpinalNode<any>} node\n   * @param {string} [categoryName='']\n   * @param {string} [label='']\n   * @param {string} [value='']\n   * @param {string} [type='']\n   * @param {string} [unit='']\n   * @return {*}  {Promise<SpinalAttribute>}\n   * @memberof AttributeService\n   */\n  public async addAttributeByCategoryName(\n    node: SpinalNode<any>,\n    categoryName: string = '',\n    label: string = '',\n    value: string = '',\n    type: string = '',\n    unit: string = ''\n  ): Promise<SpinalAttribute> {\n    categoryName = categoryName.toString().trim();\n    label = label.toString().trim();\n    value = typeof value === 'string' ? value.toString().trim() : value;\n    type = type.toString().trim();\n    unit = unit.toString().trim();\n\n    if (!(node instanceof SpinalNode))\n      throw new Error('node must be a spinalNode instance');\n    if (!label || label.toString().trim().length === 0)\n      throw new Error(\n        'attribute label must be a string and have at leat one character'\n      );\n    if (!categoryName || categoryName.toString().trim().length === 0)\n      throw new Error(\n        'category name must be a string and have at leat one character'\n      );\n    if (typeof value === 'undefined')\n      throw new Error('The attribute value is required');\n\n    let category = await this.getCategoryByName(node, categoryName);\n\n    if (!category) {\n      category = await this.addCategoryAttribute(node, categoryName);\n    }\n\n    return this.addAttributeByCategory(\n      node,\n      category,\n      label,\n      value,\n      type,\n      unit\n    );\n  }\n\n  /**\n   * This method adds(if not exists) or update(if exists) an attribute in a category\n   * @param {SpinalNode<any>} node\n   * @param {ICategory} category\n   * @param {string} [label='']\n   * @param {string} [value='']\n   * @param {string} [type='']\n   * @param {string} [unit='']\n   * @return {*}  {SpinalAttribute}\n   * @memberof AttributeService\n   */\n  public addAttributeByCategory(\n    node: SpinalNode<any>,\n    category: ICategory,\n    label: string = '',\n    value: string = '',\n    type: string = '',\n    unit: string = ''\n  ): SpinalAttribute {\n    label = label.toString().trim();\n    value = typeof value === 'string' ? value.toString().trim() : value;\n    type = type.toString().trim();\n    unit = unit.toString().trim();\n\n    if (!(node instanceof SpinalNode))\n      throw new Error('node must be a spinalNode instance');\n    if (!label || label.toString().trim().length === 0)\n      throw new Error(\n        'attribute label must be a string and have at leat one character'\n      );\n    if (typeof value === 'undefined')\n      throw new Error('The attribute value is required');\n\n    const found = this._labelExistInCategory(category, label);\n    if (!found) {\n      const attributeModel = new SpinalAttribute(label, value, type, unit);\n      category.element.push(attributeModel);\n      return attributeModel;\n    } else {\n      for (let index = 0; index < category.element.length; index++) {\n        const element = category.element[index];\n        const elementLabel = element.label.get();\n        if (elementLabel.toString().trim() === label) {\n          element.value.set(value);\n          return element;\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns an array of all SpinalAttirbute with all categories\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<SpinalAttribute[]>}\n   * @memberof AttributeService\n   */\n  public async getAllAttributes(\n    node: SpinalNode<any>\n  ): Promise<SpinalAttribute[]> {\n    const categories = await this.getCategory(node);\n    const promises = categories.map((el) => {\n      return this.getAttributesByCategory(node, el.node.info.name.get());\n    });\n\n    return Promise.all(promises).then((res) => {\n      const result = [];\n\n      for (let index = 0; index < res.length; index++) {\n        const element: Array<SpinalAttribute> = res[index];\n        result.push(...element);\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {(string | ICategory)} category\n   * @param {string} [label='']\n   * @return {*}  {(Promise<SpinalAttribute | -1>)} : -1 when not found\n   * @memberof AttributeService\n   */\n  public async findOneAttributeInCategory(\n    node: SpinalNode<any>,\n    category: string | ICategory,\n    label: string = ''\n  ): Promise<SpinalAttribute | -1> {\n    label = label.toString().trim();\n    if (!(node instanceof SpinalNode))\n      throw new Error('node must be a spinalNode instance');\n    const _category =\n      typeof category === 'string'\n        ? await this.getCategoryByName(node, category)\n        : category;\n    if (_category && _category.element) {\n      for (let index = 0; index < _category.element.length; index++) {\n        const element = _category.element[index];\n        if (!!label && element.label.get().toString().trim() === label) {\n          return element;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Takes as parmaters a node and a string(category name) and return all attributes of the category.\n   * @param {SpinalNode<any>} node\n   * @param {(string | ICategory)} category\n   * @param {string} [label]\n   * @return {*}  {Promise<SpinalAttribute[]>}\n   * @memberof AttributeService\n   */\n  public async getAttributesByCategory(\n    node: SpinalNode<any>,\n    category: string | ICategory,\n    label?: string\n  ): Promise<SpinalAttribute[]> {\n    if (!(node instanceof SpinalNode))\n      throw new Error('node must be a spinalNode instance');\n    const _category =\n      typeof category === 'string'\n        ? await this.getCategoryByName(node, category)\n        : category;\n    if (!_category || !_category.element || _category.element.length === 0)\n      return [];\n\n    if (label) {\n      const labelFound = this._findInLst(_category.element, label);\n      return labelFound ? [labelFound] : [];\n    }\n\n    const res = [];\n\n    for (let index = 0; index < _category.element.length; index++) {\n      const element = _category.element[index];\n      res.push(element);\n    }\n\n    return res;\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {(string | ICategory)} category\n   * @param {string} label\n   * @param {{ label?: string; value?: string; type?: string; unit?: string }} newValues\n   * @param {boolean} [createIt=false]\n   * @return {*}  {Promise<SpinalAttribute>}\n   * @memberof AttributeService\n   */\n  public async updateAttribute(\n    node: SpinalNode<any>,\n    category: string | ICategory,\n    label: string,\n    newValues: { label?: string; value?: string; type?: string; unit?: string },\n    createIt: boolean = false\n  ): Promise<SpinalAttribute> {\n    const [attribute] = await this.getAttributesByCategory(\n      node,\n      category,\n      label\n    );\n    if (!attribute && !createIt) throw new Error('no attribute found');\n    else if (!attribute && createIt && newValues.value) {\n      const _category =\n        typeof category === 'string'\n          ? await this.getCategoryByName(node, category)\n          : category;\n      const lab = newValues.label || label;\n\n      return this.addAttributeByCategory(\n        node,\n        _category,\n        label,\n        newValues.value\n      );\n    }\n\n    for (const key in newValues) {\n      if (Object.prototype.hasOwnProperty.call(newValues, key)) {\n        const value = newValues[key];\n        if (attribute[key]) attribute[key].set(value);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * This methods updates all attributes which have the old_label as label\n   * @param {SpinalNode<any>} node\n   * @param {string} old_label\n   * @param {string} old_value\n   * @param {string} new_label\n   * @param {string} new_value\n   * @return {*}  {Promise<void>}\n   * @memberof AttributeService\n   */\n  public async setAttribute(\n    node: SpinalNode<any>,\n    old_label: string,\n    old_value: string,\n    new_label: string,\n    new_value: string\n  ): Promise<void> {\n    old_label = old_label.toString().trim();\n    old_value =\n      typeof old_value === 'string' ? old_value.toString().trim() : old_value;\n    new_label = new_label.toString().trim();\n    new_value =\n      typeof new_value === 'string' ? new_value.toString().trim() : new_value;\n\n    if (!old_label || old_label.length === 0)\n      throw new Error(\n        'old_label must be a string and have at leat one character'\n      );\n    if (!new_label || new_label.length === 0)\n      throw new Error(\n        'new_label must be a string and have at leat one character'\n      );\n    if (typeof old_value === 'undefined')\n      throw new Error('old_value is required');\n    if (typeof new_value === 'undefined')\n      throw new Error('new_value is required');\n\n    let allAttributes = await this.getAllAttributes(node);\n    for (let i = 0; i < allAttributes.length; i++) {\n      const element = allAttributes[i];\n      if (element.label.get() == old_label) {\n        if (new_label != '') {\n          element.label.set(new_label);\n        }\n        if (new_value != '') {\n          element.value.set(new_value);\n        }\n      }\n    }\n  }\n\n  /**\n   * This methods updates the attribute with the given id from the given node\n   * @param  {SpinalNode<any>} node\n   * @param  {number} serverId\n   * @param  {string} new_label\n   * @param  {string} new_value\n   * @param  {string} new_type\n   * @param  {string} new_unit\n   * @return {*}  {Promise<void>}\n   * @memberof AttributeService\n   */\n  public async setAttributeById(\n    node: SpinalNode<any>,\n    serverId: number,\n    new_label: string,\n    new_value: string,\n    new_type: string,\n    new_unit: string\n  ): Promise<void> {\n    new_label = new_label.toString().trim();\n    new_value =\n      typeof new_value === 'string' ? new_value.toString().trim() : new_value;\n    new_type = new_type.toString().trim();\n    new_unit = new_unit.toString().trim();\n\n    const labelIsValid = new_label && new_label.toString().trim().length > 0;\n    const valueIsValid = typeof new_value !== 'undefined';\n    if (!(labelIsValid && valueIsValid)) return;\n\n    let allAttributes = await this.getAllAttributes(node);\n    for (let i = 0; i < allAttributes.length; i++) {\n      const element = allAttributes[i];\n      if (element._server_id == serverId) {\n        element.label.set(new_label);\n        element.value.set(new_value);\n        element.type.set(new_type);\n        element.unit.set(new_unit);\n      }\n    }\n  }\n\n  /**\n   * Get all attribute shared with other nodes.\n   * @param  {SpinalNode<any>} node\n   * @param  {string} categoryName?\n   * @return {*}  {Promise<{ parentNode: SpinalNode<any>; categories: ICategory[] }[]>}\n   * @memberof AttributeService\n   */\n  public async getAttributesShared(\n    node: SpinalNode<any>,\n    categoryName?: string\n  ): Promise<{ parentNode: SpinalNode<any>; categories: ICategory[] }[]> {\n    categoryName = categoryName.toString().trim();\n    const parents = await node.getParents();\n    const promises = parents.map(async (parent) => {\n      const categories = await this.getCategory(parent);\n      const filterCategory =\n        !categoryName || categoryName.length === 0\n          ? categories\n          : categories.filter(\n              (el) => el.nameCat.toString().trim() === categoryName\n            );\n      return {\n        parentNode: parent,\n        categories: filterCategory,\n      };\n    });\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * Get all attribute shared with other nodes.\n   * @param {ICategory} category\n   * @param {string} label\n   * @return {*}  {Promise<boolean>}\n   * @memberof AttributeService\n   */\n  public async removeAttributesByLabel(\n    category: ICategory,\n    label: string\n  ): Promise<boolean> {\n    const listAttributes = await category.element.load();\n    for (let i = 0; i < listAttributes.length; i++) {\n      const element = listAttributes[i];\n      const elementLabel = element.label.get();\n\n      if (elementLabel.toString().trim() == label.toString().trim()) {\n        listAttributes.splice(i, 1);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get all attribute shared with other nodes.\n   * @param {ICategory} category\n   * @param {number} serverId\n   * @return {*}  {Promise<boolean>}\n   * @memberof AttributeService\n   */\n  public async removeAttributesById(\n    category: ICategory,\n    serverId: number\n  ): Promise<boolean> {\n    const listAttributes = await category.element.load();\n    for (let i = 0; i < listAttributes.length; i++) {\n      const element = listAttributes[i];\n      if (element._server_id == serverId) {\n        listAttributes.splice(i, 1);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Takes a node of Building and return all attributes\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<SpinalAttribute[]>}\n   * @memberof AttributeService\n   */\n  public async getBuildingInformationAttributes(\n    node: SpinalNode<any>\n  ): Promise<SpinalAttribute[]> {\n    if (!(node instanceof SpinalNode)) return [];\n\n    if (node.getType().get() === geographicService.constants.BUILDING_TYPE) {\n      let lst: Promise<SpinalAttribute>[] = [];\n      lst = BUILDINGINFORMATION.map((el: string): Promise<SpinalAttribute> => {\n        return this.findAttributesByLabel(node, el);\n      });\n\n      return Promise.all(lst).then((element) =>\n        element.filter((el) => typeof el !== 'undefined')\n      );\n    }\n    return [];\n  }\n\n  /**\n   * Takes a node of Building and creates all attributes\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<SpinalAttribute[]>}\n   * @memberof AttributeService\n   */\n  public async setBuildingInformationAttributes(\n    node: SpinalNode<any>\n  ): Promise<SpinalAttribute[]> {\n    if (!(node instanceof SpinalNode))\n      node = SpinalGraphService.getRealNode(node);\n\n    if (\n      node &&\n      node.getType().get() === geographicService.constants.BUILDING_TYPE\n    ) {\n      const category = await this.addCategoryAttribute(\n        node,\n        BUILDINGINFORMATIONCATNAME\n      );\n      const promises = BUILDINGINFORMATION.map((el) => {\n        return this.addAttributeByCategory(node, category, el, 'To configure');\n      });\n\n      await Promise.all(promises);\n      return this.getBuildingInformationAttributes(node);\n    }\n\n    return [];\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {string} label\n   * @param {ICategory} [category]\n   * @return {*}  {Promise<SpinalAttribute>}\n   * @memberof AttributeService\n   */\n  public async findAttributesByLabel(\n    node: SpinalNode<any>,\n    label: string,\n    category?: ICategory\n  ): Promise<SpinalAttribute> {\n    let data: SpinalAttribute[] = [];\n\n    if (typeof category !== 'undefined') {\n      // const categoryName = this._getCategoryName(category);\n      data = await this.getAttributesByCategory(node, category.nameCat);\n    } else {\n      data = await this.getAllAttributes(node);\n    }\n\n    return data.find((el) => el.label.get() === label);\n  }\n\n  ///////////////////////////////////////////////////////////////////\n  //              ATTRIBUTES LINKED DIRECTLY TO NODE               //\n  ///////////////////////////////////////////////////////////////////\n\n  /**\n   * This methods link directily the attribute to the node without use category.\n   * @param {SpinalNode<any>} node\n   * @param {string} label\n   * @param {string} value\n   * @param {string} [type='']\n   * @param {string} [unit='']\n   * @return {*}  {Promise<SpinalNode<any>>}\n   * @memberof AttributeService\n   */\n  public async addAttribute(\n    node: SpinalNode<any>,\n    label: string,\n    value: string,\n    type: string = '',\n    unit: string = ''\n  ): Promise<SpinalNode<any>> {\n    // const labelIsValid = label && label.toString().trim().length > 0;\n    // const valueIsValid = typeof value !== \"undefined\";\n\n    // if (!(labelIsValid && valueIsValid)) return;\n    label = label.toString().trim();\n    value = typeof value === 'string' ? value.toString().trim() : value;\n    type = type.toString().trim();\n    unit = unit.toString().trim();\n\n    if (!(node instanceof SpinalNode))\n      throw new Error('node must be a spinalNode instance');\n    if (!label || label.length === 0)\n      throw new Error(\n        'attribute label must be a string and have at leat one character'\n      );\n    if (typeof value === 'undefined')\n      throw new Error('The attribute value is required');\n\n    const attributeExist = await this._attributeExist(node, label);\n\n    if (attributeExist) {\n      return attributeExist;\n    }\n\n    const attributeModel = new SpinalAttribute(label, value, type, unit);\n    const attributeNode = new SpinalNode(\n      `[Attributes] ${label}`,\n      ATTRIBUTE_TYPE,\n      attributeModel\n    );\n    await node.addChild(\n      attributeNode,\n      NODE_TO_ATTRIBUTE,\n      SPINAL_RELATION_PTR_LST_TYPE\n    );\n    return attributeNode;\n  }\n\n  /**\n   * get and returns all attribute linked directely to the node\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<{ node: SpinalNode<any>; element: SpinalAttribute }[]>}\n   * @memberof AttributeService\n   */\n  public async getAttributes(\n    node: SpinalNode<any>\n  ): Promise<{ node: SpinalNode<any>; element: SpinalAttribute }[]> {\n    const attributes = await node.getChildren(NODE_TO_ATTRIBUTE);\n    const promises = attributes.map(async (el) => {\n      return {\n        node: el,\n        element: await el.getElement(),\n      };\n    });\n\n    return Promise.all(promises);\n  }\n\n  ///////////////////////////////////////////////////////////////////\n  //                          PRIVATES                             //\n  ///////////////////////////////////////////////////////////////////\n\n  /**\n   * Check if category is linked to node and return it.\n   * @param {SpinalNode<any>} node\n   * @param {string} categoryName\n   * @return {*}  {Promise<SpinalNode<any>>}\n   * @memberof AttributeService\n   */\n  public async _categoryExist(\n    node: SpinalNode<any>,\n    categoryName: string\n  ): Promise<SpinalNode<any>> {\n    // const categories = await node.getChildren(NODE_TO_CATEGORY_RELATION);\n    const categories = await this.getCategory(node);\n\n    const found = categories\n      .map((el) => el.node)\n      .find((el) => {\n        return el.getName().get() === categoryName;\n      });\n\n    return found;\n  }\n\n  /**\n   * Takes a category node and format it like an ICategory type;\n   * @param {SpinalNode<any>} categoryNode\n   * @return {*}  {Promise<ICategory>}\n   * @memberof AttributeService\n   */\n  public async _getCategoryElement(\n    categoryNode: SpinalNode<any>\n  ): Promise<ICategory> {\n    const element = await categoryNode.getElement();\n    return {\n      element: element,\n      nameCat: categoryNode.getName().get(),\n      node: categoryNode,\n    };\n  }\n\n  /**\n   * Check if an attribute exists in a category\n   * @param {ICategory} category\n   * @param {string} argAttributeName\n   * @return {*}  {boolean}\n   * @memberof AttributeService\n   */\n  public _labelExistInCategory(\n    category: ICategory,\n    argAttributeName: string\n  ): boolean {\n    let found = false;\n    if (category && category.element) {\n      const attributes =\n        category.element instanceof Model\n          ? category.element.get()\n          : category.element;\n\n      found = attributes.find((el) => {\n        if (el instanceof Model) {\n          return el.label.get() === argAttributeName;\n        } else {\n          return el.label === argAttributeName;\n        }\n      });\n    }\n\n    return found;\n  }\n\n  /**\n   * Check if an attribute is directely link to the node\n   * @param {SpinalNode<any>} node\n   * @param {string} argAttributeName\n   * @return {*}  {Promise<SpinalNode<any>>}\n   * @memberof AttributeService\n   */\n  public async _attributeExist(\n    node: SpinalNode<any>,\n    argAttributeName: string\n  ): Promise<SpinalNode<any>> {\n    const attributes = await node.getChildren([NODE_TO_ATTRIBUTE]);\n\n    return attributes.find((el) => {\n      return el.getName().get() === `[Attributes] ${argAttributeName}`;\n    });\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<void>}\n   * @memberof AttributeService\n   */\n  public removeNode(node: SpinalNode<any>): Promise<void> {\n    return node.removeFromGraph();\n  }\n\n  /**\n   * @private\n   * @param {spinal.Lst<SpinalAttribute>} Lst\n   * @param {string} value\n   * @return {*}  {SpinalAttribute}\n   * @memberof AttributeService\n   */\n  private _findInLst(\n    Lst: spinal.Lst<SpinalAttribute>,\n    value: string\n  ): SpinalAttribute {\n    for (let index = 0; index < Lst.length; index++) {\n      const element = Lst[index];\n      if (element.label.get() == value) return element;\n    }\n  }\n}\n\nconst attributeService = new AttributeService();\n\nexport { AttributeService, attributeService };\n\nexport default AttributeService;\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./SpinalAttribute\"), exports);\n__exportStar(require(\"./SpinalFile\"), exports);\n__exportStar(require(\"./SpinalNote\"), exports);\n__exportStar(require(\"./SpinalURL\"), exports);\n__exportStar(require(\"./constants\"), exports);\n//# sourceMappingURL=index.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nexport * from './SpinalAttribute';\nexport * from './SpinalFile';\nexport * from './SpinalNote';\nexport * from './SpinalURL';\nexport * from './constants';\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalAttribute = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nclass SpinalAttribute extends spinal_core_connectorjs_type_1.Model {\n    constructor(label, value, type = '', unit = '') {\n        super();\n        this.add_attr({\n            label: label,\n            value: value,\n            date: Date.now(),\n            type: type,\n            unit: unit,\n        });\n    }\n}\nexports.SpinalAttribute = SpinalAttribute;\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalAttribute);\n//# sourceMappingURL=SpinalAttribute.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { spinalCore, Model } from 'spinal-core-connectorjs_type';\n\nexport class SpinalAttribute extends Model {\n  public label: spinal.Str;\n  public value: spinal.Str | spinal.Val | spinal.Bool;\n  public date: spinal.Val;\n  public type: spinal.Str;\n  public unit: spinal.Str;\n\n  constructor(label: string, value: any, type: string = '', unit: string = '') {\n    super();\n    this.add_attr({\n      label: label,\n      value: value,\n      date: Date.now(),\n      type: type,\n      unit: unit,\n    });\n  }\n}\n\nspinalCore.register_models(SpinalAttribute);\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalFile = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nclass SpinalFile extends spinal_core_connectorjs_type_1.Model {\n    constructor(id, name) {\n        super();\n        this.add_attr({\n            id: id,\n            name: name,\n        });\n    }\n}\nexports.SpinalFile = SpinalFile;\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalFile);\n//# sourceMappingURL=SpinalFile.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { spinalCore, Model } from 'spinal-core-connectorjs_type';\n\nexport class SpinalFile extends Model {\n  public id: spinal.Str;\n  public name: spinal.Str;\n\n  constructor(id: string, name: string) {\n    super();\n    this.add_attr({\n      id: id,\n      name: name,\n    });\n  }\n}\n\nspinalCore.register_models(SpinalFile);\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalNote = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst constants_1 = require(\"./constants\");\nclass SpinalNote extends spinal_core_connectorjs_type_1.Model {\n    constructor(username, message, userId, type = constants_1.MESSAGE_TYPES.text, file, viewPoint) {\n        super();\n        this.add_attr({\n            username: username,\n            date: Date.now(),\n            message: message,\n            userId: userId,\n            type: type,\n            file: file ? new spinal_core_connectorjs_type_1.Ptr(file) : undefined,\n            viewPoint: viewPoint ? viewPoint : undefined,\n        });\n    }\n}\nexports.SpinalNote = SpinalNote;\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalNote);\n//# sourceMappingURL=SpinalNote.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { spinalCore, Model, Ptr } from 'spinal-core-connectorjs_type';\nimport { MESSAGE_TYPES } from './constants';\n\nexport interface ViewStateInterface {\n  viewState: string;\n  objectState: string;\n  [key: string]: any;\n}\n\nexport interface ViewStateInterfaceModel extends spinal.Model {\n  viewState: spinal.Str;\n  objectState: spinal.Str;\n  [key: string]: any;\n}\n\nexport class SpinalNote extends Model {\n  username: spinal.Str;\n  date: spinal.Str;\n  message: spinal.Str;\n  userId: spinal.Str;\n  type: spinal.Str;\n  file: spinal.Ptr<spinal.File<spinal.Path>>;\n  viewPoint: ViewStateInterfaceModel;\n\n  constructor(\n    username: string,\n    message: string,\n    userId: string,\n    type: string = MESSAGE_TYPES.text,\n    file?: any,\n    viewPoint?: ViewStateInterface\n  ) {\n    super();\n    this.add_attr({\n      username: username,\n      date: Date.now(),\n      message: message,\n      userId: userId,\n      type: type,\n      file: file ? new Ptr(file) : undefined,\n      viewPoint: viewPoint ? viewPoint : undefined,\n    });\n  }\n}\n\nspinalCore.register_models(SpinalNote);\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MESSAGE_TYPES = void 0;\nexports.MESSAGE_TYPES = { text: 'text', image: 'img', file: 'file' };\n//# sourceMappingURL=constants.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nexport const MESSAGE_TYPES = { text: 'text', image: 'img', file: 'file' };\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalURL = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nclass SpinalURL extends spinal_core_connectorjs_type_1.Model {\n    constructor(name, url) {\n        super();\n        this.add_attr({\n            date: Date.now(),\n            URL: url,\n            name: name,\n        });\n    }\n}\nexports.SpinalURL = SpinalURL;\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalURL);\n//# sourceMappingURL=SpinalURL.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { spinalCore, Model } from 'spinal-core-connectorjs_type';\n\nexport class SpinalURL extends Model {\n  date: spinal.Val;\n  URL: spinal.Str;\n  name: spinal.Str;\n\n  constructor(name: string, url: string) {\n    super();\n    this.add_attr({\n      date: Date.now(),\n      URL: url,\n      name: name,\n    });\n  }\n}\n\nspinalCore.register_models(SpinalURL);\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BUILDINGINFORMATIONCATNAME = exports.BUILDINGINFORMATION = exports.ATTRIBUTE_TYPE = exports.CATEGORY_TYPE = exports.NODE_TO_ATTRIBUTE = exports.NODE_TO_CATEGORY_RELATION = exports.NOTE_GROUP_NAME = exports.NOTE_CATEGORY_NAME = exports.NOTE_CONTEXT_NAME = exports.NOTE_TYPE = exports.NOTE_RELATION = exports.URL_TYPE = exports.URL_RELATION = void 0;\nconst URL_RELATION = 'hasURL';\nexports.URL_RELATION = URL_RELATION;\nconst URL_TYPE = 'SpinalURL';\nexports.URL_TYPE = URL_TYPE;\nconst NOTE_RELATION = 'hasNotes';\nexports.NOTE_RELATION = NOTE_RELATION;\nconst NOTE_TYPE = 'SpinalNote';\nexports.NOTE_TYPE = NOTE_TYPE;\nconst NOTE_CONTEXT_NAME = 'Default Note Context';\nexports.NOTE_CONTEXT_NAME = NOTE_CONTEXT_NAME;\nconst NOTE_CATEGORY_NAME = 'Default Note Category';\nexports.NOTE_CATEGORY_NAME = NOTE_CATEGORY_NAME;\nconst NOTE_GROUP_NAME = 'Default Note Group';\nexports.NOTE_GROUP_NAME = NOTE_GROUP_NAME;\nconst NODE_TO_CATEGORY_RELATION = 'hasCategoryAttributes';\nexports.NODE_TO_CATEGORY_RELATION = NODE_TO_CATEGORY_RELATION;\nconst NODE_TO_ATTRIBUTE = 'hasAttributes';\nexports.NODE_TO_ATTRIBUTE = NODE_TO_ATTRIBUTE;\nconst CATEGORY_TYPE = 'categoryAttributes';\nexports.CATEGORY_TYPE = CATEGORY_TYPE;\nconst ATTRIBUTE_TYPE = 'SpinalAttributes';\nexports.ATTRIBUTE_TYPE = ATTRIBUTE_TYPE;\nconst BUILDINGINFORMATION = [\n    'Titre',\n    'Bâtiment',\n    'Surface',\n    'Adresse',\n    'Ville',\n];\nexports.BUILDINGINFORMATION = BUILDINGINFORMATION;\nconst BUILDINGINFORMATIONCATNAME = 'Spinal Building Information';\nexports.BUILDINGINFORMATIONCATNAME = BUILDINGINFORMATIONCATNAME;\n//# sourceMappingURL=constants.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nconst URL_RELATION: string = 'hasURL';\nconst URL_TYPE: string = 'SpinalURL';\n\nconst NOTE_RELATION: string = 'hasNotes';\nconst NOTE_TYPE: string = 'SpinalNote';\nconst NOTE_CONTEXT_NAME: string = 'Default Note Context';\nconst NOTE_CATEGORY_NAME: string = 'Default Note Category';\nconst NOTE_GROUP_NAME: string = 'Default Note Group';\n\nconst NODE_TO_CATEGORY_RELATION: string = 'hasCategoryAttributes';\nconst NODE_TO_ATTRIBUTE: string = 'hasAttributes';\nconst CATEGORY_TYPE: string = 'categoryAttributes';\nconst ATTRIBUTE_TYPE: string = 'SpinalAttributes';\nconst BUILDINGINFORMATION: string[] = [\n  'Titre',\n  'Bâtiment',\n  'Surface',\n  'Adresse',\n  'Ville',\n];\nconst BUILDINGINFORMATIONCATNAME: string = 'Spinal Building Information';\n\nexport {\n  URL_RELATION,\n  URL_TYPE,\n  NOTE_RELATION,\n  NOTE_TYPE,\n  NOTE_CONTEXT_NAME,\n  NOTE_CATEGORY_NAME,\n  NOTE_GROUP_NAME,\n  NODE_TO_CATEGORY_RELATION,\n  NODE_TO_ATTRIBUTE,\n  CATEGORY_TYPE,\n  ATTRIBUTE_TYPE,\n  BUILDINGINFORMATION,\n  BUILDINGINFORMATIONCATNAME,\n};\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.noteService = exports.NoteService = void 0;\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_env_viewer_plugin_group_manager_service_1 = require(\"spinal-env-viewer-plugin-group-manager-service\");\nconst spinal_models_documentation_1 = require(\"spinal-models-documentation\");\nconst constants_1 = require(\"./constants\");\nconst FileExplorer_1 = require(\"./FileExplorer\");\nconst globalType = typeof window === 'undefined' ? global : window;\nclass NoteService {\n    constructor() { }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {{ username: string; userId: number }} userInfo\n     * @param {string} note - Your message or File name\n     * @param {string} [type]\n     * @param {spinal.File} [file] - Spinal File\n     * @param {string} [noteContextId]\n     * @param {string} [noteGroupId]\n     * @param {ViewStateInterface} [viewPoint]\n     * @return {*}  {Promise<SpinalNode<any>>}\n     * @memberof NoteService\n     */\n    addNote(node, userInfo, note, type, file, noteContextId, noteGroupId, viewPoint) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw 'node must be a SpinalNode';\n            if (file && !(file instanceof spinal.File))\n                throw 'File must be a SpinalFile';\n            const spinalNote = new spinal_models_documentation_1.SpinalNote(userInfo.username, note, (_a = userInfo.userId) === null || _a === void 0 ? void 0 : _a.toString(), type, file, viewPoint);\n            const noteNode = new spinal_env_viewer_graph_service_1.SpinalNode(`message-${Date.now()}`, constants_1.NOTE_TYPE, spinalNote);\n            yield node.addChild(noteNode, constants_1.NOTE_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            // if (noteNode instanceof SpinalNode) {\n            //   noteNode.info.name.set(`message-${Date.now()}`);\n            //   noteNode.info.type.set(NOTE_TYPE);\n            // }\n            yield this.createAttribute(noteNode, spinalNote);\n            yield this.addNoteToContext(noteNode, noteContextId, noteGroupId);\n            return noteNode;\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {*} files\n     * @param {{ username: string; userId: number }} userInfo\n     * @param {string} [noteContextId]\n     * @param {string} [noteGroupId]\n     * @return {*}  {Promise<SpinalNode<any>[]>}\n     * @memberof NoteService\n     */\n    addFileAsNote(node, files, userInfo, noteContextId, noteGroupId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof FileList !== 'undefined' && files instanceof FileList)\n                files = Array.from(files);\n            const res = yield this.addFilesInDirectory(node, files);\n            const promises = res.map((data) => {\n                const type = FileExplorer_1.FileExplorer._getFileType(data.file);\n                let files_1 = FileExplorer_1.FileExplorer.addFileUpload(data.directory, [data.file]);\n                let file_1 = files_1.length > 0 ? files_1[0] : undefined;\n                const viewPoint = Object.keys(data.viewPoint).length > 0 ? data.viewPoint : undefined;\n                return this.addNote(node, userInfo, data.file.name, type, file_1, noteContextId, noteGroupId, viewPoint);\n            });\n            return yield Promise.all(promises);\n        });\n    }\n    /**\n     * Adding a note to a node\n     *\n     * @param {SpinalNode<any>} node node to add the note to\n     * @param {{ username: string, userId: number }} userInfo information of the user posting the note\n     * @param {string} note note to add\n     * @param {string} [type] type of the note\n     * @param {File} [file] file to add to the node\n     * @param {ViewStateInterface} [viewPoint] viewpoint to save in the note\n     * @param {string} [noteContextId] contextID of the note\n     * @param {string} [noteGroupId] groupID of the note\n     * @return {*} {Promise<SpinalNode<any>>} note as a node\n     * @memberof NoteService\n     */\n    twinAddNote(node, userInfo, note, type, file, viewPoint, noteContextId, noteGroupId) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                return;\n            let uploaded = undefined;\n            if (typeof file !== 'undefined') {\n                uploaded = FileExplorer_1.FileExplorer.addFileUpload(yield FileExplorer_1.FileExplorer._getOrCreateFileDirectory(node), [file]);\n            }\n            let view = undefined;\n            if (typeof viewPoint !== 'undefined') {\n                view = Object.keys(viewPoint).length > 0 ? viewPoint : undefined;\n            }\n            const spinalNote = new spinal_models_documentation_1.SpinalNote(userInfo.username, note, (_a = userInfo.userId) === null || _a === void 0 ? void 0 : _a.toString(), type, uploaded[0], view);\n            const spinalNode = yield node.addChild(spinalNote, constants_1.NOTE_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            if (spinalNode && spinalNode.info) {\n                spinalNode.info.name.set(`message-${Date.now()}`);\n                spinalNode.info.type.set(constants_1.NOTE_TYPE);\n            }\n            yield this.createAttribute(spinalNode, spinalNote);\n            spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(spinalNode);\n            let contextId = noteContextId;\n            let groupId = noteGroupId;\n            if (typeof contextId === 'undefined') {\n                const noteContext = yield this.createDefaultContext();\n                contextId = noteContext.getId().get();\n            }\n            if (typeof groupId === 'undefined') {\n                const groupNode = yield this.createDefaultGroup();\n                groupId = groupNode.getId().get();\n            }\n            yield this.linkNoteToGroup(contextId, groupId, spinalNode.getId().get());\n            return spinalNode;\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<{ element: SpinalNote; selectedNode: SpinalNode<any> }[]>}\n     * @memberof NoteService\n     */\n    getNotes(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                return;\n            const messagesNodes = yield node.getChildren(constants_1.NOTE_RELATION);\n            const promises = messagesNodes.map((el) => __awaiter(this, void 0, void 0, function* () {\n                const element = yield el.getElement();\n                return {\n                    element: element,\n                    selectedNode: el,\n                };\n            }));\n            return Promise.all(promises);\n        });\n    }\n    /**\n     * @param {SpinalNote} element\n     * @param {string} note\n     * @return {*}  {SpinalNote}\n     * @memberof NoteService\n     */\n    editNote(element, note) {\n        let date = new Date();\n        element.message.set(note);\n        element.date.set(date);\n        return element;\n    }\n    /**\n     * @param {SpinalNode<any>} noteNode\n     * @param {string} [contextId]\n     * @param {string} [groupId]\n     * @return {*}  {Promise<{ old_group: string; newGroup: string }>}\n     * @memberof NoteService\n     */\n    addNoteToContext(noteNode, contextId, groupId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            //@ts-ignore\n            spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(noteNode);\n            if (typeof contextId === 'undefined') {\n                const noteContext = yield this.createDefaultContext();\n                contextId = noteContext.getId().get();\n            }\n            if (typeof groupId === 'undefined') {\n                const groupNode = yield this.createDefaultGroup();\n                groupId = groupNode.getId().get();\n            }\n            return this.linkNoteToGroup(contextId, groupId, noteNode.getId().get());\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} noteContext\n     * @param {SpinalNode<any>} startNode\n     * @return {*}  {Promise<SpinalNode<any>[]>}\n     * @memberof NoteService\n     */\n    getNotesInNoteContext(noteContext, startNode) {\n        return startNode.findInContext(noteContext, (node) => {\n            let type = node.getType().get();\n            if (type === constants_1.NOTE_TYPE) {\n                //@ts-ignore\n                spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(node);\n                return true;\n            }\n        });\n    }\n    /**\n     * @param {(SpinalNode<any> | SpinalNode<any>[])} notes\n     * @return {*}  {Promise<{ [key: string]: SpinalNode<any>[] }>}\n     * @memberof NoteService\n     */\n    getNotesReferencesNodes(notes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!Array.isArray(notes))\n                notes = [notes];\n            const obj = {};\n            const promises = notes.map((note) => __awaiter(this, void 0, void 0, function* () {\n                obj[note.getId().get()] = yield note.getParents(constants_1.NOTE_RELATION);\n                return;\n            }));\n            yield Promise.all(promises);\n            return obj;\n        });\n    }\n    /**\n     * Deletes a note from a node\n     * @param {SpinalNode<any>} node node to delete from\n     * @param {SpinalNode<any>} note note to delete\n     * @memberof NoteService\n     */\n    delNote(node, note) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(node instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('Node must be a SpinalNode.');\n            if (!(note instanceof spinal_env_viewer_graph_service_1.SpinalNode))\n                throw new Error('Note must be a SpinalNode.');\n            yield node.removeChild(note, constants_1.NOTE_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n        });\n    }\n    /**\n     * @param {string} contextId\n     * @param {string} groupId\n     * @param {string} noteId\n     * @return {*}  {Promise<{ old_group: string; newGroup: string }>}\n     * @memberof NoteService\n     */\n    linkNoteToGroup(contextId, groupId, noteId) {\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.linkElementToGroup(contextId, groupId, noteId);\n    }\n    /**\n     * @return {*}  {Promise<SpinalNodeRef>}\n     * @memberof NoteService\n     */\n    createDefaultContext() {\n        return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.createGroupContext(constants_1.NOTE_CONTEXT_NAME, constants_1.NOTE_TYPE);\n    }\n    /**\n     * @return {*}  {Promise<SpinalNodeRef>}\n     * @memberof NoteService\n     */\n    createDefaultCategory() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const context = yield this.createDefaultContext();\n            return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.addCategory(context.getId().get(), constants_1.NOTE_CATEGORY_NAME, 'add');\n        });\n    }\n    /**\n     * @return {*}  {Promise<SpinalNodeRef>}\n     * @memberof NoteService\n     */\n    createDefaultGroup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const context = yield this.createDefaultContext();\n            const category = yield this.createDefaultCategory();\n            return spinal_env_viewer_plugin_group_manager_service_1.groupManagerService.addGroup(context.getId().get(), category.getId().get(), constants_1.NOTE_GROUP_NAME, '#FFF000');\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} spinalNode\n     * @param {SpinalNote} spinalNote\n     * @return {*}  {Promise<SpinalAttribute[]>}\n     * @memberof NoteService\n     */\n    createAttribute(spinalNode, spinalNote) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const categoryName = 'default';\n            const service = globalType.spinal.serviceDocumentation;\n            if (service) {\n                const category = yield service.addCategoryAttribute(spinalNode, categoryName);\n                const promises = spinalNote._attribute_names.map((key) => {\n                    return service.addAttributeByCategory(spinalNode, category, key, spinalNote[key].get());\n                });\n                return Promise.all(promises);\n            }\n        });\n    }\n    /**\n     * @private\n     * @param {SpinalNode<any>} noteNode\n     * @param {(any | any[])} files\n     * @return {*}  {Promise<IFileNote[]>}\n     * @memberof NoteService\n     */\n    addFilesInDirectory(noteNode, files) {\n        if (!Array.isArray(files))\n            files = [files];\n        const promises = files.map((file) => __awaiter(this, void 0, void 0, function* () {\n            return {\n                viewPoint: {\n                    viewState: file.viewState,\n                    objectState: file.objectState,\n                },\n                file: file,\n                directory: yield FileExplorer_1.FileExplorer._getOrCreateFileDirectory(noteNode),\n            };\n        }));\n        return Promise.all(promises);\n    }\n}\nexports.NoteService = NoteService;\nconst noteService = new NoteService();\nexports.noteService = noteService;\nexports.default = NoteService;\n//# sourceMappingURL=NoteService.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport type {\n  SpinalContext,\n  SpinalNodeRef,\n} from 'spinal-env-viewer-graph-service';\nimport {\n  SpinalNode,\n  SpinalGraphService,\n  SPINAL_RELATION_PTR_LST_TYPE,\n} from 'spinal-env-viewer-graph-service';\nimport { groupManagerService } from 'spinal-env-viewer-plugin-group-manager-service';\nimport { SpinalNote } from 'spinal-models-documentation';\nimport type {\n  ViewStateInterface,\n  SpinalAttribute,\n} from 'spinal-models-documentation';\n\nimport type { IFileNote } from '../interfaces';\nimport {\n  NOTE_CATEGORY_NAME,\n  NOTE_CONTEXT_NAME,\n  NOTE_GROUP_NAME,\n  NOTE_RELATION,\n  NOTE_TYPE,\n} from './constants';\nimport { FileExplorer } from './FileExplorer';\n\nconst globalType: any = typeof window === 'undefined' ? global : window;\n\nclass NoteService {\n  constructor() {}\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {{ username: string; userId: number }} userInfo\n   * @param {string} note - Your message or File name\n   * @param {string} [type]\n   * @param {spinal.File} [file] - Spinal File\n   * @param {string} [noteContextId]\n   * @param {string} [noteGroupId]\n   * @param {ViewStateInterface} [viewPoint]\n   * @return {*}  {Promise<SpinalNode<any>>}\n   * @memberof NoteService\n   */\n  public async addNote(\n    node: SpinalNode<any>,\n    userInfo: { username: string; userId: number },\n    note: string,\n    type?: string,\n    file?: spinal.File<spinal.Model>,\n    noteContextId?: string,\n    noteGroupId?: string,\n    viewPoint?: ViewStateInterface\n  ): Promise<SpinalNode<any>> {\n    if (!(node instanceof SpinalNode)) throw 'node must be a SpinalNode';\n    if (file && !(file instanceof spinal.File))\n      throw 'File must be a SpinalFile';\n\n    const spinalNote = new SpinalNote(\n      userInfo.username,\n      note,\n      userInfo.userId?.toString(),\n      type,\n      file,\n      viewPoint\n    );\n\n    const noteNode = new SpinalNode(\n      `message-${Date.now()}`,\n      NOTE_TYPE,\n      spinalNote\n    );\n    await node.addChild(noteNode, NOTE_RELATION, SPINAL_RELATION_PTR_LST_TYPE);\n\n    // if (noteNode instanceof SpinalNode) {\n    //   noteNode.info.name.set(`message-${Date.now()}`);\n    //   noteNode.info.type.set(NOTE_TYPE);\n    // }\n\n    await this.createAttribute(noteNode, spinalNote);\n    await this.addNoteToContext(noteNode, noteContextId, noteGroupId);\n\n    return noteNode;\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {*} files\n   * @param {{ username: string; userId: number }} userInfo\n   * @param {string} [noteContextId]\n   * @param {string} [noteGroupId]\n   * @return {*}  {Promise<SpinalNode<any>[]>}\n   * @memberof NoteService\n   */\n  public async addFileAsNote(\n    node: SpinalNode<any>,\n    files: File | File[] | FileList | any,\n    userInfo: { username: string; userId: number },\n    noteContextId?: string,\n    noteGroupId?: string\n  ): Promise<SpinalNode<any>[]> {\n    if (typeof FileList !== 'undefined' && files instanceof FileList)\n      files = Array.from(files);\n    const res = await this.addFilesInDirectory(node, files);\n    const promises = res.map(\n      (data: { viewPoint: any; file: any; directory: any }) => {\n        const type = FileExplorer._getFileType(data.file);\n\n        let files_1 = FileExplorer.addFileUpload(data.directory, [data.file]);\n        let file_1 = files_1.length > 0 ? files_1[0] : undefined;\n\n        const viewPoint =\n          Object.keys(data.viewPoint).length > 0 ? data.viewPoint : undefined;\n\n        return this.addNote(\n          node,\n          userInfo,\n          data.file.name,\n          type,\n          file_1,\n          noteContextId,\n          noteGroupId,\n          viewPoint\n        );\n      }\n    );\n    return await Promise.all(promises);\n  }\n\n  /**\n   * Adding a note to a node\n   *\n   * @param {SpinalNode<any>} node node to add the note to\n   * @param {{ username: string, userId: number }} userInfo information of the user posting the note\n   * @param {string} note note to add\n   * @param {string} [type] type of the note\n   * @param {File} [file] file to add to the node\n   * @param {ViewStateInterface} [viewPoint] viewpoint to save in the note\n   * @param {string} [noteContextId] contextID of the note\n   * @param {string} [noteGroupId] groupID of the note\n   * @return {*} {Promise<SpinalNode<any>>} note as a node\n   * @memberof NoteService\n   */\n  public async twinAddNote(\n    node: SpinalNode<any>,\n    userInfo: { username: string; userId: number },\n    note: string,\n    type?: string,\n    file?: File,\n    viewPoint?: ViewStateInterface,\n    noteContextId?: string,\n    noteGroupId?: string\n  ): Promise<SpinalNode<any>> {\n    if (!(node instanceof SpinalNode)) return;\n\n    let uploaded = undefined;\n    if (typeof file !== 'undefined') {\n      uploaded = FileExplorer.addFileUpload(\n        await FileExplorer._getOrCreateFileDirectory(node),\n        [file]\n      );\n    }\n\n    let view = undefined;\n    if (typeof viewPoint !== 'undefined') {\n      view = Object.keys(viewPoint).length > 0 ? viewPoint : undefined;\n    }\n\n    const spinalNote = new SpinalNote(\n      userInfo.username,\n      note,\n      userInfo.userId?.toString(),\n      type,\n      uploaded[0],\n      view\n    );\n    const spinalNode = await node.addChild(\n      spinalNote,\n      NOTE_RELATION,\n      SPINAL_RELATION_PTR_LST_TYPE\n    );\n\n    if (spinalNode && spinalNode.info) {\n      spinalNode.info.name.set(`message-${Date.now()}`);\n      spinalNode.info.type.set(NOTE_TYPE);\n    }\n\n    await this.createAttribute(spinalNode, spinalNote);\n\n    (<any>SpinalGraphService)._addNode(spinalNode);\n\n    let contextId = noteContextId;\n    let groupId = noteGroupId;\n\n    if (typeof contextId === 'undefined') {\n      const noteContext = await this.createDefaultContext();\n      contextId = noteContext.getId().get();\n    }\n\n    if (typeof groupId === 'undefined') {\n      const groupNode = await this.createDefaultGroup();\n      groupId = groupNode.getId().get();\n    }\n\n    await this.linkNoteToGroup(contextId, groupId, spinalNode.getId().get());\n\n    return spinalNode;\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<{ element: SpinalNote; selectedNode: SpinalNode<any> }[]>}\n   * @memberof NoteService\n   */\n  public async getNotes(\n    node: SpinalNode<any>\n  ): Promise<{ element: SpinalNote; selectedNode: SpinalNode<any> }[]> {\n    if (!(node instanceof SpinalNode)) return;\n    const messagesNodes = await node.getChildren(NOTE_RELATION);\n\n    const promises = messagesNodes.map(async (el) => {\n      const element = await el.getElement();\n      return {\n        element: element,\n        selectedNode: el,\n      };\n    });\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * @param {SpinalNote} element\n   * @param {string} note\n   * @return {*}  {SpinalNote}\n   * @memberof NoteService\n   */\n  public editNote(element: SpinalNote, note: string): SpinalNote {\n    let date = new Date();\n    element.message.set(note);\n    element.date.set(date);\n\n    return element;\n  }\n\n  /**\n   * @param {SpinalNode<any>} noteNode\n   * @param {string} [contextId]\n   * @param {string} [groupId]\n   * @return {*}  {Promise<{ old_group: string; newGroup: string }>}\n   * @memberof NoteService\n   */\n  public async addNoteToContext(\n    noteNode: SpinalNode<any>,\n    contextId?: string,\n    groupId?: string\n  ): Promise<{ old_group: string; newGroup: string }> {\n    //@ts-ignore\n    SpinalGraphService._addNode(noteNode);\n\n    if (typeof contextId === 'undefined') {\n      const noteContext = await this.createDefaultContext();\n      contextId = noteContext.getId().get();\n    }\n\n    if (typeof groupId === 'undefined') {\n      const groupNode = await this.createDefaultGroup();\n      groupId = groupNode.getId().get();\n    }\n\n    return this.linkNoteToGroup(contextId, groupId, noteNode.getId().get());\n  }\n\n  /**\n   * @param {SpinalNode<any>} noteContext\n   * @param {SpinalNode<any>} startNode\n   * @return {*}  {Promise<SpinalNode<any>[]>}\n   * @memberof NoteService\n   */\n  public getNotesInNoteContext(\n    noteContext: SpinalNode<any>,\n    startNode: SpinalNode<any>\n  ): Promise<SpinalNode<any>[]> {\n    return startNode.findInContext(noteContext, (node) => {\n      let type = node.getType().get();\n      if (type === NOTE_TYPE) {\n        //@ts-ignore\n        SpinalGraphService._addNode(node);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * @param {(SpinalNode<any> | SpinalNode<any>[])} notes\n   * @return {*}  {Promise<{ [key: string]: SpinalNode<any>[] }>}\n   * @memberof NoteService\n   */\n  public async getNotesReferencesNodes(\n    notes: SpinalNode<any> | SpinalNode<any>[]\n  ): Promise<{ [key: string]: SpinalNode<any>[] }> {\n    if (!Array.isArray(notes)) notes = [notes];\n    const obj = {};\n    const promises = notes.map(async (note) => {\n      obj[note.getId().get()] = await note.getParents(NOTE_RELATION);\n      return;\n    });\n\n    await Promise.all(promises);\n    return obj;\n  }\n\n  /**\n   * Deletes a note from a node\n   * @param {SpinalNode<any>} node node to delete from\n   * @param {SpinalNode<any>} note note to delete\n   * @memberof NoteService\n   */\n  public async delNote(\n    node: SpinalNode<any>,\n    note: SpinalNode<any>\n  ): Promise<void> {\n    if (!(node instanceof SpinalNode))\n      throw new Error('Node must be a SpinalNode.');\n    if (!(note instanceof SpinalNode))\n      throw new Error('Note must be a SpinalNode.');\n\n    await node.removeChild(note, NOTE_RELATION, SPINAL_RELATION_PTR_LST_TYPE);\n  }\n\n  /**\n   * @param {string} contextId\n   * @param {string} groupId\n   * @param {string} noteId\n   * @return {*}  {Promise<{ old_group: string; newGroup: string }>}\n   * @memberof NoteService\n   */\n  public linkNoteToGroup(\n    contextId: string,\n    groupId: string,\n    noteId: string\n  ): Promise<{ old_group: string; newGroup: string }> {\n    return groupManagerService.linkElementToGroup(contextId, groupId, noteId);\n  }\n\n  /**\n   * @return {*}  {Promise<SpinalNodeRef>}\n   * @memberof NoteService\n   */\n  public createDefaultContext(): Promise<SpinalContext> {\n    return groupManagerService.createGroupContext(NOTE_CONTEXT_NAME, NOTE_TYPE);\n  }\n\n  /**\n   * @return {*}  {Promise<SpinalNodeRef>}\n   * @memberof NoteService\n   */\n  public async createDefaultCategory(): Promise<SpinalNode> {\n    const context = await this.createDefaultContext();\n    return groupManagerService.addCategory(\n      context.getId().get(),\n      NOTE_CATEGORY_NAME,\n      'add'\n    );\n  }\n\n  /**\n   * @return {*}  {Promise<SpinalNodeRef>}\n   * @memberof NoteService\n   */\n  public async createDefaultGroup(): Promise<SpinalNode> {\n    const context = await this.createDefaultContext();\n    const category = await this.createDefaultCategory();\n\n    return groupManagerService.addGroup(\n      context.getId().get(),\n      category.getId().get(),\n      NOTE_GROUP_NAME,\n      '#FFF000'\n    );\n  }\n\n  /**\n   * @param {SpinalNode<any>} spinalNode\n   * @param {SpinalNote} spinalNote\n   * @return {*}  {Promise<SpinalAttribute[]>}\n   * @memberof NoteService\n   */\n  public async createAttribute(\n    spinalNode: SpinalNode<any>,\n    spinalNote: SpinalNote\n  ): Promise<SpinalAttribute[]> {\n    const categoryName: string = 'default';\n    const service = globalType.spinal.serviceDocumentation;\n    if (service) {\n      const category = await service.addCategoryAttribute(\n        spinalNode,\n        categoryName\n      );\n\n      const promises = spinalNote._attribute_names.map((key) => {\n        return service.addAttributeByCategory(\n          spinalNode,\n          category,\n          key,\n          spinalNote[key].get()\n        );\n      });\n\n      return Promise.all(promises);\n    }\n  }\n\n  /**\n   * @private\n   * @param {SpinalNode<any>} noteNode\n   * @param {(any | any[])} files\n   * @return {*}  {Promise<IFileNote[]>}\n   * @memberof NoteService\n   */\n  private addFilesInDirectory(\n    noteNode: SpinalNode<any>,\n    files: File | File[] | any\n  ): Promise<IFileNote[]> {\n    if (!Array.isArray(files)) files = [files];\n\n    const promises = files.map(async (file): Promise<IFileNote> => {\n      return {\n        viewPoint: {\n          viewState: file.viewState,\n          objectState: file.objectState,\n        },\n        file: file,\n        directory: await FileExplorer._getOrCreateFileDirectory(noteNode),\n      };\n    });\n\n    return Promise.all(promises);\n  }\n}\n\nconst noteService = new NoteService();\n\nexport { NoteService, noteService };\nexport default NoteService;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileExplorer = void 0;\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_models_documentation_1 = require(\"spinal-models-documentation\");\nclass FileExplorer {\n    /**\n     * @static\n     * @param {SpinalNode<any>} selectedNode\n     * @return {*}  {Promise<spinal.Directory<spinal.File<spinal.Path>>>}\n     * @memberof FileExplorer\n     */\n    static getDirectory(selectedNode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (selectedNode != undefined) {\n                const fileNode = yield selectedNode.getChildren('hasFiles');\n                if (fileNode.length == 0) {\n                    return undefined;\n                }\n                else {\n                    let directory = yield fileNode[0].getElement();\n                    return directory;\n                }\n            }\n        });\n    }\n    /**\n     * @static\n     * @param {SpinalNode<any>} selectedNode\n     * @return {*}  {Promise<number>}\n     * @memberof FileExplorer\n     */\n    static getNbChildren(selectedNode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const fileNode = yield selectedNode.getChildren('hasFiles');\n            return fileNode.length;\n        });\n    }\n    static createDirectory(selectedNode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let nbNode = yield this.getNbChildren(selectedNode);\n            if (nbNode == 0) {\n                let myDirectory = new spinal_core_connectorjs_type_1.Directory();\n                let node = yield selectedNode.addChild(myDirectory, 'hasFiles', spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n                node.info.name.set('[Files]');\n                node.info.type.set('SpinalFiles');\n                return myDirectory;\n            }\n            else {\n                return this.getDirectory(selectedNode);\n            }\n        });\n    }\n    /**\n     * @static\n     * @param {File} file - HTML File\n     * @return {*}  {string}\n     * @memberof FileExplorer\n     */\n    static _getFileType(file) {\n        const imagesExtension = [\n            'JPG',\n            'PNG',\n            'GIF',\n            'WEBP',\n            'TIFF',\n            'PSD',\n            'RAW',\n            'BMP',\n            'HEIF',\n            'INDD',\n            'JPEG 2000',\n            'SVG',\n        ];\n        const extension = /[^.]+$/.exec(file.name)[0];\n        return imagesExtension.indexOf(extension.toUpperCase()) !== -1\n            ? spinal_models_documentation_1.MESSAGE_TYPES.image\n            : spinal_models_documentation_1.MESSAGE_TYPES.file;\n    }\n    /**\n     * @static\n     * @param {spinal.Directory<any>} directory\n     * @param {((File | { name: string; buffer: Buffer })[] | FileList | any)} files - HTML Files\n     * @return {*}  {spinal.File<any>[]}\n     * @memberof FileExplorer\n     */\n    static addFileUpload(directory, files) {\n        const isFileList = typeof FileList !== 'undefined' && files instanceof FileList;\n        if (!isFileList && !Array.isArray(files))\n            files = [files];\n        console.log(\"files\", files);\n        const res = [];\n        for (let i = 0; i < files.length; i++) {\n            const element = files[i];\n            let filePath = element.buffer\n                ? new spinal_core_connectorjs_type_1.Path(element.buffer)\n                : new spinal_core_connectorjs_type_1.Path(element);\n            let myFile = new spinal_core_connectorjs_type_1.File(element.name, filePath, undefined);\n            directory.push(myFile);\n            res.push(myFile);\n        }\n        return res;\n    }\n    /**\n     * @static\n     * @param {SpinalNode<any>} node\n     * @param {((File | { name: string; buffer: Buffer })[] | FileList | any)} files - HTML Files\n     * @return {*}  {Promise<spinal.File<any>[]>}\n     * @memberof FileExplorer\n     */\n    static uploadFiles(node, files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const isFileList = typeof FileList !== 'undefined' && files instanceof FileList;\n            if (!isFileList && !Array.isArray(files))\n                files = [files];\n            const directory = yield this._getOrCreateFileDirectory(node);\n            return this.addFileUpload(directory, files);\n        });\n    }\n    static _getOrCreateFileDirectory(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let directory = yield FileExplorer.getDirectory(node);\n            if (!directory) {\n                directory = yield FileExplorer.createDirectory(node);\n            }\n            return directory;\n        });\n    }\n}\nexports.FileExplorer = FileExplorer;\n//# sourceMappingURL=FileExplorer.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport {\n  Directory,\n  File as spinalFile,\n  Path,\n} from 'spinal-core-connectorjs_type';\nimport {\n  SpinalNode,\n  SPINAL_RELATION_PTR_LST_TYPE,\n} from 'spinal-env-viewer-graph-service';\nimport { MESSAGE_TYPES } from 'spinal-models-documentation';\n\nexport class FileExplorer {\n  /**\n   * @static\n   * @param {SpinalNode<any>} selectedNode\n   * @return {*}  {Promise<spinal.Directory<spinal.File<spinal.Path>>>}\n   * @memberof FileExplorer\n   */\n  public static async getDirectory(\n    selectedNode: SpinalNode<any>\n  ): Promise<spinal.Directory<spinal.File<spinal.Path>>> {\n    if (selectedNode != undefined) {\n      const fileNode = await selectedNode.getChildren('hasFiles');\n      if (fileNode.length == 0) {\n        return undefined;\n      } else {\n        let directory = await fileNode[0].getElement();\n        return directory;\n      }\n    }\n  }\n\n  /**\n   * @static\n   * @param {SpinalNode<any>} selectedNode\n   * @return {*}  {Promise<number>}\n   * @memberof FileExplorer\n   */\n  public static async getNbChildren(\n    selectedNode: SpinalNode<any>\n  ): Promise<number> {\n    const fileNode = await selectedNode.getChildren('hasFiles');\n    return fileNode.length;\n  }\n\n  public static async createDirectory(\n    selectedNode: SpinalNode<any>\n  ): Promise<spinal.Directory<any>> {\n    let nbNode = await this.getNbChildren(selectedNode);\n    if (nbNode == 0) {\n      let myDirectory = new Directory();\n      let node = await selectedNode.addChild(\n        myDirectory,\n        'hasFiles',\n        SPINAL_RELATION_PTR_LST_TYPE\n      );\n      node.info.name.set('[Files]');\n      node.info.type.set('SpinalFiles');\n      return myDirectory;\n    } else {\n      return this.getDirectory(selectedNode);\n    }\n  }\n\n  /**\n   * @static\n   * @param {File} file - HTML File\n   * @return {*}  {string}\n   * @memberof FileExplorer\n   */\n  public static _getFileType(file: File): string {\n    const imagesExtension = [\n      'JPG',\n      'PNG',\n      'GIF',\n      'WEBP',\n      'TIFF',\n      'PSD',\n      'RAW',\n      'BMP',\n      'HEIF',\n      'INDD',\n      'JPEG 2000',\n      'SVG',\n    ];\n    const extension = /[^.]+$/.exec(file.name)[0];\n\n    return imagesExtension.indexOf(extension.toUpperCase()) !== -1\n      ? MESSAGE_TYPES.image\n      : MESSAGE_TYPES.file;\n  }\n\n  /**\n   * @static\n   * @param {spinal.Directory<any>} directory\n   * @param {((File | { name: string; buffer: Buffer })[] | FileList | any)} files - HTML Files\n   * @return {*}  {spinal.File<any>[]}\n   * @memberof FileExplorer\n   */\n  public static addFileUpload(\n    directory: spinal.Directory<any>,\n    files: (spinalFile | { name: string; buffer: Buffer })[] | FileList | any\n  ): spinal.File<any>[] {\n    const isFileList = typeof FileList !== 'undefined' && files instanceof FileList;\n\n    if (!isFileList && !Array.isArray(files)) files = [files];\n\n    console.log(\"files\", files)\n    const res = [];\n\n    for (let i = 0; i < files.length; i++) {\n      const element = files[i];\n\n      let filePath: spinal.Path = element.buffer\n        ? new Path(element.buffer)\n        : new Path(element);\n      let myFile = new spinalFile(element.name, filePath, undefined);\n\n      directory.push(myFile);\n      res.push(myFile);\n    }\n\n    return res;\n  }\n\n  /**\n   * @static\n   * @param {SpinalNode<any>} node\n   * @param {((File | { name: string; buffer: Buffer })[] | FileList | any)} files - HTML Files\n   * @return {*}  {Promise<spinal.File<any>[]>}\n   * @memberof FileExplorer\n   */\n  public static async uploadFiles(\n    node: SpinalNode<any>,\n    files: (spinalFile | { name: string; buffer: Buffer })[] | FileList | any\n  ): Promise<spinal.File<any>[]> {\n    const isFileList = typeof FileList !== 'undefined' && files instanceof FileList;\n    if (!isFileList && !Array.isArray(files)) files = [files];\n\n    const directory = await this._getOrCreateFileDirectory(node);\n    return this.addFileUpload(directory, files);\n  }\n\n  public static async _getOrCreateFileDirectory(\n    node: SpinalNode<any>\n  ): Promise<spinal.Directory<any>> {\n    let directory = await FileExplorer.getDirectory(node);\n\n    if (!directory) {\n      directory = await FileExplorer.createDirectory(node);\n    }\n\n    return directory;\n  }\n}\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.urlService = exports.UrlService = void 0;\nconst spinal_model_graph_1 = require(\"spinal-model-graph\");\nconst spinal_models_documentation_1 = require(\"spinal-models-documentation\");\nconst constants_1 = require(\"./constants\");\nclass UrlService {\n    constructor() { }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {string} urlName\n     * @param {string} urlLink\n     * @return {*}  {Promise<IUrl>}\n     * @memberof UrlService\n     */\n    addURL(node, urlName, urlLink) {\n        return __awaiter(this, void 0, void 0, function* () {\n            urlName = urlName && urlName.toString().trim();\n            urlLink = urlLink && urlLink.toString().trim();\n            const urlNameIsValid = urlName && urlName.length > 0;\n            const urlLinkIsValid = urlLink && urlLink.length > 0;\n            if (!(urlNameIsValid && urlLinkIsValid))\n                throw new Error('name or link is invalid');\n            const urlExist = yield this.getURL(node, urlName);\n            if (urlExist)\n                throw new Error(`${urlName} already exist in ${node.getName().get()}`);\n            const urlModel = new spinal_models_documentation_1.SpinalURL(urlName, urlLink);\n            const urlNode = yield node.addChild(urlModel, constants_1.URL_RELATION, spinal_model_graph_1.SPINAL_RELATION_PTR_LST_TYPE);\n            if (urlNode && urlNode.info) {\n                urlNode.info.name.set(`[URL] ${urlName}`);\n                urlNode.info.type.set(constants_1.URL_TYPE);\n                return this._getUrlData(urlNode);\n            }\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {string} [urlName]\n     * @return {*}  {(Promise<IUrl | IUrl[]>)}\n     * @memberof UrlService\n     */\n    getURL(node, urlName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const urlNodes = yield node.getChildren(constants_1.URL_RELATION);\n            const promises = [];\n            for (const urlNode of urlNodes) {\n                promises.push(this._getUrlData(urlNode, urlName));\n            }\n            const values = yield Promise.all(promises);\n            if (urlName && urlName.toString().trim().length) {\n                return values.find(({ element }) => {\n                    const elementName = element.name.get();\n                    return elementName.toString().trim() === urlName.toString().trim();\n                });\n            }\n            return values;\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} argNode\n     * @param {string} label\n     * @param {string} newValue\n     * @return {*}  {Promise<IUrl>}\n     * @memberof UrlService\n     */\n    updateUrl(argNode, label, newValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let _url = yield this.getURL(argNode, label);\n            let url = Array.isArray(_url) ? _url[0] : _url;\n            if (url) {\n                const { node, element } = url;\n                if (node && element) {\n                    const elementUrl = element.URL.get();\n                    const _newValue = newValue.toString().trim();\n                    if (!!_newValue && elementUrl.toString().trim() !== _newValue)\n                        element.URL.set(_newValue);\n                }\n                return url;\n            }\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {Array<string>} url_relationNames\n     * @return {*}  {Promise<SpinalNode<any>[]>}\n     * @memberof UrlService\n     */\n    getParents(node, url_relationNames) {\n        return node.getParents(url_relationNames);\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<SpinalNode<any>[]>}\n     * @memberof UrlService\n     */\n    getParentGroup(node) {\n        return this.getParents(node, []);\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @param {string} label\n     * @return {*}  {Promise<void>}\n     * @memberof UrlService\n     */\n    deleteURL(node, label) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = yield this.getURL(node, label);\n            if (Array.isArray(url))\n                return;\n            if (url && url.node) {\n                return url.node.removeFromGraph();\n            }\n        });\n    }\n    /**\n     * @param {SpinalNode<any>} node\n     * @return {*}  {Promise<{ node: SpinalNode<any>; urls: SpinalURL[] }[]>}\n     * @memberof UrlService\n     */\n    getSharedUrls(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const parents = yield node.getParents();\n            const promises = parents.map((parent) => __awaiter(this, void 0, void 0, function* () {\n                let _urls = yield this.getURL(parent);\n                _urls = Array.isArray(_urls) ? _urls : [_urls];\n                return {\n                    node: parent,\n                    urls: _urls.map((el) => el.element),\n                };\n            }));\n            return Promise.all(promises);\n        });\n    }\n    //////////////////////////////////////////////////////////////////////////////////\n    //                                     PRIVATES                                 //\n    //////////////////////////////////////////////////////////////////////////////////\n    /**\n     * @param {*} urlNode\n     * @param {string} [urlName]\n     * @return {*}  {Promise<IUrl>}\n     * @memberof UrlService\n     */\n    _getUrlData(urlNode, urlName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const element = yield urlNode.getElement();\n            return {\n                element: element,\n                node: urlNode,\n            };\n        });\n    }\n}\nexports.UrlService = UrlService;\nconst urlService = new UrlService();\nexports.urlService = urlService;\nexports.default = UrlService;\n//# sourceMappingURL=UrlService.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport { SpinalNode, SPINAL_RELATION_PTR_LST_TYPE } from 'spinal-model-graph';\nimport { SpinalURL } from 'spinal-models-documentation';\nimport type { IUrl } from '../interfaces';\nimport { URL_RELATION, URL_TYPE } from './constants';\n\nclass UrlService {\n  constructor() {}\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {string} urlName\n   * @param {string} urlLink\n   * @return {*}  {Promise<IUrl>}\n   * @memberof UrlService\n   */\n  public async addURL(\n    node: SpinalNode<any>,\n    urlName: string,\n    urlLink: string\n  ): Promise<IUrl> {\n    urlName = urlName && urlName.toString().trim();\n    urlLink = urlLink && urlLink.toString().trim();\n\n    const urlNameIsValid: boolean = urlName && urlName.length > 0;\n    const urlLinkIsValid: boolean = urlLink && urlLink.length > 0;\n    if (!(urlNameIsValid && urlLinkIsValid))\n      throw new Error('name or link is invalid');\n\n    const urlExist = await this.getURL(node, urlName);\n\n    if (urlExist)\n      throw new Error(`${urlName} already exist in ${node.getName().get()}`);\n\n    const urlModel = new SpinalURL(urlName, urlLink);\n\n    const urlNode = await node.addChild(\n      urlModel,\n      URL_RELATION,\n      SPINAL_RELATION_PTR_LST_TYPE\n    );\n\n    if (urlNode && urlNode.info) {\n      urlNode.info.name.set(`[URL] ${urlName}`);\n      urlNode.info.type.set(URL_TYPE);\n      return this._getUrlData(urlNode);\n    }\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {string} [urlName]\n   * @return {*}  {(Promise<IUrl | IUrl[]>)}\n   * @memberof UrlService\n   */\n  public async getURL(\n    node: SpinalNode<any>,\n    urlName?: string\n  ): Promise<IUrl | IUrl[]> {\n    const urlNodes = await node.getChildren(URL_RELATION);\n    const promises = [];\n\n    for (const urlNode of urlNodes) {\n      promises.push(this._getUrlData(urlNode, urlName));\n    }\n\n    const values = await Promise.all(promises);\n    if (urlName && urlName.toString().trim().length) {\n      return values.find(({ element }) => {\n        const elementName = element.name.get();\n        return elementName.toString().trim() === urlName.toString().trim();\n      });\n    }\n    return values;\n  }\n\n  /**\n   * @param {SpinalNode<any>} argNode\n   * @param {string} label\n   * @param {string} newValue\n   * @return {*}  {Promise<IUrl>}\n   * @memberof UrlService\n   */\n  public async updateUrl(\n    argNode: SpinalNode<any>,\n    label: string,\n    newValue: string\n  ): Promise<IUrl> {\n    let _url = await this.getURL(argNode, label);\n    let url = Array.isArray(_url) ? _url[0] : _url;\n\n    if (url) {\n      const { node, element } = url;\n\n      if (node && element) {\n        const elementUrl = element.URL.get();\n        const _newValue = newValue.toString().trim();\n        if (!!_newValue && elementUrl.toString().trim() !== _newValue)\n          element.URL.set(_newValue);\n      }\n\n      return url;\n    }\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {Array<string>} url_relationNames\n   * @return {*}  {Promise<SpinalNode<any>[]>}\n   * @memberof UrlService\n   */\n  public getParents(\n    node: SpinalNode<any>,\n    url_relationNames: Array<string>\n  ): Promise<SpinalNode<any>[]> {\n    return node.getParents(url_relationNames);\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<SpinalNode<any>[]>}\n   * @memberof UrlService\n   */\n  public getParentGroup(node: SpinalNode<any>): Promise<SpinalNode<any>[]> {\n    return this.getParents(node, []);\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @param {string} label\n   * @return {*}  {Promise<void>}\n   * @memberof UrlService\n   */\n  public async deleteURL(node: SpinalNode<any>, label: string): Promise<void> {\n    const url = await this.getURL(node, label);\n    if (Array.isArray(url)) return;\n\n    if (url && url.node) {\n      return url.node.removeFromGraph();\n    }\n  }\n\n  /**\n   * @param {SpinalNode<any>} node\n   * @return {*}  {Promise<{ node: SpinalNode<any>; urls: SpinalURL[] }[]>}\n   * @memberof UrlService\n   */\n  public async getSharedUrls(\n    node: SpinalNode<any>\n  ): Promise<{ node: SpinalNode<any>; urls: SpinalURL[] }[]> {\n    const parents = await node.getParents();\n    const promises = parents.map(async (parent) => {\n      let _urls = await this.getURL(parent);\n      _urls = Array.isArray(_urls) ? _urls : [_urls];\n      return {\n        node: parent,\n        urls: _urls.map((el) => el.element),\n      };\n    });\n\n    return Promise.all(promises);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////\n  //                                     PRIVATES                                 //\n  //////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @param {*} urlNode\n   * @param {string} [urlName]\n   * @return {*}  {Promise<IUrl>}\n   * @memberof UrlService\n   */\n  public async _getUrlData(urlNode: any, urlName?: string): Promise<IUrl> {\n    const element = await urlNode.getElement();\n    return {\n      element: element,\n      node: urlNode,\n    };\n  }\n}\n\nconst urlService = new UrlService();\n\nexport { UrlService, urlService };\nexport default UrlService;\n","\"use strict\";\n/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./attributes/ICategory\"), exports);\n__exportStar(require(\"./attributes/IUrl\"), exports);\n__exportStar(require(\"./notes/IFileNote\"), exports);\n//# sourceMappingURL=index.js.map","/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nexport * from './attributes/ICategory';\nexport * from './attributes/IUrl';\nexport * from './notes/IFileNote';\n","\"use strict\";\n/*\n * Copyright 2022 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ICategory.js.map","/*\n * Copyright 2022 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport type { SpinalNode } from 'spinal-env-viewer-graph-service';\n\nexport interface ICategory {\n  nameCat: string;\n  node: SpinalNode<any>;\n  element: spinal.Lst<any>;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IUrl.js.map","/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport type { SpinalNode } from 'spinal-model-graph';\nimport type { SpinalURL } from 'spinal-models-documentation';\n\nexport interface IUrl {\n  element: SpinalURL;\n  node: SpinalNode<any>;\n}\n","\"use strict\";\n/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IFileNote.js.map","/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\n\n\nexport interface IViewState {\n  viewState: string;\n  objectState: string;\n}\n\nexport interface IFileNote {\n  viewPoint?: IViewState;\n  file: File;\n  directory: spinal.Directory<any>;\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalTimeSeries = void 0;\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_core_connectorjs_1 = require(\"spinal-core-connectorjs\");\nconst genUID_1 = require(\"../utils/genUID\");\nconst loadPtr_1 = require(\"../utils/loadPtr\");\nconst SpinalTimeSeriesArchive_1 = require(\"./SpinalTimeSeriesArchive\");\nconst SpinalTimeSeriesConfig_1 = require(\"../SpinalTimeSeriesConfig\");\n/**\n * @class SpinalTimeSeries\n * @property {Str} id\n * @property {Val} maxDay\n * @property {Ptr<SpinalTimeSeriesArchive>} archive\n * @property {Ptr<SpinalTimeSeriesArchiveDay>} currentArchive\n * @extends {Model}\n */\nclass SpinalTimeSeries extends spinal_core_connectorjs_1.Model {\n    /**\n     * Creates an instance of SpinalTimeSeries.\n     * @param {number} [initialBlockSize=SpinalTimeSeriesConfig.INIT_BLOCK_SIZE]\n     * @param {number} [maxDay=SpinalTimeSeriesConfig.MAX_DAY] number of days to keep, default 2 days\n     * ```\n     * 0 = keep infinitly\n     * > 0 = nbr of day to keep\n     * ```\n     * @memberof SpinalTimeSeries\n     */\n    constructor(initialBlockSize = SpinalTimeSeriesConfig_1.SpinalTimeSeriesConfig.INIT_BLOCK_SIZE, maxDay = SpinalTimeSeriesConfig_1.SpinalTimeSeriesConfig.MAX_DAY) {\n        super();\n        this.archiveProm = null;\n        this.currentProm = null;\n        this.loadPtrDictionary = new Map();\n        if (spinal_core_connectorjs_1.FileSystem._sig_server === false)\n            return;\n        const archive = new SpinalTimeSeriesArchive_1.SpinalTimeSeriesArchive(initialBlockSize);\n        this.archiveProm = Promise.resolve(archive);\n        this.add_attr({\n            id: (0, genUID_1.genUID)(),\n            maxDay,\n            archive: new spinal_core_connectorjs_1.Ptr(archive),\n            currentArchive: new spinal_core_connectorjs_1.Ptr(0),\n            currentData: 0,\n        });\n    }\n    /**\n     * @param {(number|string|Date)} [start=0]\n     * @param {(number|string|Date)} [end=Date.now()]\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalTimeSeries\n     */\n    getFromIntervalTimeGen(start = 0, end = Date.now()) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const archive = yield this.getArchive();\n            return archive.getFromIntervalTimeGen(start, end);\n        });\n    }\n    /**\n     * @param {(number|string|Date)} [start=0]\n     * @param {(number|string|Date)} [end=Date.now()]\n     * @returns {Promise<SpinalDateValue[]>}\n     * @memberof SpinalTimeSeries\n     */\n    getFromIntervalTime(start = 0, end = Date.now()) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const archive = yield this.getArchive();\n            return archive.getFromIntervalTime(start, end);\n        });\n    }\n    /**\n     * @returns {Promise<SpinalDateValue>}\n     * @memberof SpinalTimeSeries\n     */\n    getCurrent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.maxDay.get() === 0) {\n                return Promise.resolve({\n                    date: NaN,\n                    value: NaN,\n                });\n            }\n            let currentDay;\n            try {\n                currentDay = yield this.getCurrentDay();\n            }\n            catch (error) {\n                const archive = yield this.getArchive();\n                currentDay = yield archive.getTodayArchive();\n            }\n            const len = currentDay.length.get();\n            return currentDay.get(len - 1);\n        });\n    }\n    setConfig(initialBlockSize, maxDay) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const archive = yield this.getArchive();\n            archive.initialBlockSize.set(initialBlockSize);\n            if (typeof this.maxDay === 'undefined') {\n                this.add_attr('maxDay', maxDay);\n            }\n            else\n                this.maxDay.set(maxDay);\n        });\n    }\n    /**\n     * @param {number} value\n     * @returns {Promise<void>}\n     * @memberof SpinalTimeSeries\n     */\n    push(value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.maxDay.get() === 0) {\n                const archive = yield this.getArchive();\n                archive.purgeArchive(this.maxDay.get());\n                return;\n            }\n            let currentDay;\n            try {\n                currentDay = yield this.getCurrentDay();\n            }\n            catch (error) {\n                const archive = yield this.getArchive();\n                currentDay = yield archive.getTodayArchive();\n            }\n            const normalizedDate = SpinalTimeSeriesArchive_1.SpinalTimeSeriesArchive.normalizeDate(Date.now());\n            const archive = yield this.getArchive();\n            if (currentDay.dateDay.get() !== normalizedDate) {\n                this.currentProm = archive.getTodayArchive();\n                currentDay = yield this.currentProm;\n            }\n            currentDay.push(value);\n            archive.purgeArchive(this.maxDay.get());\n        });\n    }\n    /**\n     * @param {number} value\n     * @returns {Promise<void>}\n     * @memberof SpinalTimeSeries\n     */\n    insert(value, date) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let currentDay;\n            const archive = yield this.getArchive();\n            if (this.maxDay.get() !== 0) {\n                currentDay = yield archive.getOrCreateArchiveAtDate(date);\n                currentDay.insert(value, date);\n            }\n            archive.purgeArchive(this.maxDay.get());\n        });\n    }\n    /**\n     * @param {(number | string | Date)} date\n     * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n     * @memberof SpinalTimeSeries\n     */\n    getDataOfDay(date) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const archive = yield this.getArchive();\n            return archive.getArchiveAtDate(date);\n        });\n    }\n    /**\n     * @returns {Promise<SpinalTimeSeriesArchive>}\n     * @memberof SpinalTimeSeries\n     */\n    getArchive() {\n        if (this.archiveProm !== null)\n            return this.archiveProm;\n        this.archiveProm = ((0, loadPtr_1.loadPtr)(this.loadPtrDictionary, this.archive));\n        return this.archiveProm;\n    }\n    /**\n     * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n     * @memberof SpinalTimeSeries\n     */\n    getCurrentDay() {\n        if (this.currentProm !== null)\n            return this.currentProm;\n        this.currentProm = ((0, loadPtr_1.loadPtr)(this.loadPtrDictionary, this.currentArchive));\n        return this.currentProm;\n    }\n    /**\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalTimeSeries\n     */\n    getDataFromYesterday() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const archive = yield this.getArchive();\n            const end = new Date().setUTCHours(0, 0, 0, -1);\n            const start = new Date(end).setUTCHours(0, 0, 0, 0);\n            return archive.getFromIntervalTimeGen(start, end);\n        });\n    }\n    /**\n     * @alias getDataFromLastDays(1)\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalTimeSeries\n     */\n    getDataFromLast24Hours() {\n        return this.getDataFromLastDays(1);\n    }\n    /**\n     * @param {number} [numberOfHours=1]\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalTimeSeries\n     */\n    getDataFromLastHours(numberOfHours = 1) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const archive = yield this.getArchive();\n            const end = Date.now();\n            const start = new Date();\n            start.setUTCHours(start.getUTCHours() - numberOfHours);\n            return archive.getFromIntervalTimeGen(start, end);\n        });\n    }\n    /**\n     * @param {number} [numberOfDays=1]\n     * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n     * @memberof SpinalTimeSeries\n     */\n    getDataFromLastDays(numberOfDays = 1) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const archive = yield this.getArchive();\n            const end = Date.now();\n            const start = new Date();\n            start.setDate(start.getDate() - numberOfDays);\n            return archive.getFromIntervalTimeGen(start, end);\n        });\n    }\n}\nexports.SpinalTimeSeries = SpinalTimeSeries;\n/**\n * @static\n * @type {string}\n * @memberof SpinalTimeSeries\n */\nSpinalTimeSeries.relationName = 'hasTimeSeries';\n/**\n * @static\n * @type {string}\n * @memberof SpinalTimeSeries\n */\nSpinalTimeSeries.nodeTypeName = 'TimeSeries';\nspinal_core_connectorjs_1.spinalCore.register_models(SpinalTimeSeries);\n//# sourceMappingURL=SpinalTimeSeries.js.map","/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport {\n  FileSystem,\n  Model,\n  Ptr,\n  spinalCore,\n  type Val,\n  type Str,\n} from 'spinal-core-connectorjs';\nimport { genUID } from '../utils/genUID';\nimport { loadPtr } from '../utils/loadPtr';\nimport { SpinalDateValue } from '../interfaces/SpinalDateValue';\nimport { SpinalTimeSeriesArchive } from './SpinalTimeSeriesArchive';\nimport { SpinalTimeSeriesArchiveDay } from './SpinalTimeSeriesArchiveDay';\nimport { SpinalTimeSeriesConfig } from '../SpinalTimeSeriesConfig';\n\n/**\n * @class SpinalTimeSeries\n * @property {Str} id\n * @property {Val} maxDay\n * @property {Ptr<SpinalTimeSeriesArchive>} archive\n * @property {Ptr<SpinalTimeSeriesArchiveDay>} currentArchive\n * @extends {Model}\n */\nexport class SpinalTimeSeries extends Model {\n  /**\n   * @static\n   * @type {string}\n   * @memberof SpinalTimeSeries\n   */\n  public static relationName: string = 'hasTimeSeries';\n  /**\n   * @static\n   * @type {string}\n   * @memberof SpinalTimeSeries\n   */\n  public static nodeTypeName: string = 'TimeSeries';\n\n  public id: Str;\n  public currentArchive: Ptr<SpinalTimeSeriesArchiveDay>;\n  public archive: Ptr<SpinalTimeSeriesArchive>;\n\n  public archiveProm: Promise<SpinalTimeSeriesArchive>;\n  public currentProm: Promise<SpinalTimeSeriesArchiveDay>;\n  private loadPtrDictionary: Map<\n    number,\n    Promise<SpinalTimeSeriesArchiveDay | SpinalTimeSeriesArchive>\n  >;\n  /**\n   * @type {Val} number of days to keep, default 2 days\n   * ```\n   * < 0 = keep infinitly\n   * 0 = no timeseries\n   * > 0 = nbr of day to keep\n   * ```\n   * @memberof SpinalTimeSeries\n   */\n  public maxDay: Val;\n\n  /**\n   * Creates an instance of SpinalTimeSeries.\n   * @param {number} [initialBlockSize=SpinalTimeSeriesConfig.INIT_BLOCK_SIZE]\n   * @param {number} [maxDay=SpinalTimeSeriesConfig.MAX_DAY] number of days to keep, default 2 days\n   * ```\n   * 0 = keep infinitly\n   * > 0 = nbr of day to keep\n   * ```\n   * @memberof SpinalTimeSeries\n   */\n  constructor(\n    initialBlockSize: number = SpinalTimeSeriesConfig.INIT_BLOCK_SIZE,\n    maxDay: number = SpinalTimeSeriesConfig.MAX_DAY\n  ) {\n    super();\n    this.archiveProm = null;\n    this.currentProm = null;\n    this.loadPtrDictionary = new Map();\n    if (FileSystem._sig_server === false) return;\n\n    const archive = new SpinalTimeSeriesArchive(initialBlockSize);\n    this.archiveProm = Promise.resolve(archive);\n\n    this.add_attr({\n      id: genUID(),\n      maxDay,\n      archive: new Ptr(archive),\n      currentArchive: new Ptr(0),\n      currentData: 0,\n    });\n  }\n\n  /**\n   * @param {(number|string|Date)} [start=0]\n   * @param {(number|string|Date)} [end=Date.now()]\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalTimeSeries\n   */\n  public async getFromIntervalTimeGen(\n    start: number | string | Date = 0,\n    end: number | string | Date = Date.now()\n  ): Promise<AsyncIterableIterator<SpinalDateValue>> {\n    const archive = await this.getArchive();\n    return archive.getFromIntervalTimeGen(start, end);\n  }\n  /**\n   * @param {(number|string|Date)} [start=0]\n   * @param {(number|string|Date)} [end=Date.now()]\n   * @returns {Promise<SpinalDateValue[]>}\n   * @memberof SpinalTimeSeries\n   */\n  public async getFromIntervalTime(\n    start: number | string | Date = 0,\n    end: number | string | Date = Date.now()\n  ): Promise<SpinalDateValue[]> {\n    const archive = await this.getArchive();\n    return archive.getFromIntervalTime(start, end);\n  }\n  /**\n   * @returns {Promise<SpinalDateValue>}\n   * @memberof SpinalTimeSeries\n   */\n  public async getCurrent(): Promise<SpinalDateValue> {\n    if (this.maxDay.get() === 0) {\n      return Promise.resolve({\n        date: NaN,\n        value: NaN,\n      });\n    }\n    let currentDay: SpinalTimeSeriesArchiveDay;\n    try {\n      currentDay = await this.getCurrentDay();\n    } catch (error) {\n      const archive = await this.getArchive();\n      currentDay = await archive.getTodayArchive();\n    }\n    const len = currentDay.length.get();\n    return currentDay.get(len - 1);\n  }\n\n  public async setConfig(\n    initialBlockSize: number,\n    maxDay: number\n  ): Promise<void> {\n    const archive = await this.getArchive();\n    archive.initialBlockSize.set(initialBlockSize);\n    if (typeof this.maxDay === 'undefined') {\n      this.add_attr('maxDay', maxDay);\n    } else this.maxDay.set(maxDay);\n  }\n\n  /**\n   * @param {number} value\n   * @returns {Promise<void>}\n   * @memberof SpinalTimeSeries\n   */\n  public async push(value: number): Promise<void> {\n    if (this.maxDay.get() === 0) {\n      const archive = await this.getArchive();\n      archive.purgeArchive(this.maxDay.get());\n      return;\n    }\n    let currentDay: SpinalTimeSeriesArchiveDay;\n    try {\n      currentDay = await this.getCurrentDay();\n    } catch (error) {\n      const archive = await this.getArchive();\n      currentDay = await archive.getTodayArchive();\n    }\n    const normalizedDate: number = SpinalTimeSeriesArchive.normalizeDate(\n      Date.now()\n    );\n    const archive = await this.getArchive();\n    if (currentDay.dateDay.get() !== normalizedDate) {\n      this.currentProm = archive.getTodayArchive();\n      currentDay = await this.currentProm;\n    }\n    currentDay.push(value);\n    archive.purgeArchive(this.maxDay.get());\n  }\n\n  /**\n   * @param {number} value\n   * @returns {Promise<void>}\n   * @memberof SpinalTimeSeries\n   */\n  public async insert(\n    value: number,\n    date: number | string | Date\n  ): Promise<void> {\n    let currentDay: SpinalTimeSeriesArchiveDay;\n    const archive = await this.getArchive();\n    if (this.maxDay.get() !== 0) {\n      currentDay = await archive.getOrCreateArchiveAtDate(date);\n      currentDay.insert(value, date);\n    }\n    archive.purgeArchive(this.maxDay.get());\n  }\n\n  /**\n   * @param {(number | string | Date)} date\n   * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n   * @memberof SpinalTimeSeries\n   */\n  public async getDataOfDay(\n    date: number | string | Date\n  ): Promise<SpinalTimeSeriesArchiveDay> {\n    const archive = await this.getArchive();\n    return archive.getArchiveAtDate(date);\n  }\n\n  /**\n   * @returns {Promise<SpinalTimeSeriesArchive>}\n   * @memberof SpinalTimeSeries\n   */\n  public getArchive(): Promise<SpinalTimeSeriesArchive> {\n    if (this.archiveProm !== null) return this.archiveProm;\n    this.archiveProm = <Promise<SpinalTimeSeriesArchive>>(\n      loadPtr(this.loadPtrDictionary, this.archive)\n    );\n    return this.archiveProm;\n  }\n\n  /**\n   * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n   * @memberof SpinalTimeSeries\n   */\n  public getCurrentDay(): Promise<SpinalTimeSeriesArchiveDay> {\n    if (this.currentProm !== null) return this.currentProm;\n    this.currentProm = <Promise<SpinalTimeSeriesArchiveDay>>(\n      loadPtr(this.loadPtrDictionary, this.currentArchive)\n    );\n    return this.currentProm;\n  }\n\n  /**\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalTimeSeries\n   */\n  public async getDataFromYesterday(): Promise<\n    AsyncIterableIterator<SpinalDateValue>\n  > {\n    const archive = await this.getArchive();\n    const end = new Date().setUTCHours(0, 0, 0, -1);\n    const start = new Date(end).setUTCHours(0, 0, 0, 0);\n    return archive.getFromIntervalTimeGen(start, end);\n  }\n\n  /**\n   * @alias getDataFromLastDays(1)\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalTimeSeries\n   */\n  public getDataFromLast24Hours(): Promise<\n    AsyncIterableIterator<SpinalDateValue>\n  > {\n    return this.getDataFromLastDays(1);\n  }\n\n  /**\n   * @param {number} [numberOfHours=1]\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalTimeSeries\n   */\n  public async getDataFromLastHours(\n    numberOfHours: number = 1\n  ): Promise<AsyncIterableIterator<SpinalDateValue>> {\n    const archive = await this.getArchive();\n    const end = Date.now();\n    const start = new Date();\n    start.setUTCHours(start.getUTCHours() - numberOfHours);\n    return archive.getFromIntervalTimeGen(start, end);\n  }\n  /**\n   * @param {number} [numberOfDays=1]\n   * @returns {Promise<AsyncIterableIterator<SpinalDateValue>>}\n   * @memberof SpinalTimeSeries\n   */\n  public async getDataFromLastDays(\n    numberOfDays: number = 1\n  ): Promise<AsyncIterableIterator<SpinalDateValue>> {\n    const archive = await this.getArchive();\n    const end = Date.now();\n    const start = new Date();\n    start.setDate(start.getDate() - numberOfDays);\n    return archive.getFromIntervalTimeGen(start, end);\n  }\n}\n\nspinalCore.register_models(SpinalTimeSeries);\n","\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.genUID = void 0;\nfunction s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n        .toString(16)\n        .substring(1);\n}\n/**\n * @returns {string}\n */\nfunction genUID() {\n    const res = `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4() + s4()}-${Date.now().toString(16)}`;\n    return res;\n}\nexports.genUID = genUID;\n//# sourceMappingURL=genUID.js.map","/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nfunction s4(): string {\n  return Math.floor((1 + Math.random()) * 0x10000)\n    .toString(16)\n    .substring(1);\n}\n\n/**\n * @returns {string}\n */\nfunction genUID(): string {\n  const res: string = `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${\n    s4() + s4()\n  }-${Date.now().toString(16)}`;\n\n  return res;\n}\n\nexport { genUID };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loadPtr = void 0;\n/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_core_connectorjs_1 = require(\"spinal-core-connectorjs\");\nfunction loadPtr(loadPtrDictionary, ptr) {\n    if (typeof ptr.data.value !== 'undefined' &&\n        loadPtrDictionary.has(ptr.data.value)) {\n        return loadPtrDictionary.get(ptr.data.value);\n    }\n    if (typeof ptr.data.model !== 'undefined') {\n        const res = Promise.resolve(ptr.data.model);\n        if (ptr.data.value) {\n            loadPtrDictionary.set(ptr.data.value, res);\n        }\n        return res;\n    }\n    if (typeof ptr.data.value !== 'undefined' && ptr.data.value === 0) {\n        return Promise.reject('Load Ptr to 0');\n    }\n    if (typeof spinal_core_connectorjs_1.FileSystem._objects[ptr.data.value] !== 'undefined') {\n        const res = Promise.resolve(spinal_core_connectorjs_1.FileSystem._objects[ptr.data.value]);\n        loadPtrDictionary.set(ptr.data.value, res);\n        return Promise.resolve(res);\n    }\n    const res = ptr.load();\n    loadPtrDictionary.set(ptr.data.value, res);\n    return res;\n}\nexports.loadPtr = loadPtr;\n//# sourceMappingURL=loadPtr.js.map","/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport { FileSystem } from 'spinal-core-connectorjs';\n\nexport function loadPtr<T extends spinal.Model>(\n  loadPtrDictionary: Map<number, Promise<T>>,\n  ptr: spinal.Ptr<T>\n): Promise<T> {\n  if (\n    typeof ptr.data.value !== 'undefined' &&\n    loadPtrDictionary.has(ptr.data.value)\n  ) {\n    return loadPtrDictionary.get(ptr.data.value);\n  }\n\n  if (typeof ptr.data.model !== 'undefined') {\n    const res = Promise.resolve(ptr.data.model);\n    if (ptr.data.value) {\n      loadPtrDictionary.set(ptr.data.value, res);\n    }\n    return res;\n  }\n\n  if (typeof ptr.data.value !== 'undefined' && ptr.data.value === 0) {\n    return Promise.reject('Load Ptr to 0');\n  }\n\n  if (typeof FileSystem._objects[ptr.data.value] !== 'undefined') {\n    const res = Promise.resolve(<T>FileSystem._objects[ptr.data.value]);\n    loadPtrDictionary.set(ptr.data.value, res);\n    return Promise.resolve(res);\n  }\n  const res: Promise<T> = ptr.load();\n  loadPtrDictionary.set(ptr.data.value, res);\n  return res;\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalTimeSeriesArchive = void 0;\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_core_connectorjs_1 = require(\"spinal-core-connectorjs\");\nconst loadPtr_1 = require(\"../utils/loadPtr\");\nconst SpinalTimeSeriesArchiveDay_1 = require(\"./SpinalTimeSeriesArchiveDay\");\nconst SpinalTimeSeriesConfig_1 = require(\"../SpinalTimeSeriesConfig\");\n/**\n * @class SpinalTimeSeriesArchive\n * @extends {Model}\n */\nclass SpinalTimeSeriesArchive extends spinal_core_connectorjs_1.Model {\n    /**\n     *Creates an instance of SpinalTimeSeriesArchive.\n     * @param {number} [initialBlockSize=SpinalTimeSeriesConfig.INIT_BLOCK_SIZE]\n     * @memberof SpinalTimeSeriesArchive\n     */\n    constructor(initialBlockSize = SpinalTimeSeriesConfig_1.SpinalTimeSeriesConfig.INIT_BLOCK_SIZE) {\n        super({\n            initialBlockSize,\n            lstDate: [],\n            lstItem: [],\n        });\n        this.itemLoadedDictionary = new Map();\n        this.loadPtrDictionary = new Map();\n    }\n    /**\n     * @static\n     * @param {(number | string | Date)} date\n     * @returns {number}\n     * @memberof SpinalTimeSeriesArchive\n     */\n    static normalizeDate(date) {\n        return new Date(date).setUTCHours(0, 0, 0, 0);\n    }\n    /**\n     * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n     * @memberof SpinalTimeSeriesArchive\n     */\n    getTodayArchive() {\n        this.cleanUpNaNDates();\n        const now = Date.now();\n        const date = SpinalTimeSeriesArchive.normalizeDate(now);\n        const spinalTimeSeriesArchiveDay = this.itemLoadedDictionary.get(date);\n        if (spinalTimeSeriesArchiveDay !== undefined) {\n            return spinalTimeSeriesArchiveDay;\n        }\n        for (let index = 0; index < this.lstDate.length; index += 1) {\n            const element = this.lstDate[index];\n            const ptr = this.lstItem[index];\n            if (element.get() === date) {\n                return (0, loadPtr_1.loadPtr)(this.loadPtrDictionary, ptr);\n            }\n        }\n        const value = new SpinalTimeSeriesArchiveDay_1.SpinalTimeSeriesArchiveDay(this.initialBlockSize.get());\n        this.lstDate.push(date);\n        this.lstItem.push(new spinal_core_connectorjs_1.Ptr(value));\n        const prom = Promise.resolve(value);\n        this.itemLoadedDictionary.set(date, prom);\n        return prom;\n    }\n    /**\n     * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n     * @memberof SpinalTimeSeriesArchive\n     */\n    getOrCreateArchiveAtDate(atDate) {\n        this.cleanUpNaNDates();\n        const date = SpinalTimeSeriesArchive.normalizeDate(atDate);\n        if (isNaN(date)) {\n            throw `the value [${atDate}] is not a valid date`;\n        }\n        const spinalTimeSeriesArchiveDay = this.itemLoadedDictionary.get(date);\n        if (spinalTimeSeriesArchiveDay !== undefined) {\n            return spinalTimeSeriesArchiveDay;\n        }\n        for (let index = 0; index < this.lstDate.length; index += 1) {\n            const element = this.lstDate[index];\n            const ptr = this.lstItem[index];\n            if (element.get() === date) {\n                return (0, loadPtr_1.loadPtr)(this.loadPtrDictionary, ptr);\n            }\n        }\n        const value = new SpinalTimeSeriesArchiveDay_1.SpinalTimeSeriesArchiveDay(this.initialBlockSize.get());\n        value.dateDay.set(date);\n        // search index\n        let index = 0;\n        for (let idx = 0; idx < this.lstDate.length; idx += 1) {\n            const element = this.lstDate[idx];\n            if (element > date) {\n                break;\n            }\n            index += 1;\n        }\n        this.lstDate.insert(index, [date]);\n        this.lstItem.insert(index, [new spinal_core_connectorjs_1.Ptr(value)]);\n        const prom = Promise.resolve(value);\n        this.itemLoadedDictionary.set(date, prom);\n        return prom;\n    }\n    /**\n     * @memberof SpinalTimeSeriesArchive\n     */\n    cleanUpNaNDates() {\n        let idx = 0;\n        while (idx < this.lstDate.length) {\n            const date = this.lstDate[idx];\n            if (date && isNaN(date.get())) {\n                this.lstDate.splice(idx, 1);\n                this.lstItem.splice(idx, 1);\n            }\n            else {\n                ++idx;\n            }\n        }\n    }\n    /**\n     * @param {(number|string)} [start=0]\n     * @param {(number|string)} [end=Date.now()]\n     * @returns {AsyncIterableIterator<SpinalDateValue>}\n     * @memberof SpinalTimeSeriesArchive\n     */\n    getFromIntervalTimeGen(start = 0, end = Date.now()) {\n        return __asyncGenerator(this, arguments, function* getFromIntervalTimeGen_1() {\n            this.cleanUpNaNDates();\n            const normalizedStart = SpinalTimeSeriesArchive.normalizeDate(start);\n            const normalizedEnd = typeof end === 'number' || typeof end === 'string'\n                ? new Date(end).getTime()\n                : end.getTime();\n            if (isNaN(normalizedStart)) {\n                throw `the value 'start' [${start}] is not a valid date`;\n            }\n            if (isNaN(normalizedEnd)) {\n                throw `the value 'end' [${end}] is not a valid date`;\n            }\n            for (let idx = 0; idx < this.lstDate.length; idx += 1) {\n                const element = this.lstDate[idx].get();\n                if (normalizedStart > element)\n                    continue;\n                const archive = yield __await(this.getArchiveAtDate(element));\n                let index = 0;\n                const archiveLen = archive.length.get();\n                if (normalizedStart === element) {\n                    for (; index < archiveLen; index += 1) {\n                        const dateValue = archive.get(index);\n                        if (dateValue.date >= normalizedStart) {\n                            break;\n                        }\n                    }\n                }\n                for (; index < archiveLen; index += 1) {\n                    const dateValue = archive.get(index);\n                    if (dateValue.date > normalizedEnd)\n                        return yield __await(void 0);\n                    yield yield __await(dateValue);\n                }\n            }\n        });\n    }\n    /**\n     * getFromIntervalTimeGen is prefered.\n     * @param {number} start\n     * @param {(number|string)} [end=Date.now()]\n     * @returns {Promise<SpinalDateValue[]>}\n     * @memberof SpinalTimeSeriesArchive\n     */\n    getFromIntervalTime(start, end = Date.now()) {\n        var _a, e_1, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = [];\n            try {\n                for (var _d = true, _e = __asyncValues(this.getFromIntervalTimeGen(start, end)), _f; _f = yield _e.next(), _a = _f.done, !_a;) {\n                    _c = _f.value;\n                    _d = false;\n                    try {\n                        const data = _c;\n                        result.push(data);\n                    }\n                    finally {\n                        _d = true;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return result;\n        });\n    }\n    /**\n     * @param {(number | string | Date)} date\n     * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n     * @memberof SpinalTimeSeriesArchive\n     */\n    getArchiveAtDate(date) {\n        this.cleanUpNaNDates();\n        const normalizedDate = SpinalTimeSeriesArchive.normalizeDate(date);\n        if (isNaN(normalizedDate)) {\n            throw `the value [${date}] is not a valid date`;\n        }\n        if (this.itemLoadedDictionary.has(normalizedDate)) {\n            return this.itemLoadedDictionary.get(normalizedDate);\n        }\n        const idx = this.lstDate.indexOf(normalizedDate);\n        if (idx < 0)\n            return Promise.reject(new Error(`Date '${date}' not fond.`));\n        const promise = getArchive.call(this);\n        this.itemLoadedDictionary.set(normalizedDate, promise);\n        return promise;\n        function getArchive() {\n            return new Promise((resolve) => {\n                const ptr = this.lstItem[idx];\n                if (typeof ptr.data.model !== 'undefined') {\n                    resolve(ptr.data.model);\n                }\n                else {\n                    ptr.load((element) => {\n                        resolve(element);\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * @returns {Lst<Val>}\n     * @memberof SpinalTimeSeriesArchive\n     */\n    getDates() {\n        return this.lstDate;\n    }\n    /**\n     * @param {(number | string | Date)} date\n     * @returns {boolean}\n     * @memberof SpinalTimeSeriesArchive\n     */\n    dateExist(date) {\n        const normalizedDate = SpinalTimeSeriesArchive.normalizeDate(date);\n        for (let idx = this.lstDate.length - 1; idx >= 0; idx -= 1) {\n            if (this.lstDate[idx].get() === normalizedDate)\n                return true;\n        }\n        return false;\n    }\n    purgeArchive(maxDay) {\n        if (maxDay > 0) {\n            let lstDateToDelete = [];\n            const maxDayMS = maxDay * 86400000;\n            const minDateMS = new Date().valueOf() - maxDayMS;\n            for (let index = 0; index < this.lstDate.length; index += 1) {\n                if (this.lstDate[index].get() <= minDateMS) {\n                    lstDateToDelete.push(this.lstDate[index].get());\n                }\n            }\n            for (let elt of lstDateToDelete) {\n                let id = this.lstDate.indexOf(elt);\n                this.lstDate.splice(id, 1);\n                this.lstItem.splice(id, 1);\n            }\n        }\n        else if (maxDay === 0) {\n            this.lstDate.clear();\n            this.lstItem.clear();\n        }\n    }\n}\nexports.SpinalTimeSeriesArchive = SpinalTimeSeriesArchive;\nspinal_core_connectorjs_1.spinalCore.register_models(SpinalTimeSeriesArchive);\n//# sourceMappingURL=SpinalTimeSeriesArchive.js.map","/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport {\n  Model,\n  Ptr,\n  spinalCore,\n  type Lst,\n  type Val,\n} from 'spinal-core-connectorjs';\nimport { loadPtr } from '../utils/loadPtr';\nimport { SpinalTimeSeriesArchiveDay } from './SpinalTimeSeriesArchiveDay';\nimport { SpinalTimeSeriesConfig } from '../SpinalTimeSeriesConfig';\nimport type { SpinalDateValue } from '../interfaces/SpinalDateValue';\n\n/**\n * @class SpinalTimeSeriesArchive\n * @extends {Model}\n */\nexport class SpinalTimeSeriesArchive extends Model {\n  // synchronized\n  private lstDate: Lst<Val>;\n  private lstItem: Lst<Ptr<SpinalTimeSeriesArchiveDay>>;\n  public initialBlockSize: Val;\n\n  // not synchronized\n  private itemLoadedDictionary: Map<\n    number,\n    Promise<SpinalTimeSeriesArchiveDay>\n  >;\n  private loadPtrDictionary: Map<number, Promise<SpinalTimeSeriesArchiveDay>>;\n\n  /**\n   *Creates an instance of SpinalTimeSeriesArchive.\n   * @param {number} [initialBlockSize=SpinalTimeSeriesConfig.INIT_BLOCK_SIZE]\n   * @memberof SpinalTimeSeriesArchive\n   */\n  constructor(\n    initialBlockSize: number = SpinalTimeSeriesConfig.INIT_BLOCK_SIZE\n  ) {\n    super({\n      initialBlockSize,\n      lstDate: [],\n      lstItem: [],\n    });\n\n    this.itemLoadedDictionary = new Map();\n    this.loadPtrDictionary = new Map();\n  }\n\n  /**\n   * @static\n   * @param {(number | string | Date)} date\n   * @returns {number}\n   * @memberof SpinalTimeSeriesArchive\n   */\n  public static normalizeDate(date: number | string | Date): number {\n    return new Date(date).setUTCHours(0, 0, 0, 0);\n  }\n\n  /**\n   * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n   * @memberof SpinalTimeSeriesArchive\n   */\n  public getTodayArchive(): Promise<SpinalTimeSeriesArchiveDay> {\n    this.cleanUpNaNDates();\n    const now = Date.now();\n    const date = SpinalTimeSeriesArchive.normalizeDate(now);\n    const spinalTimeSeriesArchiveDay = this.itemLoadedDictionary.get(date);\n\n    if (spinalTimeSeriesArchiveDay !== undefined) {\n      return spinalTimeSeriesArchiveDay;\n    }\n\n    for (let index = 0; index < this.lstDate.length; index += 1) {\n      const element = this.lstDate[index];\n      const ptr = this.lstItem[index];\n      if (element.get() === date) {\n        return loadPtr(this.loadPtrDictionary, ptr);\n      }\n    }\n    const value = new SpinalTimeSeriesArchiveDay(this.initialBlockSize.get());\n    this.lstDate.push(date);\n    this.lstItem.push(new Ptr(value));\n    const prom = Promise.resolve(value);\n    this.itemLoadedDictionary.set(date, prom);\n    return prom;\n  }\n\n  /**\n   * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n   * @memberof SpinalTimeSeriesArchive\n   */\n  public getOrCreateArchiveAtDate(\n    atDate: number | string | Date\n  ): Promise<SpinalTimeSeriesArchiveDay> {\n    this.cleanUpNaNDates();\n    const date = SpinalTimeSeriesArchive.normalizeDate(atDate);\n    if (isNaN(date)) {\n      throw `the value [${atDate}] is not a valid date`;\n    }\n    const spinalTimeSeriesArchiveDay = this.itemLoadedDictionary.get(date);\n\n    if (spinalTimeSeriesArchiveDay !== undefined) {\n      return spinalTimeSeriesArchiveDay;\n    }\n    for (let index = 0; index < this.lstDate.length; index += 1) {\n      const element = this.lstDate[index];\n      const ptr = this.lstItem[index];\n      if (element.get() === date) {\n        return loadPtr(this.loadPtrDictionary, ptr);\n      }\n    }\n    const value = new SpinalTimeSeriesArchiveDay(this.initialBlockSize.get());\n    value.dateDay.set(date);\n    // search index\n    let index = 0;\n    for (let idx = 0; idx < this.lstDate.length; idx += 1) {\n      const element = this.lstDate[idx];\n      if (element > date) {\n        break;\n      }\n      index += 1;\n    }\n\n    this.lstDate.insert(index, [date]);\n    this.lstItem.insert(index, [new Ptr(value)]);\n    const prom = Promise.resolve(value);\n    this.itemLoadedDictionary.set(date, prom);\n    return prom;\n  }\n\n  /**\n   * @memberof SpinalTimeSeriesArchive\n   */\n  cleanUpNaNDates() {\n    let idx = 0;\n    while (idx < this.lstDate.length) {\n      const date = this.lstDate[idx];\n      if (date && isNaN(date.get())) {\n        this.lstDate.splice(idx, 1);\n        this.lstItem.splice(idx, 1);\n      } else {\n        ++idx;\n      }\n    }\n  }\n\n  /**\n   * @param {(number|string)} [start=0]\n   * @param {(number|string)} [end=Date.now()]\n   * @returns {AsyncIterableIterator<SpinalDateValue>}\n   * @memberof SpinalTimeSeriesArchive\n   */\n  public async *getFromIntervalTimeGen(\n    start: number | string | Date = 0,\n    end: number | string | Date = Date.now()\n  ): AsyncIterableIterator<SpinalDateValue> {\n    this.cleanUpNaNDates();\n    const normalizedStart = SpinalTimeSeriesArchive.normalizeDate(start);\n    const normalizedEnd =\n      typeof end === 'number' || typeof end === 'string'\n        ? new Date(end).getTime()\n        : end.getTime();\n    if (isNaN(normalizedStart)) {\n      throw `the value 'start' [${start}] is not a valid date`;\n    }\n    if (isNaN(normalizedEnd)) {\n      throw `the value 'end' [${end}] is not a valid date`;\n    }\n    for (let idx = 0; idx < this.lstDate.length; idx += 1) {\n      const element = this.lstDate[idx].get();\n      if (normalizedStart > element) continue;\n      const archive = await this.getArchiveAtDate(element);\n      let index = 0;\n      const archiveLen = archive.length.get();\n      if (normalizedStart === element) {\n        for (; index < archiveLen; index += 1) {\n          const dateValue = archive.get(index);\n          if (dateValue.date >= normalizedStart) {\n            break;\n          }\n        }\n      }\n\n      for (; index < archiveLen; index += 1) {\n        const dateValue = archive.get(index);\n        if (dateValue.date > normalizedEnd) return;\n        yield dateValue;\n      }\n    }\n  }\n\n  /**\n   * getFromIntervalTimeGen is prefered.\n   * @param {number} start\n   * @param {(number|string)} [end=Date.now()]\n   * @returns {Promise<SpinalDateValue[]>}\n   * @memberof SpinalTimeSeriesArchive\n   */\n  public async getFromIntervalTime(\n    start: number | string | Date,\n    end: number | string | Date = Date.now()\n  ): Promise<SpinalDateValue[]> {\n    const result = [];\n    for await (const data of this.getFromIntervalTimeGen(start, end)) {\n      result.push(data);\n    }\n    return result;\n  }\n\n  /**\n   * @param {(number | string | Date)} date\n   * @returns {Promise<SpinalTimeSeriesArchiveDay>}\n   * @memberof SpinalTimeSeriesArchive\n   */\n  public getArchiveAtDate(\n    date: number | string | Date\n  ): Promise<SpinalTimeSeriesArchiveDay> {\n    this.cleanUpNaNDates();\n    const normalizedDate: number = SpinalTimeSeriesArchive.normalizeDate(date);\n    if (isNaN(normalizedDate)) {\n      throw `the value [${date}] is not a valid date`;\n    }\n    if (this.itemLoadedDictionary.has(normalizedDate)) {\n      return this.itemLoadedDictionary.get(normalizedDate);\n    }\n    const idx = this.lstDate.indexOf(normalizedDate);\n    if (idx < 0) return Promise.reject(new Error(`Date '${date}' not fond.`));\n\n    const promise: Promise<SpinalTimeSeriesArchiveDay> = getArchive.call(this);\n    this.itemLoadedDictionary.set(normalizedDate, promise);\n    return promise;\n\n    function getArchive(): Promise<SpinalTimeSeriesArchiveDay> {\n      return new Promise((resolve) => {\n        const ptr: Ptr<SpinalTimeSeriesArchiveDay> = this.lstItem[idx];\n        if (typeof ptr.data.model !== 'undefined') {\n          resolve(ptr.data.model);\n        } else {\n          ptr.load((element: SpinalTimeSeriesArchiveDay) => {\n            resolve(element);\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * @returns {Lst<Val>}\n   * @memberof SpinalTimeSeriesArchive\n   */\n  public getDates(): Lst<Val> {\n    return this.lstDate;\n  }\n\n  /**\n   * @param {(number | string | Date)} date\n   * @returns {boolean}\n   * @memberof SpinalTimeSeriesArchive\n   */\n  public dateExist(date: number | string | Date): boolean {\n    const normalizedDate: number = SpinalTimeSeriesArchive.normalizeDate(date);\n    for (let idx = this.lstDate.length - 1; idx >= 0; idx -= 1) {\n      if (this.lstDate[idx].get() === normalizedDate) return true;\n    }\n    return false;\n  }\n\n  public purgeArchive(maxDay: number): void {\n    if (maxDay > 0) {\n      let lstDateToDelete = [];\n      const maxDayMS = maxDay * 86400000;\n      const minDateMS = new Date().valueOf() - maxDayMS;\n      for (let index = 0; index < this.lstDate.length; index += 1) {\n        if (this.lstDate[index].get() <= minDateMS) {\n          lstDateToDelete.push(this.lstDate[index].get());\n        }\n      }\n\n      for (let elt of lstDateToDelete) {\n        let id = this.lstDate.indexOf(elt);\n        this.lstDate.splice(id, 1);\n        this.lstItem.splice(id, 1);\n      }\n    } else if (maxDay === 0) {\n      this.lstDate.clear();\n      this.lstItem.clear();\n    }\n  }\n}\n\nspinalCore.register_models(SpinalTimeSeriesArchive);\n","\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalTimeSeriesArchiveDay = void 0;\nconst spinal_core_connectorjs_1 = require(\"spinal-core-connectorjs\");\n/**\n * @property {Lst<Val>} lstDate\n * @property {Lst<Val>} lstValue\n * @property {Val} length\n * @property {Val} dateDay\n * @class SpinalTimeSeriesArchiveDay\n * @extends {Model}\n */\nclass SpinalTimeSeriesArchiveDay extends spinal_core_connectorjs_1.Model {\n    constructor(initialBlockSize = 50) {\n        super();\n        if (spinal_core_connectorjs_1.FileSystem._sig_server === false)\n            return;\n        this.add_attr({\n            lstDate: new spinal_core_connectorjs_1.Lst(Array(initialBlockSize).fill(0)),\n            lstValue: new spinal_core_connectorjs_1.Lst(Array(initialBlockSize).fill(0)),\n            dateDay: new Date().setUTCHours(0, 0, 0, 0),\n            length: 0,\n        });\n    }\n    /**\n     * @param {number} data\n     * @memberof SpinalTimeSeriesArchiveDay\n     */\n    push(data) {\n        this.upgradeFromOldTimeSeries();\n        if (this.lstDate.length <= this.length.get())\n            this.addBufferSizeLength();\n        this.setLstVal(this.length.get(), Date.now(), data);\n        this.length.set(this.length.get() + 1);\n    }\n    /**\n     * @param {number} data\n     * @param {(number|string|Date)} date\n     * @returns {boolean}\n     * @memberof SpinalTimeSeriesArchiveDay\n     */\n    insert(data, date) {\n        this.upgradeFromOldTimeSeries();\n        const targetDate = new Date(date).getTime();\n        const maxDate = new Date(this.dateDay.get()).setUTCHours(23, 59, 59, 999);\n        if (!(this.dateDay.get() <= targetDate && targetDate <= maxDate))\n            return false;\n        if (this.lstDate.length <= this.length.get())\n            this.addBufferSizeLength();\n        let index = 0;\n        for (; index < this.length.get(); index += 1) {\n            const element = this.lstDate[index].get();\n            if (element === targetDate) {\n                // check exist\n                this.lstValue[index].set(data);\n                return true;\n            }\n            if (element > targetDate)\n                break;\n        }\n        if (index === this.length.get()) {\n            this.setLstVal(this.length.get(), targetDate, data);\n            this.length.set(this.length.get() + 1);\n        }\n        else {\n            for (let idx = this.length.get() - 1; idx >= index; idx -= 1) {\n                this.setLstVal(idx + 1, this.lstDate[idx].get(), this.lstValue[idx].get());\n            }\n            this.setLstVal(index, targetDate, data);\n            this.length.set(this.length.get() + 1);\n        }\n        return true;\n    }\n    setLstVal(idx, date, value) {\n        this.lstDate[idx].set(date);\n        this.lstValue[idx].set(value);\n    }\n    /**\n     * @param {number} [index]\n     * @returns {(SpinalDateValue | SpinalDateValueArray)}\n     * @memberof SpinalTimeSeriesArchiveDay\n     */\n    get(index) {\n        if (typeof index === 'number')\n            return this.at(index);\n        if (this.lstDate instanceof spinal_core_connectorjs_1.TypedArray)\n            return {\n                dateDay: this.dateDay.get(),\n                // @ts-ignore\n                date: this.lstDate.get().subarray(0, this.length.get()),\n                // @ts-ignore\n                value: this.lstValue.get().subarray(0, this.length.get()),\n            };\n        const date = [], value = [];\n        for (let idx = 0; idx < this.length.get(); idx++) {\n            date.push(this.lstDate[idx].get());\n            value.push(this.lstValue[idx].get());\n        }\n        return {\n            dateDay: this.dateDay.get(),\n            date,\n            value,\n        };\n    }\n    /**\n     * alias of 'get' method with index\n     * @param {number} index\n     * @returns {SpinalDateValue}\n     * @memberof SpinalTimeSeriesArchiveDay\n     */\n    at(index) {\n        if (index >= this.length.get() || index < 0) {\n            return undefined;\n        }\n        if (this.lstDate instanceof spinal_core_connectorjs_1.TypedArray) {\n            return {\n                date: this.lstDate.get(index),\n                // @ts-ignore\n                value: this.lstValue.get(index),\n            };\n        }\n        return {\n            date: this.lstDate[index].get(),\n            value: this.lstValue[index].get(),\n        };\n    }\n    /**\n     * For Tests - returns the TypedArrays' size\n     * @memberof SpinalTimeSeriesArchiveDay\n     */\n    getActualBufferSize() {\n        return this.lstDate.length;\n    }\n    /**\n     * @private\n     * @memberof SpinalTimeSeriesArchiveDay\n     */\n    addBufferSizeLength() {\n        this.upgradeFromOldTimeSeries();\n        for (let idx = this.length.get(); idx < this.length.get() * 2; idx++) {\n            this.lstDate.push(0);\n            this.lstValue.push(0);\n        }\n    }\n    upgradeFromOldTimeSeries() {\n        if (this.lstDate instanceof spinal_core_connectorjs_1.TypedArray) {\n            const tmpDate = this.lstDate;\n            const tmpValue = this.lstValue;\n            this.mod_attr('lstDate', tmpDate.get());\n            this.mod_attr('lstValue', tmpValue.get());\n        }\n    }\n}\nexports.SpinalTimeSeriesArchiveDay = SpinalTimeSeriesArchiveDay;\nspinal_core_connectorjs_1.spinalCore.register_models(SpinalTimeSeriesArchiveDay);\n//# sourceMappingURL=SpinalTimeSeriesArchiveDay.js.map","/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport {\n  Model,\n  FileSystem,\n  spinalCore,\n  Lst,\n  TypedArray,\n  type Val,\n} from 'spinal-core-connectorjs';\nimport type { SpinalDateValue } from '../interfaces/SpinalDateValue';\nimport type { SpinalDateValueArray } from '../interfaces/SpinalDateValueArray';\n\n/**\n * @property {Lst<Val>} lstDate\n * @property {Lst<Val>} lstValue\n * @property {Val} length\n * @property {Val} dateDay\n * @class SpinalTimeSeriesArchiveDay\n * @extends {Model}\n */\nexport class SpinalTimeSeriesArchiveDay extends Model {\n  /**\n   * @private\n   * @type {Lst<Val>}\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  private lstDate: Lst<Val>;\n  /**\n   * @private\n   * @type {Lst<Val>}\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  private lstValue: Lst<Val>;\n  public length: Val;\n  public dateDay: Val;\n\n  constructor(initialBlockSize: number = 50) {\n    super();\n    if (FileSystem._sig_server === false) return;\n    this.add_attr({\n      lstDate: new Lst(Array(initialBlockSize).fill(0)),\n      lstValue: new Lst(Array(initialBlockSize).fill(0)),\n      dateDay: new Date().setUTCHours(0, 0, 0, 0),\n      length: 0,\n    });\n  }\n\n  /**\n   * @param {number} data\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  push(data: number): void {\n    this.upgradeFromOldTimeSeries();\n    if (this.lstDate.length <= this.length.get()) this.addBufferSizeLength();\n    this.setLstVal(this.length.get(), Date.now(), data);\n    this.length.set(this.length.get() + 1);\n  }\n  /**\n   * @param {number} data\n   * @param {(number|string|Date)} date\n   * @returns {boolean}\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  insert(data: number, date: number | string | Date): boolean {\n    this.upgradeFromOldTimeSeries();\n    const targetDate = new Date(date).getTime();\n    const maxDate = new Date(this.dateDay.get()).setUTCHours(23, 59, 59, 999);\n    if (!(this.dateDay.get() <= targetDate && targetDate <= maxDate))\n      return false;\n    if (this.lstDate.length <= this.length.get()) this.addBufferSizeLength();\n    let index = 0;\n    for (; index < this.length.get(); index += 1) {\n      const element = this.lstDate[index].get();\n      if (element === targetDate) {\n        // check exist\n        this.lstValue[index].set(data);\n        return true;\n      }\n      if (element > targetDate) break;\n    }\n    if (index === this.length.get()) {\n      this.setLstVal(this.length.get(), targetDate, data);\n      this.length.set(this.length.get() + 1);\n    } else {\n      for (let idx = this.length.get() - 1; idx >= index; idx -= 1) {\n        this.setLstVal(\n          idx + 1,\n          this.lstDate[idx].get(),\n          this.lstValue[idx].get()\n        );\n      }\n      this.setLstVal(index, targetDate, data);\n      this.length.set(this.length.get() + 1);\n    }\n    return true;\n  }\n\n  private setLstVal(idx: number, date: number, value: number): void {\n    this.lstDate[idx].set(date);\n    this.lstValue[idx].set(value);\n  }\n\n  /**\n   * @param {number} index\n   * @returns {SpinalDateValue}\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  get(index: number): SpinalDateValue;\n  /**\n   * @returns {SpinalDateValueArray}\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  get(): SpinalDateValueArray;\n  /**\n   * @param {number} [index]\n   * @returns {(SpinalDateValue | SpinalDateValueArray)}\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  get(index?: number): SpinalDateValue | SpinalDateValueArray {\n    if (typeof index === 'number') return this.at(index);\n    if (this.lstDate instanceof TypedArray)\n      return {\n        dateDay: this.dateDay.get(),\n        // @ts-ignore\n        date: this.lstDate.get().subarray(0, this.length.get()),\n        // @ts-ignore\n        value: this.lstValue.get().subarray(0, this.length.get()),\n      };\n    const date = [],\n      value = [];\n    for (let idx = 0; idx < this.length.get(); idx++) {\n      date.push(this.lstDate[idx].get());\n      value.push(this.lstValue[idx].get());\n    }\n    return {\n      dateDay: this.dateDay.get(),\n      date,\n      value,\n    };\n  }\n\n  /**\n   * alias of 'get' method with index\n   * @param {number} index\n   * @returns {SpinalDateValue}\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  public at(index: number): SpinalDateValue {\n    if (index >= this.length.get() || index < 0) {\n      return undefined;\n    }\n    if (this.lstDate instanceof TypedArray) {\n      return {\n        date: this.lstDate.get(index),\n        // @ts-ignore\n        value: this.lstValue.get(index),\n      };\n    }\n    return {\n      date: this.lstDate[index].get(),\n      value: this.lstValue[index].get(),\n    };\n  }\n\n  /**\n   * For Tests - returns the TypedArrays' size\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  public getActualBufferSize(): number {\n    return this.lstDate.length;\n  }\n\n  /**\n   * @private\n   * @memberof SpinalTimeSeriesArchiveDay\n   */\n  private addBufferSizeLength() {\n    this.upgradeFromOldTimeSeries();\n    for (let idx = this.length.get(); idx < this.length.get() * 2; idx++) {\n      this.lstDate.push(0);\n      this.lstValue.push(0);\n    }\n  }\n\n  private upgradeFromOldTimeSeries() {\n    if (this.lstDate instanceof TypedArray) {\n      const tmpDate = this.lstDate;\n      const tmpValue = this.lstValue;\n      this.mod_attr('lstDate', tmpDate.get());\n      this.mod_attr('lstValue', tmpValue.get());\n    }\n  }\n}\n\nspinalCore.register_models(SpinalTimeSeriesArchiveDay);\n","\"use strict\";\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalTimeSeriesConfig = void 0;\nexports.SpinalTimeSeriesConfig = {\n    MAX_DAY: 2,\n    INIT_BLOCK_SIZE: 50,\n};\n//# sourceMappingURL=SpinalTimeSeriesConfig.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nexport const SpinalTimeSeriesConfig = {\n  MAX_DAY: 2,\n  INIT_BLOCK_SIZE: 50,\n};\n","\"use strict\";\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asyncGenToArray = void 0;\n/**\n * @template T\n * @param {AsyncIterableIterator<T>} it\n * @return {Promise<T[]>}\n */\nfunction asyncGenToArray(it) {\n    var _a, it_1, it_1_1;\n    var _b, e_1, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n        const res = [];\n        try {\n            for (_a = true, it_1 = __asyncValues(it); it_1_1 = yield it_1.next(), _b = it_1_1.done, !_b;) {\n                _d = it_1_1.value;\n                _a = false;\n                try {\n                    const i = _d;\n                    res.push(i);\n                }\n                finally {\n                    _a = true;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_a && !_b && (_c = it_1.return)) yield _c.call(it_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return res;\n    });\n}\nexports.asyncGenToArray = asyncGenToArray;\n//# sourceMappingURL=asyncGenToArray.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n * \n * This file is part of SpinalCore.\n * \n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n * \n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n * \n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\n/**\n * @template T\n * @param {AsyncIterableIterator<T>} it\n * @return {Promise<T[]>}\n */\n\nexport async function asyncGenToArray<T>(\n  it: AsyncIterableIterator<T>\n): Promise<T[]> {\n  const res: T[] = [];\n  for await (const i of it) {\n    res.push(i);\n  }\n  return res;\n}\n","\"use strict\";\n/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=SpinalDateValueArray.js.map","/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\n/**\n * @property {number} dateDay\n * @property {number[]} date\n * @property {number[]} value\n * @interface SpinalDateValueArray\n */\nexport interface SpinalDateValueArray {\n  dateDay: number;\n  date: number[];\n  value: number[];\n}\n","\"use strict\";\n/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=SpinalDateValue.js.map","/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\n/**\n * @property {number} date\n * @property {number} value\n * @interface SpinalDateValue\n */\nexport interface SpinalDateValue {\n  date: number;\n  value: number;\n}\n","\"use strict\";\n/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=TimeSeriesEndpointCfg.js.map","/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\n/**\n * @property {number} maxDay\n * @property {number} initialBlockSize\n * @export\n * @interface TimeSeriesEndpointCfg\n */\nexport interface TimeSeriesEndpointCfg {\n  maxDay: number;\n  initialBlockSize: number;\n}\n","\"use strict\";\n/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=TimeSeriesIntervalDate.js.map","/*\n * Copyright 2021 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\n/**\n * @property {Date | number | string} start\n * @property {Date | number | string} end\n * @interface TimeSeriesIntervalDate\n */\nexport interface TimeSeriesIntervalDate {\n  start: Date | number | string;\n  end: Date | number | string;\n}\n","\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InputDataEndpointDataType = exports.InputDataEndpointType = void 0;\nconst InputDataEndpointDataType_1 = require(\"./InputDataEndpointDataType\");\nObject.defineProperty(exports, \"InputDataEndpointDataType\", { enumerable: true, get: function () { return InputDataEndpointDataType_1.InputDataEndpointDataType; } });\nconst InputDataEndpointType_1 = require(\"./InputDataEndpointType\");\nObject.defineProperty(exports, \"InputDataEndpointType\", { enumerable: true, get: function () { return InputDataEndpointType_1.InputDataEndpointType; } });\n//# sourceMappingURL=InputDataModel.js.map",null,"\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InputDataEndpointDataType = void 0;\n/**\n * @enum {number}\n */\nvar InputDataEndpointDataType;\n(function (InputDataEndpointDataType) {\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Null\"] = 0] = \"Null\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Boolean\"] = 1] = \"Boolean\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Unsigned\"] = 2] = \"Unsigned\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Unsigned8\"] = 3] = \"Unsigned8\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Unsigned16\"] = 4] = \"Unsigned16\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Unsigned32\"] = 5] = \"Unsigned32\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Integer\"] = 6] = \"Integer\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Integer16\"] = 7] = \"Integer16\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Real\"] = 8] = \"Real\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Double\"] = 9] = \"Double\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"OctetString\"] = 10] = \"OctetString\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"CharacterString\"] = 11] = \"CharacterString\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"BitString\"] = 12] = \"BitString\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Enumerated\"] = 13] = \"Enumerated\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Date\"] = 14] = \"Date\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Time\"] = 15] = \"Time\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Array\"] = 16] = \"Array\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"DateTime\"] = 17] = \"DateTime\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Long\"] = 18] = \"Long\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"String\"] = 19] = \"String\";\n    InputDataEndpointDataType[InputDataEndpointDataType[\"Duration\"] = 20] = \"Duration\";\n})(InputDataEndpointDataType || (exports.InputDataEndpointDataType = InputDataEndpointDataType = {}));\n//# sourceMappingURL=InputDataEndpointDataType.js.map",null,"\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InputDataEndpointType = void 0;\n/**\n * @enum {number}\n */\nvar InputDataEndpointType;\n(function (InputDataEndpointType) {\n    InputDataEndpointType[InputDataEndpointType[\"Temperature\"] = 0] = \"Temperature\";\n    InputDataEndpointType[InputDataEndpointType[\"Hygrometry\"] = 1] = \"Hygrometry\";\n    InputDataEndpointType[InputDataEndpointType[\"Power\"] = 2] = \"Power\";\n    InputDataEndpointType[InputDataEndpointType[\"Occupation\"] = 3] = \"Occupation\";\n    InputDataEndpointType[InputDataEndpointType[\"Light\"] = 4] = \"Light\";\n    InputDataEndpointType[InputDataEndpointType[\"Alarm\"] = 5] = \"Alarm\";\n    InputDataEndpointType[InputDataEndpointType[\"Other\"] = 6] = \"Other\";\n    InputDataEndpointType[InputDataEndpointType[\"Consigne\"] = 7] = \"Consigne\";\n    InputDataEndpointType[InputDataEndpointType[\"co2\"] = 8] = \"co2\";\n})(InputDataEndpointType || (exports.InputDataEndpointType = InputDataEndpointType = {}));\n//# sourceMappingURL=InputDataEndpointType.js.map",null,"\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalBmsEndpointGroup = exports.SpinalBmsEndpoint = exports.SpinalBmsNetwork = exports.SpinalBmsDevice = void 0;\nconst SpinalBmsDevice_1 = require(\"./bms-network/SpinalBmsDevice\");\nObject.defineProperty(exports, \"SpinalBmsDevice\", { enumerable: true, get: function () { return SpinalBmsDevice_1.SpinalBmsDevice; } });\nconst SpinalBmsNetwork_1 = require(\"./bms-network/SpinalBmsNetwork\");\nObject.defineProperty(exports, \"SpinalBmsNetwork\", { enumerable: true, get: function () { return SpinalBmsNetwork_1.SpinalBmsNetwork; } });\nconst SpinalBmsEndpoint_1 = require(\"./bms-network/SpinalBmsEndpoint\");\nObject.defineProperty(exports, \"SpinalBmsEndpoint\", { enumerable: true, get: function () { return SpinalBmsEndpoint_1.SpinalBmsEndpoint; } });\nconst SpinalBmsEndpointGroup_1 = require(\"./bms-network/SpinalBmsEndpointGroup\");\nObject.defineProperty(exports, \"SpinalBmsEndpointGroup\", { enumerable: true, get: function () { return SpinalBmsEndpointGroup_1.SpinalBmsEndpointGroup; } });\nconst obj = {\n    SpinalBmsDevice: SpinalBmsDevice_1.SpinalBmsDevice,\n    SpinalBmsNetwork: SpinalBmsNetwork_1.SpinalBmsNetwork,\n    SpinalBmsEndpoint: SpinalBmsEndpoint_1.SpinalBmsEndpoint,\n    SpinalBmsEndpointGroup: SpinalBmsEndpointGroup_1.SpinalBmsEndpointGroup,\n};\nexports.default = obj;\n//# sourceMappingURL=SpinalBms.js.map",null,"\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalBmsDevice = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst genUID_1 = require(\"../Utils/genUID\");\n/**\n * @property {spinal.Str} id;\n * @property {spinal.Str} name;\n * @property {spinal.Str} type;\n * @property {spinal.Str} path;\n * @export\n * @class SpinalBmsDevice\n * @extends {Model}\n */\nclass SpinalBmsDevice extends spinal_core_connectorjs_type_1.Model {\n    /**\n     *Creates an instance of SpinalBmsDevice.\n     * @param {string} [name='']\n     * @param {string} [type='']\n     * @param {string} [path='']\n     * @param {string} [id=genUID('SpinalBmsDevice')]\n     * @memberof SpinalBmsDevice\n     */\n    constructor(name = '', type = '', path = '', id = (0, genUID_1.genUID)('SpinalBmsDevice')) {\n        super();\n        this.add_attr({\n            id,\n            name,\n            type,\n            path,\n        });\n    }\n}\nexports.SpinalBmsDevice = SpinalBmsDevice;\n/**\n * @static\n * @type {string}\n * @memberof SpinalBmsDevice\n */\nSpinalBmsDevice.relationName = 'hasBmsDevice';\n/**\n * @static\n * @type {string}\n * @memberof SpinalBmsDevice\n */\nSpinalBmsDevice.nodeTypeName = 'BmsDevice';\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalBmsDevice);\nexports.default = SpinalBmsDevice;\n//# sourceMappingURL=SpinalBmsDevice.js.map",null,"\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.genUID = void 0;\nfunction s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n}\n/**\n * @param {string} constructor\n * @returns {string}\n */\nfunction genUID(constructor) {\n    const res = `${constructor}-${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4() + s4() + s4()}-${Date.now().toString(16)}`;\n    return res;\n}\nexports.genUID = genUID;\n//# sourceMappingURL=genUID.js.map",null,"\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalBmsNetwork = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst genUID_1 = require(\"../Utils/genUID\");\n/**\n *\n * @property {spinal.Str} name\n * @property {spinal.Str} type\n * @property {spinal.Str} id\n * @export\n * @class SpinalBmsNetwork\n * @extends {Model}\n */\nclass SpinalBmsNetwork extends spinal_core_connectorjs_type_1.Model {\n    /**\n     *Creates an instance of SpinalBmsNetwork.\n     * @param {string} [name='']\n     * @param {string} [type='']\n     * @param {string} [id=genUID('SpinalBmsNetwork')]\n     * @memberof SpinalBmsNetwork\n     */\n    constructor(name = '', type = '', id = (0, genUID_1.genUID)('SpinalBmsNetwork')) {\n        super();\n        this.add_attr({ id, name, type });\n    }\n}\nexports.SpinalBmsNetwork = SpinalBmsNetwork;\n/**\n * @static\n * @type {string}\n * @memberof SpinalBmsNetwork\n */\nSpinalBmsNetwork.relationName = 'hasBmsNetwork';\n/**\n * @static\n * @type {string}\n * @memberof SpinalBmsNetwork\n */\nSpinalBmsNetwork.nodeTypeName = 'BmsNetwork';\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalBmsNetwork);\nexports.default = SpinalBmsNetwork;\n//# sourceMappingURL=SpinalBmsNetwork.js.map",null,"\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalBmsEndpoint = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst genUID_1 = require(\"../Utils/genUID\");\n/**\n * @property {spinal.Str} id\n * @property {spinal.Str} path\n * @property {spinal.Str | spinal.Val} currentValue\n * @property {spinal.Str} unit\n * @property {spinal.Str} type\n * @property {spinal.Str} dataType\n * @export\n * @class SpinalBmsEndpoint\n * @extends {Model}\n */\nclass SpinalBmsEndpoint extends spinal_core_connectorjs_type_1.Model {\n    /**\n     *Creates an instance of SpinalBmsEndpoint.\n     * @param {string} [name='']\n     * @param {string} [path='']\n     * @param {(string|number)} [currentValue='']\n     * @param {string} [unit='']\n     * @param {string} [dataType='']\n     * @param {string} [type='']\n     * @param {string} [id=genUID('SpinalBmsEndpoint')]\n     * @memberof SpinalBmsEndpoint\n     */\n    constructor(name = \"\", path = \"\", currentValue = \"\", unit = \"\", dataType = \"\", type = \"\", id = (0, genUID_1.genUID)(\"SpinalBmsEndpoint\")) {\n        super();\n        this.add_attr({\n            id,\n            name,\n            path,\n            currentValue,\n            unit,\n            dataType,\n            type\n        });\n    }\n}\nexports.SpinalBmsEndpoint = SpinalBmsEndpoint;\n/**\n * @static\n * @type {string}\n * @memberof SpinalBmsEndpoint\n */\nSpinalBmsEndpoint.relationName = \"hasBmsEndpoint\";\n/**\n * @static\n * @type {string}\n * @memberof SpinalBmsEndpoint\n */\nSpinalBmsEndpoint.nodeTypeName = \"BmsEndpoint\";\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalBmsEndpoint);\nexports.default = SpinalBmsEndpoint;\n//# sourceMappingURL=SpinalBmsEndpoint.js.map",null,"\"use strict\";\n/*\n * Copyright 2018 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpinalBmsEndpointGroup = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst genUID_1 = require(\"../Utils/genUID\");\n/**\n * @property {spinal.Str} id;\n * @property {spinal.Str} name;\n * @property {spinal.Str} type;\n * @property {spinal.Str} path;\n * @export\n * @class SpinalBmsEndpointGroup\n * @extends {Model}\n */\nclass SpinalBmsEndpointGroup extends spinal_core_connectorjs_type_1.Model {\n    /**\n     *Creates an instance of SpinalBmsEndpointGroup.\n     * @param {string} [name='']\n     * @param {string} [type='']\n     * @param {string} [path='']\n     * @param {string} [id=genUID('SpinalBmsNetwork')]\n     * @memberof SpinalBmsEndpointGroup\n     */\n    constructor(name = '', type = '', path = '', id = (0, genUID_1.genUID)('SpinalBmsNetwork')) {\n        super();\n        this.add_attr({\n            id,\n            name,\n            type,\n            path,\n        });\n    }\n}\nexports.SpinalBmsEndpointGroup = SpinalBmsEndpointGroup;\n/**\n * @static\n * @type {string}\n * @memberof SpinalBmsEndpointGroup\n */\nSpinalBmsEndpointGroup.relationName = 'hasBmsEndpointGroup';\n/**\n * @static\n * @type {string}\n * @memberof SpinalBmsEndpointGroup\n */\nSpinalBmsEndpointGroup.nodeTypeName = 'BmsEndpointGroup';\nspinal_core_connectorjs_type_1.spinalCore.register_models(SpinalBmsEndpointGroup);\nexports.default = SpinalBmsEndpointGroup;\n//# sourceMappingURL=SpinalBmsEndpointGroup.js.map",null,"/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n","\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst constants_1 = require(\"./constants\");\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nconst spinal_env_viewer_context_geographic_service_1 = require(\"spinal-env-viewer-context-geographic-service\");\nconst spinal_model_bmsnetwork_1 = require(\"spinal-model-bmsnetwork\");\nclass SpinalGroup {\n    constructor() {\n        this.CATEGORY_TO_GROUP_RELATION = constants_1.CATEGORY_TO_GROUP_RELATION;\n        this.RELATION_BEGIN = constants_1.GROUP_RELATION_BEGIN;\n    }\n    addGroup(contextId, categoryId, groupName, groupColor, groupIcon = \"3d_rotation\") {\n        return __awaiter(this, void 0, void 0, function* () {\n            const groupFound = yield this._groupNameExist(categoryId, groupName);\n            if (groupFound) {\n                return spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(groupFound.id.get());\n            }\n            let contextInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(contextId);\n            if (contextInfo) {\n                let info = {\n                    name: groupName,\n                    type: `${this._getChildrenType(contextInfo.type.get())}Group`,\n                    color: groupColor ? groupColor : \"#000000\",\n                    icon: groupIcon,\n                };\n                let childId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(info, new spinal_core_connectorjs_type_1.Model({\n                    name: groupName,\n                }));\n                return spinal_env_viewer_graph_service_1.SpinalGraphService.addChildInContext(categoryId, childId, contextId, this.CATEGORY_TO_GROUP_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            }\n            // return Promise.resolve(false);\n        });\n    }\n    linkElementToGroup(contextId, groupId, elementId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let contextInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(contextId);\n            let elementInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(elementId);\n            if (contextInfo && elementInfo) {\n                let childrenType = this._getChildrenType(contextInfo.type.get());\n                if (childrenType === elementInfo.type.get() || this._isOldGroup(contextInfo.type.get(), elementInfo.type.get()))\n                    return spinal_env_viewer_graph_service_1.SpinalGraphService.addChildInContext(groupId, elementId, contextId, `${this.RELATION_BEGIN}${elementInfo.type.get()}`, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            }\n            throw Error(`${elementInfo.type.get()} cannot be linked to this group.`);\n        });\n    }\n    elementIsLinkedToGroup(groupId, elementId) {\n        let childrenIds = spinal_env_viewer_graph_service_1.SpinalGraphService.getChildrenIds(groupId);\n        return childrenIds.indexOf(elementId) !== -1;\n    }\n    unLinkElementToGroup(groupId, elementId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let elementInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(elementId);\n            let relationName = `${this.RELATION_BEGIN}${elementInfo.type.get()}`;\n            let result;\n            try {\n                result = yield spinal_env_viewer_graph_service_1.SpinalGraphService.removeChild(groupId, elementId, relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            }\n            catch (error) {\n                result = yield spinal_env_viewer_graph_service_1.SpinalGraphService.removeChild(groupId, elementId, relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_LST_PTR_TYPE);\n            }\n            if (!result) {\n                const groupInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(groupId);\n                relationName = this._getGroupRelation(groupInfo.type.get());\n                return spinal_env_viewer_graph_service_1.SpinalGraphService.removeChild(groupId, elementId, relationName, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n            }\n        });\n    }\n    getElementsLinkedToGroup(groupId) {\n        let groupInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(groupId);\n        let type = this._getChildrenType(groupInfo.type.get());\n        let relationNames = [`${this.RELATION_BEGIN}${type}`];\n        const tempRel = this._getGroupRelation(groupInfo.type.get());\n        if (typeof tempRel !== \"undefined\")\n            relationNames.push(tempRel);\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(groupId, relationNames);\n    }\n    getGroups(nodeId) {\n        let nodeInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(nodeId);\n        if (this._isGroup(nodeInfo.type.get())) {\n            return Promise.resolve([nodeInfo]);\n        }\n        let relations = [\n            constants_1.CONTEXT_TO_CATEGORY_RELATION,\n            constants_1.CATEGORY_TO_GROUP_RELATION,\n            // `${this.RELATION_BEGIN}${nodeInfo.type.get()}`,\n            // OLD_RELATIONS_TYPES.GROUP_TO_ENDPOINT_RELATION,\n            // OLD_RELATIONS_TYPES.GROUP_TO_EQUIPMENTS_RELATION,\n            // OLD_RELATIONS_TYPES.GROUP_TO_ROOMS_RELATION,\n        ];\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.findNodes(nodeId, relations, (node) => {\n            let argType = node.getType().get();\n            return this._isGroup(argType);\n        }).then((res) => {\n            return res.map((el) => {\n                spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(el);\n                return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(el.getId().get());\n            });\n        });\n    }\n    getCategory(groupId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const parents = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getParents(groupId, this.CATEGORY_TO_GROUP_RELATION);\n            if (parents.length > 0)\n                return parents[0];\n        });\n    }\n    updateGroup(groupId, newInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let realNode = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(groupId);\n            for (const key in newInfo) {\n                if (newInfo.hasOwnProperty(key)) {\n                    const value = newInfo[key];\n                    if (realNode.info[key]) {\n                        realNode.info[key].set(value);\n                    }\n                    else {\n                        realNode.info.add_attr({\n                            [key]: value,\n                        });\n                    }\n                }\n            }\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(realNode.getId().get());\n        });\n    }\n    _isGroup(type) {\n        // let stringEnd = type.substr(type.length - 5);\n        // return stringEnd === \"Group\";\n        return /Group$/.test(type);\n    }\n    checkGroupType(groupType, childrenType) {\n        return groupType === `${childrenType}Group`;\n    }\n    ////////////////////////////////////////////////////////////////////\n    //                      PRIVATES                                  //\n    ////////////////////////////////////////////////////////////////////\n    _getChildrenType(elementType) {\n        if (elementType.toLowerCase() === constants_1.OLD_CONTEXTS_TYPES.ROOMS_GROUP_CONTEXT.toLowerCase() || elementType.toLowerCase() === constants_1.OLD_GROUPS_TYPES.ROOMS_GROUP.toLowerCase()) {\n            return spinal_env_viewer_context_geographic_service_1.default.constants.ROOM_TYPE;\n        }\n        else if (elementType.toLowerCase() === constants_1.OLD_CONTEXTS_TYPES.EQUIPMENTS_GROUP_CONTEXT.toLowerCase() || elementType.toLowerCase() === constants_1.OLD_GROUPS_TYPES.EQUIPMENTS_GROUP.toLowerCase()) {\n            return spinal_env_viewer_context_geographic_service_1.default.constants.EQUIPMENT_TYPE;\n        }\n        else if (elementType.toLowerCase() === constants_1.OLD_CONTEXTS_TYPES.ENDPOINTS_GROUP_CONTEXT.toLowerCase() || elementType.toLowerCase() === constants_1.OLD_GROUPS_TYPES.ENDPOINT_GROUP.toLowerCase()) {\n            return spinal_model_bmsnetwork_1.SpinalBmsEndpoint.nodeTypeName;\n        }\n        else {\n            if (/GroupContext$/.test(elementType))\n                return elementType.replace(\"GroupContext\", \"\");\n            else if (/Group$/.test(elementType))\n                return elementType.replace(\"Group\", \"\");\n            throw new Error(`${elementType} is not a group element type`);\n        }\n    }\n    _isOldGroup(contextType, elementType) {\n        const isRoomGroup = contextType === constants_1.OLD_CONTEXTS_TYPES.ROOMS_GROUP_CONTEXT && elementType === spinal_env_viewer_context_geographic_service_1.default.constants.ROOM_TYPE;\n        const isEquipementGroup = contextType === constants_1.OLD_CONTEXTS_TYPES.EQUIPMENTS_GROUP_CONTEXT && elementType === spinal_env_viewer_context_geographic_service_1.default.constants.EQUIPMENT_TYPE;\n        const isEndpointGroup = contextType === constants_1.OLD_CONTEXTS_TYPES.ENDPOINTS_GROUP_CONTEXT && elementType === spinal_model_bmsnetwork_1.SpinalBmsEndpoint.nodeTypeName;\n        console.log(isRoomGroup, isEquipementGroup, isEndpointGroup);\n        return isRoomGroup || isEquipementGroup || isEndpointGroup;\n    }\n    _groupNameExist(nodeId, groupName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const groups = yield this.getGroups(nodeId);\n            for (const group of groups) {\n                const name = group.name.get();\n                if (name === groupName)\n                    return group;\n            }\n        });\n    }\n    _getGroupRelation(type) {\n        let relationName;\n        switch (type.toLowerCase()) {\n            case constants_1.OLD_GROUPS_TYPES.ROOMS_GROUP.toLowerCase():\n                relationName = constants_1.OLD_RELATIONS_TYPES.GROUP_TO_ROOMS_RELATION;\n                break;\n            case constants_1.OLD_GROUPS_TYPES.EQUIPMENTS_GROUP.toLowerCase():\n                relationName = constants_1.OLD_RELATIONS_TYPES.GROUP_TO_EQUIPMENTS_RELATION;\n                break;\n            case constants_1.OLD_GROUPS_TYPES.EQUIPMENTS_GROUP.toLowerCase():\n                relationName = constants_1.OLD_RELATIONS_TYPES.GROUP_TO_ENDPOINT_RELATION;\n                break;\n        }\n        return relationName;\n    }\n}\nexports.default = SpinalGroup;\n//# sourceMappingURL=SpinalGroup.js.map",null,"\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst constants_1 = require(\"./constants\");\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nclass SpinalCategory {\n    constructor() {\n        this.CATEGORY_TYPE = constants_1.CATEGORY_TYPE;\n        this.CONTEXT_TO_CATEGORY_RELATION = constants_1.CONTEXT_TO_CATEGORY_RELATION;\n    }\n    addCategory(contextId, categoryName, iconName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const categoryFound = yield this._categoryNameExist(contextId, categoryName);\n            if (categoryFound) {\n                return spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(categoryFound.id.get());\n            }\n            let info = {\n                name: categoryName,\n                type: this.CATEGORY_TYPE,\n                icon: iconName\n            };\n            let childId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(info, new spinal_core_connectorjs_type_1.Model({\n                name: categoryName\n            }));\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.addChildInContext(contextId, childId, contextId, this.CONTEXT_TO_CATEGORY_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n        });\n    }\n    getCategories(nodeId) {\n        let nodeInfo = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(nodeId);\n        if (this._isCategory(nodeInfo.type.get())) {\n            return Promise.resolve([nodeInfo]);\n        }\n        else if (this._isContext(nodeInfo.type.get())) {\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(nodeId, [this.CONTEXT_TO_CATEGORY_RELATION]);\n        }\n        else {\n            return this._getRelationRefs(nodeId).then(refs => {\n                let promises = refs.map(node => {\n                    return node.parent.load();\n                });\n                return Promise.all(promises).then((parents) => {\n                    return parents.map(el => {\n                        return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(el.getId().get());\n                    });\n                });\n            });\n        }\n    }\n    elementIsInCategorie(categoryId, elementId) {\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(categoryId, [constants_1.CATEGORY_TO_GROUP_RELATION]).then(children => {\n            let itemFound = children.find((child) => {\n                return child.childrenIds.find(el => {\n                    return el === elementId;\n                });\n            });\n            return itemFound;\n        });\n    }\n    updateCategory(categoryId, newInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let realNode = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(categoryId);\n            for (const key in newInfo) {\n                if (newInfo.hasOwnProperty(key)) {\n                    const value = newInfo[key];\n                    if (realNode.info[key]) {\n                        realNode.info[key].set(value);\n                    }\n                    else {\n                        realNode.info.add_attr({\n                            [key]: value\n                        });\n                    }\n                }\n            }\n            return realNode;\n        });\n    }\n    ////////////////////////////////////////////////////////////////////\n    //                      PRIVATES                                  //\n    ////////////////////////////////////////////////////////////////////\n    _isCategory(type) {\n        return type === this.CATEGORY_TYPE;\n    }\n    _isContext(type) {\n        const values = Object.values(constants_1.OLD_CONTEXTS_TYPES);\n        if (values.indexOf(type) !== -1)\n            return true;\n        return /GroupContext$/.test(type);\n    }\n    _getRelationRefs(nodeId) {\n        let relationRefPromises = [];\n        let node = spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(nodeId);\n        let relationList = node.parents[`groupHas${node.getType().get()}`];\n        if (relationList) {\n            for (let i = 0; i < relationList.length; i++) {\n                const element = relationList[i];\n                relationRefPromises.push(element.load());\n            }\n        }\n        return Promise.all(relationRefPromises);\n    }\n    _categoryNameExist(nodeId, categoryName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const categories = yield this.getCategories(nodeId);\n            for (const category of categories) {\n                const name = category.name.get();\n                if (name === categoryName)\n                    return category;\n            }\n        });\n    }\n}\nexports.default = SpinalCategory;\n//# sourceMappingURL=SpinalCategory.js.map",null],"names":[],"version":3,"file":"dist.8820b390.js.map"}