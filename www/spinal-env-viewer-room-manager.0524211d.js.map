{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A;A,O,c,C,S,c;I,O;A;A,Q,a,G,Q,qB,G,K;ACCA,MAAA,aAAA,QAAA;AAsBG,OAAA,cAAA,CAAA,SAAA,iBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAtBM,WAAA,aAAa;IAAA;AAAA;AACtB,MAAA,oBAAA,QAAA;AAGA,MAAM,aAAkB,OAAO,WAAW,cAAc,SAAS;AAEjE,MAAM,wBAAwB,IAAI,kBAAA,eAAe;AAc9C,QAAA,qBAAA,GAAA;AAXH,IAAI,OAAO,WAAW,MAAM,KAAK,aAAa,WAAW,MAAM,GAAG,CAAA;AAElE,IAAI,OAAO,WAAW,MAAM,CAAC,qBAAqB,KAAK,aACpD,WAAW,MAAM,CAAC,qBAAqB,GAAG;AAG7C,IAAI,OAAO,WAAW,MAAM,CAAC,qBAAqB,KAAK,aACpD,WAAW,MAAM,CAAC,qBAAqB,GAAG;AAS7C,QAAA,OAAA,GAAe;;;A;A,O,c,C,S,c;I,O;A;A,Q,a,G,K;AE1Bf,MAAA,iCAAA,QAAA;AAKA,MAAM,sBAAsB,+BAAA,KAAK;IAC9B,YAAY,QAAmB,CAA/B;QACG,KAAK;QACL,IAAI,CAAC,QAAQ,CAAC;IACjB;AACF;AAKE,QAAA,aAAA,GAAA;AAHH,+BAAA,UAAU,CAAC,eAAe,CAAC;IAAC;CAAc;AAC1C,QAAA,OAAA,GAAe;;;A;A,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,O,c,C,S,c;I,O;A;A,Q,e,G,K;AEZf,MAAA,oCAAA,QAAA;AACA,MAAA,mDAAA,QAAA;AACA,MAAA,aA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YACA,MAAA,IAAAtC,MAAA;QACA;QAEAI;YACA,IAAA,CAAA/G,IAAA,CAAAkJ,IAAA,CAAA,CAAAC,OAAAC,QAAAD,MAAA/F,EAAA,CAAAb,KAAA,GAAA6G,MAAAhG,EAAA,CAAAb,KAAA;QACA;IACA;AACA;A,S,mB,Q,E,K,E,M,E,O,E,oB,E,iB,e,G,E,U,E,c,E,iB,E,oB;I,I,O,e,W;Q,oB;Q,iB;Q,a;I;I,yC;I,M,U,O,W,a,O,O,G;I,mB;I,I,Y,S,M,E;Q,Q,M,G,S,M;Q,Q,e,G,S,e;Q,Q,S,G;Q,sB;Q,I,sB,Q,U,G;I;I,W;I,I,S,Q,Q,G;I,I;I,I,kB;Q,e;Q,O,S,O;Y,gB;Y,U,W,c;Y,I,C,M,I,I,C,M,C,U,I,W;Y,I,C,M,I,I,C,M,C,M,I,I,C,M,C,M,C,U,E,a;Y,iC;Y,I,C,W,O,wB,a,U;Y,0B;Y,I,O,M,I,C,I,E,kB;Y,iE;Y,I,W,Q,qB,E,Q,qB,C,G,C;Q;Q,2D;Q,oB;Q,Q,Y,G;I,O,I,O,O,a,S,O;Q,M,I,C,I,E,qB,S,I,C,K,C,Q,C,U;I,I,S,O;Q,M,I,C,I,E,e;I;I,I;Q,I,Q,U,E;Y,gD;Y,M,iB,Q,M;Y,Q,M,G,S,yB,C,E,O;gB,K,I,C;gB,O,e,G;Y;Q,O;Y,qD;Y,M,W,Q,Y;Y,Q,Y,G,W,E,C,M,C,U,Q;gB;a;Q;;I,O;A;A,U,GAntBA,MAAc8G,mBAAAC;A,Y,G,I,mB;I,I,M;I,I,M,I;I,I,K,I,c;I,I,K,I,K,C,E,I;I,O,G,O;Q,Y;Y;gB,M;gB,S;gB,O,I,sB;gB,Y;Y;S;Q,a;Q,O,C,A,O;Y,O,I,K;Y,a,I,Q;Q,G,I,C,e,I,S,C,G,M,I;Q,I;Y,W,S,M;gB,O,I,Y,C,K,C,M;Y;Q;I,G;Q,I,M,C,M,G,G,O;Y,K;Y,a;Q,G;Y,I,E,C;S,E,K,I,E;Q,I,E,C;Q,G,I,O,E;Y,K;Y,K;Y,a;Y,O,I,S;Y,O,C,A,S,C,G,M,C,I,S,K,a,c,W,G,I,S,G,M,M;Q,G;Y,I,E,C,I,I,E,S,I;gB,O,G,I,O,E,I,E,C;oB,K,K,E,C,E;oB,K;oB,a;oB,O;wB,I,S;wB;4B,O,C,I,S,I,I,Q,K,K,E,C,G;wB;qB;oB,O,I,K,G;wB,W,c,C,I,S,K,a,M,G,I,M,K,Q,G,kB,C,I,S,K,a,M,G,I,M,K,M,G;wB,O,I,S,G,A,C,I,S,K,a,I,iB,I,I,Q,G,I,Q,A,I,O;wB,Q,I,S,G,A,C,I,S,K,e,I,iB,I,I,Q,G,I,Q,A,I,O;oB,I;gB,G,I,S,G,C,I;oB,Y;wB,I,Q,G,K,E,C,G;oB;oB,Y;wB,I,Q,G;oB;gB,I;oB,I,E,C,W,M;wB,M,K,I;wB,O,K,E,C,K;wB,Q,K,E,C,I;oB;iB,E;Y;Y,I,E,C;Y,I,E,C;S,E;Q,I,E,C;Q,I,M,C,K,G,G,O;Y,K;Y,a;Q,G;Y,I,E,C;S,E,K,I,E;Q,I,E,C;Q,G,kB;Y,I;gB,Q,I,Y;Y;Q;K,E;A;A,I,4B,E;A,iB,a,G;A,S,G,M,0B;A,U,G,M,qB;A,qB,G,M,8B;A,uB,G,M,mC;A,gB,G,oB,G,2B,G,M,sB,W,G,mB;I,Q;I,iB;A,G,yB,kB,oB,kC,6B,O,W,W;A,E;ACsCd,IAAA,WAAA;IACA5K,MAAA;IAEAC,YAAA;QACA4K,iBAAAA;IACA;IAEAC;QACA,IAAA,OAAA5K,mBAAA,aACA,IAAA,CAAA6K,gBAAA,GAAA,IAAA7K,eAAA8K,CAAAA;YACA9F,sBAAA;gBACA,IAAA,CAAAxG,MAAAuM,OAAA,CAAAD,UACA;gBAEA,KAAA,MAAAvF,SAAAuF,QACA,IAAAvF,MAAA8C,MAAA,EAAA;oBACA,MAAAtD,QAAA,IAAAiG,YACA,UACA;wBACAC,QAAA;4BACAC,aAAA3F,MAAA2F,WAAAA;wBACA;oBACA;oBAEA3F,MAAA8C,MAAA,CAAA8C,aAAA,CAAApG;gBACA;YAEA;QACA;QAGA,OAAA;YACAqG,aAAA,IAAA,CAAAA,WAAA;YACAC,eAAA,IAAA;YACAC,uBAAA,IAAA,CAAAT,gBAAAA;QACA;IACA;IAEAU,cAAA;IAEAlN,OAAA;QACA,GAAAA,KAAA;QAEAmC,aAAA;YACAjC,MAAA;gBAAA6B;gBAAAzB;aAAA;YACAF,UAAA;QACA;IACA;IAEA0C;QACA,OAAA;YACAiK,aAAA;gBACAI,QAAA;gBACA/J,OAAA,CAAA;gBACAgK,YAAA,CAAA;gBACA/M,UAAA,IAAA,CAAAA,QAAA;g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J,GAAA;YACA,8BAAA;YACA,IAAA,CAAApF,SAAA,CAAA;gBACAwF,GAAAU,SAAA,GAAAV,GAAA9B,YAAA,GAAA;gBACA,0BAAA;gBACA,MAAAkG,KAAA;oBACApE,GAAAU,SAAA,GAAAV,GAAA9B,YAAA,GAAA;oBACA7B,sBAAA;wBACA2D,GAAAU,SAAA,GAAAV,GAAA9B,YAAA,GAAA;wBACA,IAAA,IAAA,CAAA0F,gBAAA,KAAA,GACA,IAAA,CAAAO,mBAAA,GAAA;6BAEA9H,sBAAA+H;oBAEA;gBACA;gBACA/H,sBAAA+H;YACA;QACA;IACA;AACA;A,U,GAnPA,MAActC,mBAAAC;A,Y,G,I,iB;I,I,M,I;I,I,K,I,c;I,I,K,I,K,C,E,I;I,O,G,mB,I,E,C,I,E,C;Q,K;Q,O;Y,O,I,a;Y,iB,I,W;Y,W,I,S;Y,a;Y,Y,I,O;Y,Y,I,O;Q;Q,I;Y,Q,I,gB;Y,S,I,iB;Q;Q,a,I,E,C;Y;gB,K;gB,I,S,G;oB,I,e,I,I;oB,I,Q,I,K;oB,I,S,I,M;oB,O;wB,I,E,C,W,M,M;4B,M,a,I;4B,O;4B,Q;4B,c;wB;qB;gB;Y;S,E,M;I,G,mB,I,M,E,Q,I,S,G;Q,I,E,C;Q,G,Y;Y,M;Q,G;Y,I,E,C;S,E;Q,I,E,C;Q,G,Y;Y,M;Q,G;Y,I,E,C;S,E;Q,I,E,C;Q,G,Y;Y,M;Q,G;Y,I,E,C;S,E;K,E;A;A,I,0B,E;A,e,a,G;A,S,G,M,0B;A,U,G,M,qB;A,qB,G,M,8B;A,uB,G,M,mC;A,gB,G,oB,G,2B,G,M,sB,W,G,mB;I,Q;I,iB;A,G,yB,kB,oB,kC,6B,O,W,W;ACDd,IAAA,SAAA;IACA5K,MAAA;IAEAkN,QAAA;QACA;QACA;QACA;KACA;IAEA3O,OAAA;QACA,kDAAA;QACAuF,MAAA;YACAnF,UAAA;QACA;QAEAwO,WAAA;YACA1O,MAAAsC;YACAjC,SAAA;QACA;QAEA;;KAEA,GACA4M,QAAA;YACAjN,MAAAsC;YACApC,UAAA;QACA;QAEAkF,OAAA;YACApF,MAAA6B;YACAxB,SAAA0B;QACA;QAEA4M,kBAAA;YACA3O,MAAA;gBAAAC;gBAAAgB;aAAA;YACAZ,SAAA;QACA;QA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","sources":["node_modules/spinal-env-viewer-plugin-analytics-service/dist/index.js","node_modules/spinal-env-viewer-plugin-analytics-service/src/index.ts","node_modules/spinal-env-viewer-plugin-analytics-service/dist/Models/Analytic.js","node_modules/spinal-env-viewer-plugin-analytics-service/src/Models/Analytic.ts","node_modules/spinal-env-viewer-plugin-analytics-service/dist/services/AnalyticService.js","node_modules/spinal-env-viewer-plugin-analytics-service/src/services/AnalyticService.ts","node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js","node_modules/vue-virtual-scroller/src/config.js","node_modules/vue-virtual-scroller/src/components/common.js","node_modules/vue-virtual-scroller/src/utils.js","node_modules/vue-virtual-scroller/src/components/RecycleScroller.vue","node_modules/vue-virtual-scroller/src/components/DynamicScroller.vue","node_modules/vue-virtual-scroller/src/components/DynamicScrollerItem.vue","node_modules/vue-virtual-scroller/src/mixins/IdState.js","node_modules/vue-virtual-scroller/src/index.js","node_modules/vue-virtual-scroller/node_modules/vue-resize/dist/vue-resize.esm.js","node_modules/vue-observe-visibility/dist/vue-observe-visibility.esm.js","node_modules/scrollparent/scrollparent.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnalyticModel = exports.spinalAnalyticService = void 0;\nconst Analytic_1 = require(\"./Models/Analytic\");\nObject.defineProperty(exports, \"AnalyticModel\", { enumerable: true, get: function () { return Analytic_1.AnalyticModel; } });\nconst AnalyticService_1 = require(\"./services/AnalyticService\");\nconst globalRoot = typeof window === \"undefined\" ? global : window;\nconst spinalAnalyticService = new AnalyticService_1.AnalyticService();\nexports.spinalAnalyticService = spinalAnalyticService;\nif (typeof globalRoot.spinal === 'undefined')\n    globalRoot.spinal = {};\nif (typeof globalRoot.spinal.spinalAnalyticService === 'undefined') {\n    globalRoot.spinal.spinalAnalyticService = spinalAnalyticService;\n}\nif (typeof globalRoot.spinal.spinalAnalyticService === 'undefined') {\n    globalRoot.spinal.spinalAnalyticService = spinalAnalyticService;\n}\nexports.default = spinalAnalyticService;\n//# sourceMappingURL=index.js.map",null,"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnalyticModel = void 0;\nconst spinal_core_connectorjs_type_1 = require(\"spinal-core-connectorjs_type\");\nclass AnalyticModel extends spinal_core_connectorjs_type_1.Model {\n    constructor(analytic) {\n        super();\n        this.add_attr(analytic);\n    }\n}\nexports.AnalyticModel = AnalyticModel;\nspinal_core_connectorjs_type_1.spinalCore.register_models([AnalyticModel]);\nexports.default = AnalyticModel;\n//# sourceMappingURL=Analytic.js.map",null,"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnalyticService = void 0;\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nconst spinal_env_viewer_plugin_group_manager_service_1 = require(\"spinal-env-viewer-plugin-group-manager-service\");\nconst Analytic_1 = require(\"../Models/Analytic\");\nclass AnalyticService {\n    constructor() {\n        this.nodeType = \"Analytic\";\n        this.ANALYTIC_TO_GROUP_RELATION = \"analyticHasGroup\";\n    }\n    /**\n       * This method creates a context of analytic\n       * @param  {string} contextName - The analytic's context Name\n       * @returns Promise\n       */\n    createContext(contextName) {\n        return spinal_env_viewer_plugin_group_manager_service_1.default.createGroupContext(contextName, this.nodeType).then((context) => {\n            const contextId = context.getId().get();\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(contextId);\n        });\n    }\n    /**\n     * retrieves and returns all contexts of analytic\n     * @returns Promise\n     */\n    getContexts(contextName) {\n        return spinal_env_viewer_plugin_group_manager_service_1.default.getGroupContexts(this.nodeType).then((contexts) => {\n            const argContexts = contexts.map(el => spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(el.id));\n            if (typeof contextName === \"undefined\")\n                return argContexts;\n            return argContexts.find(context => context.name.get() === contextName);\n        });\n    }\n    /**\n     * This method creates an endpoint control category\n     * @param  {string} contextId\n     * @param  {string} categoryName\n     * @param  {string} iconName\n     * @returns Promise\n     */\n    createCategory(contextId, categoryName, iconName) {\n        return spinal_env_viewer_plugin_group_manager_service_1.default.addCategory(contextId, categoryName, iconName).then((result) => {\n            const nodeId = result.getId().get();\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(nodeId);\n        });\n    }\n    /**\n     * get and return all categories in the context\n     * @param  {string} nodeId\n     * @returns Promise\n     */\n    getCategories(nodeId) {\n        return spinal_env_viewer_plugin_group_manager_service_1.default.getCategories(nodeId).then((result) => {\n            return result.map(el => spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(el.id.get()));\n        });\n    }\n    /**\n     * This method creates an endpoint control group\n     * @param  {string} contextId\n     * @param  {string} categoryId\n     * @param  {string} groupName\n     * @param  {string} groupColor\n     * @returns Promise\n     */\n    createGroup(contextId, categoryId, groupName, groupColor) {\n        return spinal_env_viewer_plugin_group_manager_service_1.default.addGroup(contextId, categoryId, groupName, groupColor).then((result) => {\n            const nodeId = result.getId().get();\n            return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(nodeId);\n        });\n    }\n    /**\n     * get and return all groups in the category\n     * @param  {string} nodeId\n     * @returns Promise\n     */\n    getGroups(nodeId) {\n        return spinal_env_viewer_plugin_group_manager_service_1.default.getGroups(nodeId).then((result) => {\n            return result.map(el => spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(el.id.get()));\n        });\n    }\n    /**\n     * checks if the id passed in parameter is a group of analytic\n     * @param  {string} id\n     * @returns boolean\n     */\n    isAnalyticGroup(id) {\n        const info = spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(id);\n        const type = info.type.get();\n        return type === `${this.nodeType}Group`;\n    }\n    /**\n     * This function creates and links analytic node to group\n     * @param  {string} contextId\n     * @param  {string} groupId\n     * @param  {IAnalytic} analyticInfo\n     * @returns Promise\n     */\n    createAndLinkAnalytic(contextId, groupId, analyticInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = this.createAnalyticNode(analyticInfo);\n            yield spinal_env_viewer_plugin_group_manager_service_1.default.linkElementToGroup(contextId, groupId, info.id.get());\n            return info;\n        });\n    }\n    /**\n     * This function retrieves and return all analytics node of group\n     * @param  {string} groupId\n     * @returns Promise\n     */\n    getAnalyticNodes(groupId) {\n        return spinal_env_viewer_plugin_group_manager_service_1.default.getElementsLinkedToGroup(groupId);\n    }\n    /**\n     * creates and links analytic to group\n     * @param  {string} contextId\n     * @param  {string} analyticId\n     * @param  {string} groupId\n     * @returns Promise\n     */\n    linkGroupToAnalytic(contextId, analyticId, groupId) {\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.addChildInContext(analyticId, groupId, contextId, this.ANALYTIC_TO_GROUP_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n    }\n    unLinkGroupToAnalytic(analyticId, groupId) {\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.removeChild(analyticId, groupId, this.ANALYTIC_TO_GROUP_RELATION, spinal_env_viewer_graph_service_1.SPINAL_RELATION_PTR_LST_TYPE);\n    }\n    getGroupsLinked(analyticId) {\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(analyticId, [this.ANALYTIC_TO_GROUP_RELATION]);\n    }\n    isLinkedToAnalytic(analyticId, nodeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const children = yield spinal_env_viewer_graph_service_1.SpinalGraphService.getChildren(analyticId, [this.ANALYTIC_TO_GROUP_RELATION]);\n            const found = children.find(el => el.id.get() === nodeId);\n            return typeof found !== \"undefined\";\n        });\n    }\n    /**\n     * This method creates and returns analyctic node info\n     * @param  {IAnalytic} analyticInfo\n     * @returns SpinalNodeRef\n     */\n    createAnalyticNode(analyticInfo) {\n        analyticInfo.type = this.nodeType;\n        const analyticModel = new Analytic_1.AnalyticModel(analyticInfo);\n        const nodeId = spinal_env_viewer_graph_service_1.SpinalGraphService.createNode(analyticInfo, analyticModel);\n        return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(nodeId);\n    }\n}\nexports.default = AnalyticService;\nexports.AnalyticService = AnalyticService;\n//# sourceMappingURL=AnalyticService.js.map",null,"import { ResizeObserver as ResizeObserver$1 } from 'vue-resize';\nimport { ObserveVisibility } from 'vue-observe-visibility';\nimport ScrollParent from 'scrollparent';\nimport Vue from 'vue';\n\nvar config = {\n  itemsLimit: 1000\n};\n\nconst props = {\n  items: {\n    type: Array,\n    required: true\n  },\n  keyField: {\n    type: String,\n    default: 'id'\n  },\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: value => ['vertical', 'horizontal'].includes(value)\n  },\n  listTag: {\n    type: String,\n    default: 'div'\n  },\n  itemTag: {\n    type: String,\n    default: 'div'\n  }\n};\nfunction simpleArray() {\n  return this.items.length && typeof this.items[0] !== 'object';\n}\n\nlet supportsPassive = false;\nif (typeof window !== 'undefined') {\n  supportsPassive = false;\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get() {\n        supportsPassive = true;\n      }\n    });\n    window.addEventListener('test', null, opts);\n  } catch (e) {}\n}\n\n//\nlet uid = 0;\nvar script$2 = {\n  name: 'RecycleScroller',\n  components: {\n    ResizeObserver: ResizeObserver$1\n  },\n  directives: {\n    ObserveVisibility\n  },\n  props: {\n    ...props,\n    itemSize: {\n      type: Number,\n      default: null\n    },\n    gridItems: {\n      type: Number,\n      default: undefined\n    },\n    itemSecondarySize: {\n      type: Number,\n      default: undefined\n    },\n    minItemSize: {\n      type: [Number, String],\n      default: null\n    },\n    sizeField: {\n      type: String,\n      default: 'size'\n    },\n    typeField: {\n      type: String,\n      default: 'type'\n    },\n    buffer: {\n      type: Number,\n      default: 200\n    },\n    pageMode: {\n      type: Boolean,\n      default: false\n    },\n    prerender: {\n      type: Number,\n      default: 0\n    },\n    emitUpdate: {\n      type: Boolean,\n      default: false\n    },\n    skipHover: {\n      type: Boolean,\n      default: false\n    },\n    listTag: {\n      type: String,\n      default: 'div'\n    },\n    itemTag: {\n      type: String,\n      default: 'div'\n    },\n    listClass: {\n      type: [String, Object, Array],\n      default: ''\n    },\n    itemClass: {\n      type: [String, Object, Array],\n      default: ''\n    }\n  },\n  data() {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null\n    };\n  },\n  computed: {\n    sizes() {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': {\n            accumulator: 0\n          }\n        };\n        const items = this.items;\n        const field = this.sizeField;\n        const minItemSize = this.minItemSize;\n        let computedMinSize = 10000;\n        let accumulator = 0;\n        let current;\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize;\n          if (current < computedMinSize) {\n            computedMinSize = current;\n          }\n          accumulator += current;\n          sizes[i] = {\n            accumulator,\n            size: current\n          };\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize;\n        return sizes;\n      }\n      return [];\n    },\n    simpleArray\n  },\n  watch: {\n    items() {\n      this.updateVisibleItems(true);\n    },\n    pageMode() {\n      this.applyPageMode();\n      this.updateVisibleItems(false);\n    },\n    sizes: {\n      handler() {\n        this.updateVisibleItems(false);\n      },\n      deep: true\n    },\n    gridItems() {\n      this.updateVisibleItems(true);\n    },\n    itemSecondarySize() {\n      this.updateVisibleItems(true);\n    }\n  },\n  created() {\n    this.$_startIndex = 0;\n    this.$_endIndex = 0;\n    this.$_views = new Map();\n    this.$_unusedViews = new Map();\n    this.$_scrollDirty = false;\n    this.$_lastUpdateScrollPosition = 0;\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true;\n      this.updateVisibleItems(false);\n    }\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems');\n    }\n  },\n  mounted() {\n    this.applyPageMode();\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false;\n      this.updateVisibleItems(true);\n      this.ready = true;\n    });\n  },\n  activated() {\n    const lastPosition = this.$_lastUpdateScrollPosition;\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition);\n      });\n    }\n  },\n  beforeDestroy() {\n    this.removeListeners();\n  },\n  methods: {\n    addView(pool, index, item, key, type) {\n      const view = {\n        item,\n        position: 0\n      };\n      const nonReactive = {\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type\n      };\n      Object.defineProperty(view, 'nr', {\n        configurable: false,\n        value: nonReactive\n      });\n      pool.push(view);\n      return view;\n    },\n    unuseView(view, fake = false) {\n      const unusedViews = this.$_unusedViews;\n      const type = view.nr.type;\n      let unusedPool = unusedViews.get(type);\n      if (!unusedPool) {\n        unusedPool = [];\n        unusedViews.set(type, unusedPool);\n      }\n      unusedPool.push(view);\n      if (!fake) {\n        view.nr.used = false;\n        view.position = -9999;\n        this.$_views.delete(view.nr.key);\n      }\n    },\n    handleResize() {\n      this.$emit('resize');\n      if (this.ready) this.updateVisibleItems(false);\n    },\n    handleScroll(event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true;\n        requestAnimationFrame(() => {\n          this.$_scrollDirty = false;\n          const {\n            continuous\n          } = this.updateVisibleItems(false, true);\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout);\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100);\n          }\n        });\n      }\n    },\n    handleVisibilityChange(isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible');\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false);\n          });\n        } else {\n          this.$emit('hidden');\n        }\n      }\n    },\n    updateVisibleItems(checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize;\n      const gridItems = this.gridItems || 1;\n      const itemSecondarySize = this.itemSecondarySize || itemSize;\n      const minItemSize = this.$_computedMinItemSize;\n      const typeField = this.typeField;\n      const keyField = this.simpleArray ? null : this.keyField;\n      const items = this.items;\n      const count = items.length;\n      const sizes = this.sizes;\n      const views = this.$_views;\n      const unusedViews = this.$_unusedViews;\n      const pool = this.pool;\n      let startIndex, endIndex;\n      let totalSize;\n      let visibleStartIndex, visibleEndIndex;\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0;\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0;\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length);\n        totalSize = null;\n      } else {\n        const scroll = this.getScroll();\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition;\n          if (positionDiff < 0) positionDiff = -positionDiff;\n          if (itemSize === null && positionDiff < minItemSize || positionDiff < itemSize) {\n            return {\n              continuous: true\n            };\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start;\n        const buffer = this.buffer;\n        scroll.start -= buffer;\n        scroll.end += buffer;\n\n        // account for leading slot\n        let beforeSize = 0;\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight;\n          scroll.start -= beforeSize;\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight;\n          scroll.end += afterSize;\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h;\n          let a = 0;\n          let b = count - 1;\n          let i = ~~(count / 2);\n          let oldI;\n\n          // Searching for startIndex\n          do {\n            oldI = i;\n            h = sizes[i].accumulator;\n            if (h < scroll.start) {\n              a = i;\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i;\n            }\n            i = ~~((a + b) / 2);\n          } while (i !== oldI);\n          i < 0 && (i = 0);\n          startIndex = i;\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator;\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1;\n          } else {\n            endIndex++;\n            // Bounds\n            endIndex > count && (endIndex = count);\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && beforeSize + sizes[visibleStartIndex].accumulator < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && beforeSize + sizes[visibleEndIndex].accumulator < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems);\n          const remainer = startIndex % gridItems;\n          startIndex -= remainer;\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems);\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems));\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems);\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0);\n          endIndex > count && (endIndex = count);\n          visibleStartIndex < 0 && (visibleStartIndex = 0);\n          visibleEndIndex > count && (visibleEndIndex = count);\n          totalSize = Math.ceil(count / gridItems) * itemSize;\n        }\n      }\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError();\n      }\n      this.totalSize = totalSize;\n      let view;\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;\n      if (this.$_continuous !== continuous) {\n        if (continuous) {\n          views.clear();\n          unusedViews.clear();\n          for (let i = 0, l = pool.length; i < l; i++) {\n            view = pool[i];\n            this.unuseView(view);\n          }\n        }\n        this.$_continuous = continuous;\n      } else if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i];\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = items.indexOf(view.item);\n            }\n\n            // Check if index is still in visible range\n            if (view.nr.index === -1 || view.nr.index < startIndex || view.nr.index >= endIndex) {\n              this.unuseView(view);\n            }\n          }\n        }\n      }\n      const unusedIndex = continuous ? null : new Map();\n      let item, type, unusedPool;\n      let v;\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i];\n        const key = keyField ? item[keyField] : item;\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);\n        }\n        view = views.get(key);\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view);\n          continue;\n        }\n\n        // No view assigned to item\n        if (!view) {\n          if (i === items.length - 1) this.$emit('scroll-end');\n          if (i === 0) this.$emit('scroll-start');\n          type = item[typeField];\n          unusedPool = unusedViews.get(type);\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop();\n              view.item = item;\n              view.nr.used = true;\n              view.nr.index = i;\n              view.nr.key = key;\n              view.nr.type = type;\n            } else {\n              view = this.addView(pool, i, item, key, type);\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0;\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type);\n              this.unuseView(view, true);\n              unusedPool = unusedViews.get(type);\n            }\n            view = unusedPool[v];\n            view.item = item;\n            view.nr.used = true;\n            view.nr.index = i;\n            view.nr.key = key;\n            view.nr.type = type;\n            unusedIndex.set(type, v + 1);\n            v++;\n          }\n          views.set(key, view);\n        } else {\n          view.nr.used = true;\n          view.item = item;\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator;\n          view.offset = 0;\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize;\n          view.offset = i % gridItems * itemSecondarySize;\n        }\n      }\n      this.$_startIndex = startIndex;\n      this.$_endIndex = endIndex;\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex);\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer);\n      this.$_sortTimer = setTimeout(this.sortViews, 300);\n      return {\n        continuous\n      };\n    },\n    getListenerTarget() {\n      let target = ScrollParent(this.$el);\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window;\n      }\n      return target;\n    },\n    getScroll() {\n      const {\n        $el: el,\n        direction\n      } = this;\n      const isVertical = direction === 'vertical';\n      let scrollState;\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect();\n        const boundsSize = isVertical ? bounds.height : bounds.width;\n        let start = -(isVertical ? bounds.top : bounds.left);\n        let size = isVertical ? window.innerHeight : window.innerWidth;\n        if (start < 0) {\n          size += start;\n          start = 0;\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start;\n        }\n        scrollState = {\n          start,\n          end: start + size\n        };\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight\n        };\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth\n        };\n      }\n      return scrollState;\n    },\n    applyPageMode() {\n      if (this.pageMode) {\n        this.addListeners();\n      } else {\n        this.removeListeners();\n      }\n    },\n    addListeners() {\n      this.listenerTarget = this.getListenerTarget();\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\n        passive: true\n      } : false);\n      this.listenerTarget.addEventListener('resize', this.handleResize);\n    },\n    removeListeners() {\n      if (!this.listenerTarget) {\n        return;\n      }\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll);\n      this.listenerTarget.removeEventListener('resize', this.handleResize);\n      this.listenerTarget = null;\n    },\n    scrollToItem(index) {\n      let scroll;\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0;\n      } else {\n        scroll = Math.floor(index / this.gridItems) * this.itemSize;\n      }\n      this.scrollToPosition(scroll);\n    },\n    scrollToPosition(position) {\n      const direction = this.direction === 'vertical' ? {\n        scroll: 'scrollTop',\n        start: 'top'\n      } : {\n        scroll: 'scrollLeft',\n        start: 'left'\n      };\n      let viewport;\n      let scrollDirection;\n      let scrollDistance;\n      if (this.pageMode) {\n        const viewportEl = ScrollParent(this.$el);\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll];\n        const bounds = viewportEl.getBoundingClientRect();\n        const scroller = this.$el.getBoundingClientRect();\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start];\n        viewport = viewportEl;\n        scrollDirection = direction.scroll;\n        scrollDistance = position + scrollTop + scrollerPosition;\n      } else {\n        viewport = this.$el;\n        scrollDirection = direction.scroll;\n        scrollDistance = position;\n      }\n      viewport[scrollDirection] = scrollDistance;\n    },\n    itemsLimitError() {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el);\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.');\n      });\n      throw new Error('Rendered items limit reached');\n    },\n    sortViews() {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index);\n    }\n  }\n};\n\nfunction normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n  if (typeof shadowMode !== 'boolean') {\n    createInjectorSSR = createInjector;\n    createInjector = shadowMode;\n    shadowMode = false;\n  }\n  // Vue.extend constructor export interop.\n  const options = typeof script === 'function' ? script.options : script;\n  // render functions\n  if (template && template.render) {\n    options.render = template.render;\n    options.staticRenderFns = template.staticRenderFns;\n    options._compiled = true;\n    // functional template\n    if (isFunctionalTemplate) {\n      options.functional = true;\n    }\n  }\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId;\n  }\n  let hook;\n  if (moduleIdentifier) {\n    // server build\n    hook = function (context) {\n      // 2.3 injection\n      context = context ||\n      // cached call\n      this.$vnode && this.$vnode.ssrContext ||\n      // stateful\n      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__;\n      }\n      // inject component styles\n      if (style) {\n        style.call(this, createInjectorSSR(context));\n      }\n      // register component module identifier for async chunk inference\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier);\n      }\n    };\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook;\n  } else if (style) {\n    hook = shadowMode ? function (context) {\n      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\n    } : function (context) {\n      style.call(this, createInjector(context));\n    };\n  }\n  if (hook) {\n    if (options.functional) {\n      // register for functional component in vue file\n      const originalRender = options.render;\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context);\n        return originalRender(h, context);\n      };\n    } else {\n      // inject component registration as beforeCreate hook\n      const existing = options.beforeCreate;\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n    }\n  }\n  return script;\n}\n\n/* script */\nconst __vue_script__$2 = script$2;\n/* template */\nvar __vue_render__$1 = function () {\n  var _obj, _obj$1;\n  var _vm = this;\n  var _h = _vm.$createElement;\n  var _c = _vm._self._c || _h;\n  return _c(\n    \"div\",\n    {\n      directives: [\n        {\n          name: \"observe-visibility\",\n          rawName: \"v-observe-visibility\",\n          value: _vm.handleVisibilityChange,\n          expression: \"handleVisibilityChange\",\n        },\n      ],\n      staticClass: \"vue-recycle-scroller\",\n      class:\n        ((_obj = {\n          ready: _vm.ready,\n          \"page-mode\": _vm.pageMode,\n        }),\n        (_obj[\"direction-\" + _vm.direction] = true),\n        _obj),\n      on: {\n        \"&scroll\": function ($event) {\n          return _vm.handleScroll.apply(null, arguments)\n        },\n      },\n    },\n    [\n      _vm.$slots.before\n        ? _c(\n            \"div\",\n            { ref: \"before\", staticClass: \"vue-recycle-scroller__slot\" },\n            [_vm._t(\"before\")],\n            2\n          )\n        : _vm._e(),\n      _vm._v(\" \"),\n      _c(\n        _vm.listTag,\n        {\n          ref: \"wrapper\",\n          tag: \"component\",\n          staticClass: \"vue-recycle-scroller__item-wrapper\",\n          class: _vm.listClass,\n          style:\n            ((_obj$1 = {}),\n            (_obj$1[_vm.direction === \"vertical\" ? \"minHeight\" : \"minWidth\"] =\n              _vm.totalSize + \"px\"),\n            _obj$1),\n        },\n        [\n          _vm._l(_vm.pool, function (view) {\n            return _c(\n              _vm.itemTag,\n              _vm._g(\n                {\n                  key: view.nr.id,\n                  tag: \"component\",\n                  staticClass: \"vue-recycle-scroller__item-view\",\n                  class: [\n                    _vm.itemClass,\n                    {\n                      hover: !_vm.skipHover && _vm.hoverKey === view.nr.key,\n                    },\n                  ],\n                  style: _vm.ready\n                    ? {\n                        transform:\n                          \"translate\" +\n                          (_vm.direction === \"vertical\" ? \"Y\" : \"X\") +\n                          \"(\" +\n                          view.position +\n                          \"px) translate\" +\n                          (_vm.direction === \"vertical\" ? \"X\" : \"Y\") +\n                          \"(\" +\n                          view.offset +\n                          \"px)\",\n                        width: _vm.gridItems\n                          ? (_vm.direction === \"vertical\"\n                              ? _vm.itemSecondarySize || _vm.itemSize\n                              : _vm.itemSize) + \"px\"\n                          : undefined,\n                        height: _vm.gridItems\n                          ? (_vm.direction === \"horizontal\"\n                              ? _vm.itemSecondarySize || _vm.itemSize\n                              : _vm.itemSize) + \"px\"\n                          : undefined,\n                      }\n                    : null,\n                },\n                _vm.skipHover\n                  ? {}\n                  : {\n                      mouseenter: function () {\n                        _vm.hoverKey = view.nr.key;\n                      },\n                      mouseleave: function () {\n                        _vm.hoverKey = null;\n                      },\n                    }\n              ),\n              [\n                _vm._t(\"default\", null, {\n                  item: view.item,\n                  index: view.nr.index,\n                  active: view.nr.used,\n                }),\n              ],\n              2\n            )\n          }),\n          _vm._v(\" \"),\n          _vm._t(\"empty\"),\n        ],\n        2\n      ),\n      _vm._v(\" \"),\n      _vm.$slots.after\n        ? _c(\n            \"div\",\n            { ref: \"after\", staticClass: \"vue-recycle-scroller__slot\" },\n            [_vm._t(\"after\")],\n            2\n          )\n        : _vm._e(),\n      _vm._v(\" \"),\n      _c(\"ResizeObserver\", { on: { notify: _vm.handleResize } }),\n    ],\n    1\n  )\n};\nvar __vue_staticRenderFns__$1 = [];\n__vue_render__$1._withStripped = true;\n\n  /* style */\n  const __vue_inject_styles__$2 = undefined;\n  /* scoped */\n  const __vue_scope_id__$2 = undefined;\n  /* module identifier */\n  const __vue_module_identifier__$2 = undefined;\n  /* functional template */\n  const __vue_is_functional_template__$2 = false;\n  /* style inject */\n  \n  /* style inject SSR */\n  \n  /* style inject shadow dom */\n  \n\n  \n  const __vue_component__$2 = /*#__PURE__*/normalizeComponent(\n    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },\n    __vue_inject_styles__$2,\n    __vue_script__$2,\n    __vue_scope_id__$2,\n    __vue_is_functional_template__$2,\n    __vue_module_identifier__$2,\n    false,\n    undefined,\n    undefined,\n    undefined\n  );\n\n//\nvar script$1 = {\n  name: 'DynamicScroller',\n  components: {\n    RecycleScroller: __vue_component__$2\n  },\n  provide() {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return;\n          }\n          for (const entry of entries) {\n            if (entry.target) {\n              const event = new CustomEvent('resize', {\n                detail: {\n                  contentRect: entry.contentRect\n                }\n              });\n              entry.target.dispatchEvent(event);\n            }\n          }\n        });\n      });\n    }\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver\n    };\n  },\n  inheritAttrs: false,\n  props: {\n    ...props,\n    minItemSize: {\n      type: [Number, String],\n      required: true\n    }\n  },\n  data() {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        validSizes: {},\n        keyField: this.keyField,\n        simpleArray: false\n      }\n    };\n  },\n  computed: {\n    simpleArray,\n    itemsWithSize() {\n      const result = [];\n      const {\n        items,\n        keyField,\n        simpleArray\n      } = this;\n      const sizes = this.vscrollData.sizes;\n      const l = items.length;\n      for (let i = 0; i < l; i++) {\n        const item = items[i];\n        const id = simpleArray ? i : item[keyField];\n        let size = sizes[id];\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0;\n        }\n        result.push({\n          item,\n          id,\n          size\n        });\n      }\n      return result;\n    },\n    listeners() {\n      const listeners = {};\n      for (const key in this.$listeners) {\n        if (key !== 'resize' && key !== 'visible') {\n          listeners[key] = this.$listeners[key];\n        }\n      }\n      return listeners;\n    }\n  },\n  watch: {\n    items() {\n      this.forceUpdate(false);\n    },\n    simpleArray: {\n      handler(value) {\n        this.vscrollData.simpleArray = value;\n      },\n      immediate: true\n    },\n    direction(value) {\n      this.forceUpdate(true);\n    },\n    itemsWithSize(next, prev) {\n      const scrollTop = this.$el.scrollTop;\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0;\n      let activeTop = 0;\n      const length = Math.min(next.length, prev.length);\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break;\n        }\n        prevActiveTop += prev[i].size || this.minItemSize;\n        activeTop += next[i].size || this.minItemSize;\n      }\n      const offset = activeTop - prevActiveTop;\n      if (offset === 0) {\n        return;\n      }\n      this.$el.scrollTop += offset;\n    }\n  },\n  beforeCreate() {\n    this.$_updates = [];\n    this.$_undefinedSizes = 0;\n    this.$_undefinedMap = {};\n  },\n  activated() {\n    this.vscrollData.active = true;\n  },\n  deactivated() {\n    this.vscrollData.active = false;\n  },\n  methods: {\n    onScrollerResize() {\n      const scroller = this.$refs.scroller;\n      if (scroller) {\n        this.forceUpdate();\n      }\n      this.$emit('resize');\n    },\n    onScrollerVisible() {\n      this.$emit('vscroll:update', {\n        force: false\n      });\n      this.$emit('visible');\n    },\n    forceUpdate(clear = true) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.validSizes = {};\n      }\n      this.$emit('vscroll:update', {\n        force: true\n      });\n    },\n    scrollToItem(index) {\n      const scroller = this.$refs.scroller;\n      if (scroller) scroller.scrollToItem(index);\n    },\n    getItemSize(item, index = undefined) {\n      const id = this.simpleArray ? index != null ? index : this.items.indexOf(item) : item[this.keyField];\n      return this.vscrollData.sizes[id] || 0;\n    },\n    scrollToBottom() {\n      if (this.$_scrollingToBottom) return;\n      this.$_scrollingToBottom = true;\n      const el = this.$el;\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000;\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000;\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000;\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false;\n            } else {\n              requestAnimationFrame(cb);\n            }\n          });\n        };\n        requestAnimationFrame(cb);\n      });\n    }\n  }\n};\n\n/* script */\nconst __vue_script__$1 = script$1;\n\n/* template */\nvar __vue_render__ = function () {\n  var _vm = this;\n  var _h = _vm.$createElement;\n  var _c = _vm._self._c || _h;\n  return _c(\n    \"RecycleScroller\",\n    _vm._g(\n      _vm._b(\n        {\n          ref: \"scroller\",\n          attrs: {\n            items: _vm.itemsWithSize,\n            \"min-item-size\": _vm.minItemSize,\n            direction: _vm.direction,\n            \"key-field\": \"id\",\n            \"list-tag\": _vm.listTag,\n            \"item-tag\": _vm.itemTag,\n          },\n          on: { resize: _vm.onScrollerResize, visible: _vm.onScrollerVisible },\n          scopedSlots: _vm._u(\n            [\n              {\n                key: \"default\",\n                fn: function (ref) {\n                  var itemWithSize = ref.item;\n                  var index = ref.index;\n                  var active = ref.active;\n                  return [\n                    _vm._t(\"default\", null, null, {\n                      item: itemWithSize.item,\n                      index: index,\n                      active: active,\n                      itemWithSize: itemWithSize,\n                    }),\n                  ]\n                },\n              },\n            ],\n            null,\n            true\n          ),\n        },\n        \"RecycleScroller\",\n        _vm.$attrs,\n        false\n      ),\n      _vm.listeners\n    ),\n    [\n      _vm._v(\" \"),\n      _c(\"template\", { slot: \"before\" }, [_vm._t(\"before\")], 2),\n      _vm._v(\" \"),\n      _c(\"template\", { slot: \"after\" }, [_vm._t(\"after\")], 2),\n      _vm._v(\" \"),\n      _c(\"template\", { slot: \"empty\" }, [_vm._t(\"empty\")], 2),\n    ],\n    2\n  )\n};\nvar __vue_staticRenderFns__ = [];\n__vue_render__._withStripped = true;\n\n  /* style */\n  const __vue_inject_styles__$1 = undefined;\n  /* scoped */\n  const __vue_scope_id__$1 = undefined;\n  /* module identifier */\n  const __vue_module_identifier__$1 = undefined;\n  /* functional template */\n  const __vue_is_functional_template__$1 = false;\n  /* style inject */\n  \n  /* style inject SSR */\n  \n  /* style inject shadow dom */\n  \n\n  \n  const __vue_component__$1 = /*#__PURE__*/normalizeComponent(\n    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },\n    __vue_inject_styles__$1,\n    __vue_script__$1,\n    __vue_scope_id__$1,\n    __vue_is_functional_template__$1,\n    __vue_module_identifier__$1,\n    false,\n    undefined,\n    undefined,\n    undefined\n  );\n\nvar script = {\n  name: 'DynamicScrollerItem',\n  inject: ['vscrollData', 'vscrollParent', 'vscrollResizeObserver'],\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true\n    },\n    watchData: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true\n    },\n    index: {\n      type: Number,\n      default: undefined\n    },\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null\n    },\n    emitResize: {\n      type: Boolean,\n      default: false\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    }\n  },\n  computed: {\n    id() {\n      if (this.vscrollData.simpleArray) return this.index;\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.item.hasOwnProperty(this.vscrollData.keyField)) return this.item[this.vscrollData.keyField];\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`);\n    },\n    size() {\n      return this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id] || 0;\n    },\n    finalActive() {\n      return this.active && this.vscrollData.active;\n    }\n  },\n  watch: {\n    watchData: 'updateWatchData',\n    id() {\n      if (!this.size) {\n        this.onDataUpdate();\n      }\n    },\n    finalActive(value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++;\n            this.vscrollParent.$_undefinedMap[this.id] = true;\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--;\n            this.vscrollParent.$_undefinedMap[this.id] = false;\n          }\n        }\n      }\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize();\n        } else {\n          this.unobserveSize();\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize();\n      }\n    }\n  },\n  created() {\n    if (this.$isServer) return;\n    this.$_forceNextVScrollUpdate = null;\n    this.updateWatchData();\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate);\n      }\n      this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate);\n      this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize);\n    }\n  },\n  mounted() {\n    if (this.vscrollData.active) {\n      this.updateSize();\n      this.observeSize();\n    }\n  },\n  beforeDestroy() {\n    this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate);\n    this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize);\n    this.unobserveSize();\n  },\n  methods: {\n    updateSize() {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id;\n          this.$_forceNextVScrollUpdate = null;\n          this.$_pendingVScrollUpdate = null;\n          this.computeSize(this.id);\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id;\n      }\n    },\n    updateWatchData() {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate();\n        }, {\n          deep: true\n        });\n      } else if (this.$_watchData) {\n        this.$_watchData();\n        this.$_watchData = null;\n      }\n    },\n    onVscrollUpdate({\n      force\n    }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id;\n      }\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize();\n      }\n    },\n    onDataUpdate() {\n      this.updateSize();\n    },\n    computeSize(id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth;\n          const height = this.$el.offsetHeight;\n          this.applySize(width, height);\n        }\n        this.$_pendingSizeUpdate = null;\n      });\n    },\n    applySize(width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width);\n      if (size && this.size !== size) {\n        if (this.vscrollParent.$_undefinedMap[this.id]) {\n          this.vscrollParent.$_undefinedSizes--;\n          this.vscrollParent.$_undefinedMap[this.id] = undefined;\n        }\n        this.$set(this.vscrollData.sizes, this.id, size);\n        this.$set(this.vscrollData.validSizes, this.id, true);\n        if (this.emitResize) this.$emit('resize', this.id);\n      }\n    },\n    observeSize() {\n      if (!this.vscrollResizeObserver || !this.$el.parentNode) return;\n      this.vscrollResizeObserver.observe(this.$el.parentNode);\n      this.$el.parentNode.addEventListener('resize', this.onResize);\n    },\n    unobserveSize() {\n      if (!this.vscrollResizeObserver) return;\n      this.vscrollResizeObserver.unobserve(this.$el.parentNode);\n      this.$el.parentNode.removeEventListener('resize', this.onResize);\n    },\n    onResize(event) {\n      const {\n        width,\n        height\n      } = event.detail.contentRect;\n      this.applySize(width, height);\n    }\n  },\n  render(h) {\n    return h(this.tag, this.$slots.default);\n  }\n};\n\n/* script */\nconst __vue_script__ = script;\n\n/* template */\n\n  /* style */\n  const __vue_inject_styles__ = undefined;\n  /* scoped */\n  const __vue_scope_id__ = undefined;\n  /* module identifier */\n  const __vue_module_identifier__ = undefined;\n  /* functional template */\n  const __vue_is_functional_template__ = undefined;\n  /* style inject */\n  \n  /* style inject SSR */\n  \n  /* style inject shadow dom */\n  \n\n  \n  const __vue_component__ = /*#__PURE__*/normalizeComponent(\n    {},\n    __vue_inject_styles__,\n    __vue_script__,\n    __vue_scope_id__,\n    __vue_is_functional_template__,\n    __vue_module_identifier__,\n    false,\n    undefined,\n    undefined,\n    undefined\n  );\n\nfunction IdState ({\n  idProp = vm => vm.item.id\n} = {}) {\n  const store = {};\n  const vm = new Vue({\n    data() {\n      return {\n        store\n      };\n    }\n  });\n\n  // @vue/component\n  return {\n    data() {\n      return {\n        idState: null\n      };\n    },\n    created() {\n      this.$_id = null;\n      if (typeof idProp === 'function') {\n        this.$_getId = () => idProp.call(this, this);\n      } else {\n        this.$_getId = () => this[idProp];\n      }\n      this.$watch(this.$_getId, {\n        handler(value) {\n          this.$nextTick(() => {\n            this.$_id = value;\n          });\n        },\n        immediate: true\n      });\n      this.$_updateIdState();\n    },\n    beforeUpdate() {\n      this.$_updateIdState();\n    },\n    methods: {\n      /**\n       * Initialize an idState\n       * @param {number|string} id Unique id for the data\n       */\n      $_idStateInit(id) {\n        const factory = this.$options.idState;\n        if (typeof factory === 'function') {\n          const data = factory.call(this, this);\n          vm.$set(store, id, data);\n          this.$_id = id;\n          return data;\n        } else {\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.');\n        }\n      },\n      /**\n       * Ensure idState is created and up-to-date\n       */\n      $_updateIdState() {\n        const id = this.$_getId();\n        if (id == null) {\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`);\n        }\n        if (id !== this.$_id) {\n          if (!store[id]) {\n            this.$_idStateInit(id);\n          }\n          this.idState = store[id];\n        }\n      }\n    }\n  };\n}\n\nfunction registerComponents(Vue, prefix) {\n  Vue.component(`${prefix}recycle-scroller`, __vue_component__$2);\n  Vue.component(`${prefix}RecycleScroller`, __vue_component__$2);\n  Vue.component(`${prefix}dynamic-scroller`, __vue_component__$1);\n  Vue.component(`${prefix}DynamicScroller`, __vue_component__$1);\n  Vue.component(`${prefix}dynamic-scroller-item`, __vue_component__);\n  Vue.component(`${prefix}DynamicScrollerItem`, __vue_component__);\n}\nconst plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"1.1.2\",\n  install(Vue, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: ''\n    }, options);\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key];\n      }\n    }\n    if (finalOptions.installComponents) {\n      registerComponents(Vue, finalOptions.componentsPrefix);\n    }\n  }\n};\n\n// Auto-install\nlet GlobalVue = null;\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\nexport { __vue_component__$1 as DynamicScroller, __vue_component__ as DynamicScrollerItem, IdState, __vue_component__$2 as RecycleScroller, plugin as default };\n//# sourceMappingURL=vue-virtual-scroller.esm.js.map\n","export default {\n  itemsLimit: 1000,\n}\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport ScrollParent from 'scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeDestroy () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const view = {\n        item,\n        position: 0,\n      }\n      const nonReactive = {\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      }\n      Object.defineProperty(view, 'nr', {\n        configurable: false,\n        value: nonReactive,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n        this.$_views.delete(view.nr.key)\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\n          }\n        })\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      if (this.$_continuous !== continuous) {\n        if (continuous) {\n          views.clear()\n          unusedViews.clear()\n          for (let i = 0, l = pool.length; i < l; i++) {\n            view = pool[i]\n            this.unuseView(view)\n          }\n        }\n        this.$_continuous = continuous\n      } else if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = items.indexOf(view.item)\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index === -1 ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type, unusedPool\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        // No view assigned to item\n        if (!view) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n\n          type = item[typeField]\n          unusedPool = unusedViews.get(type)\n\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n              view.item = item\n              view.nr.used = true\n              view.nr.index = i\n              view.nr.key = key\n              view.nr.type = type\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            view.item = item\n            view.nr.used = true\n            view.nr.index = i\n            view.nr.key = key\n            view.nr.type = type\n            unusedIndex.set(type, v + 1)\n            v++\n          }\n          views.set(key, view)\n        } else {\n          view.nr.used = true\n          view.item = item\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = ScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / this.gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = ScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n    v-on=\"listeners\"\n  >\n    <template slot-scope=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template slot=\"before\">\n      <slot name=\"before\" />\n    </template>\n    <template slot=\"after\">\n      <slot name=\"after\" />\n    </template>\n    <template slot=\"empty\">\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target) {\n              const event = new CustomEvent(\n                'resize',\n                {\n                  detail: {\n                    contentRect: entry.contentRect,\n                  },\n                },\n              )\n              entry.target.dispatchEvent(event)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        validSizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n\n    listeners () {\n      const listeners = {}\n      for (const key in this.$listeners) {\n        if (key !== 'resize' && key !== 'visible') {\n          listeners[key] = this.$listeners[key]\n        }\n      }\n      return listeners\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate(false)\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = true) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.validSizes = {}\n      }\n      this.$emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<script>\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.item.hasOwnProperty(this.vscrollData.keyField)) return this.item[this.vscrollData.keyField]\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)\n    },\n\n    size () {\n      return (this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id]) || 0\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id () {\n      if (!this.size) {\n        this.onDataUpdate()\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++\n            this.vscrollParent.$_undefinedMap[this.id] = true\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--\n            this.vscrollParent.$_undefinedMap[this.id] = false\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize()\n        } else {\n          this.unobserveSize()\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize()\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return\n\n    this.$_forceNextVScrollUpdate = null\n    this.updateWatchData()\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\n      }\n\n      this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate)\n      this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize)\n    }\n  },\n\n  mounted () {\n    if (this.vscrollData.active) {\n      this.updateSize()\n      this.observeSize()\n    }\n  },\n\n  beforeDestroy () {\n    this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate)\n    this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize)\n    this.unobserveSize()\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id\n          this.$_forceNextVScrollUpdate = null\n          this.$_pendingVScrollUpdate = null\n          this.computeSize(this.id)\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate()\n        }, {\n          deep: true,\n        })\n      } else if (this.$_watchData) {\n        this.$_watchData()\n        this.$_watchData = null\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize()\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize()\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth\n          const height = this.$el.offsetHeight\n          this.applySize(width, height)\n        }\n        this.$_pendingSizeUpdate = null\n      })\n    },\n\n    applySize (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width)\n      if (size && this.size !== size) {\n        if (this.vscrollParent.$_undefinedMap[this.id]) {\n          this.vscrollParent.$_undefinedSizes--\n          this.vscrollParent.$_undefinedMap[this.id] = undefined\n        }\n        this.$set(this.vscrollData.sizes, this.id, size)\n        this.$set(this.vscrollData.validSizes, this.id, true)\n        if (this.emitResize) this.$emit('resize', this.id)\n      }\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver || !this.$el.parentNode) return\n      this.vscrollResizeObserver.observe(this.$el.parentNode)\n      this.$el.parentNode.addEventListener('resize', this.onResize)\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return\n      this.vscrollResizeObserver.unobserve(this.$el.parentNode)\n      this.$el.parentNode.removeEventListener('resize', this.onResize)\n    },\n\n    onResize (event) {\n      const { width, height } = event.detail.contentRect\n      this.applySize(width, height)\n    },\n  },\n\n  render (h) {\n    return h(this.tag, this.$slots.default)\n  },\n}\n</script>\n","import Vue from 'vue'\n\nexport default function ({\n  idProp = vm => vm.item.id,\n} = {}) {\n  const store = {}\n  const vm = new Vue({\n    data () {\n      return {\n        store,\n      }\n    },\n  })\n\n  // @vue/component\n  return {\n    data () {\n      return {\n        idState: null,\n      }\n    },\n\n    created () {\n      this.$_id = null\n      if (typeof idProp === 'function') {\n        this.$_getId = () => idProp.call(this, this)\n      } else {\n        this.$_getId = () => this[idProp]\n      }\n      this.$watch(this.$_getId, {\n        handler (value) {\n          this.$nextTick(() => {\n            this.$_id = value\n          })\n        },\n        immediate: true,\n      })\n      this.$_updateIdState()\n    },\n\n    beforeUpdate () {\n      this.$_updateIdState()\n    },\n\n    methods: {\n      /**\n       * Initialize an idState\n       * @param {number|string} id Unique id for the data\n       */\n      $_idStateInit (id) {\n        const factory = this.$options.idState\n        if (typeof factory === 'function') {\n          const data = factory.call(this, this)\n          vm.$set(store, id, data)\n          this.$_id = id\n          return data\n        } else {\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\n        }\n      },\n\n      /**\n       * Ensure idState is created and up-to-date\n       */\n      $_updateIdState () {\n        const id = this.$_getId()\n        if (id == null) {\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\n        }\n        if (id !== this.$_id) {\n          if (!store[id]) {\n            this.$_idStateInit(id)\n          }\n          this.idState = store[id]\n        }\n      },\n    },\n  }\n}\n","import config from './config'\n\nimport RecycleScroller from './components/RecycleScroller.vue'\nimport DynamicScroller from './components/DynamicScroller.vue'\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\n\nexport { default as IdState } from './mixins/IdState'\n\nexport {\n  RecycleScroller,\n  DynamicScroller,\n  DynamicScrollerItem,\n}\n\nfunction registerComponents (Vue, prefix) {\n  Vue.component(`${prefix}recycle-scroller`, RecycleScroller)\n  Vue.component(`${prefix}RecycleScroller`, RecycleScroller)\n  Vue.component(`${prefix}dynamic-scroller`, DynamicScroller)\n  Vue.component(`${prefix}DynamicScroller`, DynamicScroller)\n  Vue.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\n  Vue.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\n}\n\nconst plugin = {\n  // eslint-disable-next-line no-undef\n  version: VERSION,\n  install (Vue, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: '',\n    }, options)\n\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key]\n      }\n    }\n\n    if (finalOptions.installComponents) {\n      registerComponents(Vue, finalOptions.componentsPrefix)\n    }\n  },\n}\n\nexport default plugin\n\n// Auto-install\nlet GlobalVue = null\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue\n}\nif (GlobalVue) {\n  GlobalVue.use(plugin)\n}\n","function getInternetExplorerVersion() {\n\tvar ua = window.navigator.userAgent;\n\n\tvar msie = ua.indexOf('MSIE ');\n\tif (msie > 0) {\n\t\t// IE 10 or older => return version number\n\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t}\n\n\tvar trident = ua.indexOf('Trident/');\n\tif (trident > 0) {\n\t\t// IE 11 => return version number\n\t\tvar rv = ua.indexOf('rv:');\n\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t}\n\n\tvar edge = ua.indexOf('Edge/');\n\tif (edge > 0) {\n\t\t// Edge (IE 12+) => return version number\n\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t}\n\n\t// other browser\n\treturn -1;\n}\n\nvar isIE = void 0;\n\nfunction initCompat() {\n\tif (!initCompat.init) {\n\t\tinitCompat.init = true;\n\t\tisIE = getInternetExplorerVersion() !== -1;\n\t}\n}\n\nvar ResizeObserver = { render: function render() {\n\t\tvar _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: \"resize-observer\", attrs: { \"tabindex\": \"-1\" } });\n\t}, staticRenderFns: [], _scopeId: 'data-v-b329ee4c',\n\tname: 'resize-observer',\n\n\tmethods: {\n\t\tcompareAndNotify: function compareAndNotify() {\n\t\t\tif (this._w !== this.$el.offsetWidth || this._h !== this.$el.offsetHeight) {\n\t\t\t\tthis._w = this.$el.offsetWidth;\n\t\t\t\tthis._h = this.$el.offsetHeight;\n\t\t\t\tthis.$emit('notify');\n\t\t\t}\n\t\t},\n\t\taddResizeHandlers: function addResizeHandlers() {\n\t\t\tthis._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);\n\t\t\tthis.compareAndNotify();\n\t\t},\n\t\tremoveResizeHandlers: function removeResizeHandlers() {\n\t\t\tif (this._resizeObject && this._resizeObject.onload) {\n\t\t\t\tif (!isIE && this._resizeObject.contentDocument) {\n\t\t\t\t\tthis._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);\n\t\t\t\t}\n\t\t\t\tdelete this._resizeObject.onload;\n\t\t\t}\n\t\t}\n\t},\n\n\tmounted: function mounted() {\n\t\tvar _this = this;\n\n\t\tinitCompat();\n\t\tthis.$nextTick(function () {\n\t\t\t_this._w = _this.$el.offsetWidth;\n\t\t\t_this._h = _this.$el.offsetHeight;\n\t\t});\n\t\tvar object = document.createElement('object');\n\t\tthis._resizeObject = object;\n\t\tobject.setAttribute('aria-hidden', 'true');\n\t\tobject.setAttribute('tabindex', -1);\n\t\tobject.onload = this.addResizeHandlers;\n\t\tobject.type = 'text/html';\n\t\tif (isIE) {\n\t\t\tthis.$el.appendChild(object);\n\t\t}\n\t\tobject.data = 'about:blank';\n\t\tif (!isIE) {\n\t\t\tthis.$el.appendChild(object);\n\t\t}\n\t},\n\tbeforeDestroy: function beforeDestroy() {\n\t\tthis.removeResizeHandlers();\n\t}\n};\n\n// Install the components\nfunction install(Vue) {\n\tVue.component('resize-observer', ResizeObserver);\n\tVue.component('ResizeObserver', ResizeObserver);\n}\n\n// Plugin\nvar plugin = {\n\t// eslint-disable-next-line no-undef\n\tversion: \"0.4.5\",\n\tinstall: install\n};\n\n// Auto-install\nvar GlobalVue = null;\nif (typeof window !== 'undefined') {\n\tGlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n\tGlobalVue = global.Vue;\n}\nif (GlobalVue) {\n\tGlobalVue.use(plugin);\n}\n\nexport { install, ResizeObserver };\nexport default plugin;\n","function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState =\n/*#__PURE__*/\nfunction () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      vnode.context.$nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && this.options.intersection.threshold || 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction bind(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction update(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unbind(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    bind(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unbind(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  bind: bind,\n  update: update,\n  unbind: unbind\n};\n\nfunction install(Vue) {\n  Vue.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"0.4.6\",\n  install: install\n};\n\nvar GlobalVue = null;\n\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Scrollparent = factory();\n  }\n}(this, function () {\n  function isScrolling(node) {\n    var overflow = getComputedStyle(node, null).getPropertyValue(\"overflow\");\n\n    return overflow.indexOf(\"scroll\") > -1 || overflow.indexOf(\"auto\") > - 1;\n  }\n\n  function scrollParent(node) {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n      return undefined;\n    }\n\n    var current = node.parentNode;\n    while (current.parentNode) {\n      if (isScrolling(current)) {\n        return current;\n      }\n\n      current = current.parentNode;\n    }\n\n    return document.scrollingElement || document.documentElement;\n  }\n\n  return scrollParent;\n}));"],"names":["itemsLimit","props","items","type","Array","required","keyField","String","default","direction","validator","value","includes","listTag","itemTag","simpleArray","length","supportsPassive","window","opts","Object","defineProperty","get","addEventListener","e","uid","name","components","ResizeObserver","directives","ObserveVisibility","itemSize","Number","gridItems","undefined","itemSecondarySize","minItemSize","sizeField","typeField","buffer","pageMode","Boolean","prerender","emitUpdate","skipHover","listClass","itemClass","data","pool","totalSize","ready","hoverKey","computed","sizes","accumulator","field","computedMinSize","current","i","l","size","$_computedMinItemSize","watch","updateVisibleItems","applyPageMode","handler","deep","created","$_startIndex","$_endIndex","$_views","Map","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","console","error","mounted","$nextTick","activated","lastPosition","scrollToPosition","beforeDestroy","removeListeners","methods","addView","index","item","key","view","position","nonReactive","id","used","configurable","push","unuseView","fake","unusedViews","nr","unusedPool","set","delete","handleResize","$emit","handleScroll","event","requestAnimationFrame","continuous","clearTimeout","$_refreshTimout","setTimeout","handleVisibilityChange","isVisible","entry","boundingClientRect","width","height","checkItem","checkPositionDiff","count","views","startIndex","endIndex","visibleStartIndex","visibleEndIndex","Math","min","scroll","getScroll","positionDiff","start","end","beforeSize","$refs","before","scrollHeight","after","afterSize","h","a","b","oldI","remainer","ceil","max","floor","config","itemsLimitError","$_continuous","clear","indexOf","unusedIndex","v","Error","pop","offset","$_sortTimer","sortViews","getListenerTarget","target","ScrollParent","$el","document","documentElement","body","el","isVertical","scrollState","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","passive","removeEventListener","scrollToItem","viewport","scrollDirection","scrollDistance","viewportEl","tagName","scroller","scrollerPosition","log","sort","viewA","viewB","__vue_script__","script","RecycleScroller","provide","$_resizeObserver","entries","isArray","CustomEvent","detail","contentRect","dispatchEvent","vscrollData","vscrollParent","vscrollResizeObserver","inheritAttrs","active","validSizes","itemsWithSize","result","$_undefinedMap","listeners","$listeners","forceUpdate","immediate","next","prev","prevActiveTop","activeTop","beforeCreate","$_updates","$_undefinedSizes","deactivated","onScrollerResize","onScrollerVisible","force","getItemSize","scrollToBottom","$_scrollingToBottom","cb","inject","watchData","sizeDependencies","emitResize","tag","hasOwnProperty","finalActive","onDataUpdate","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$watch","$on","onVscrollUpdate","onVscrollUpdateSize","$off","$_pendingSizeUpdate","computeSize","$_watchData","offsetWidth","offsetHeight","applySize","$set","parentNode","observe","onResize","unobserve","render","$slots","idProp","vm","store","Vue","idState","$_id","$_getId","call","$_updateIdState","beforeUpdate","$_idStateInit","factory","$options","warn","registerComponents","prefix","component","DynamicScroller","DynamicScrollerItem","plugin","version","VERSION","install","options","finalOptions","assign","installComponents","componentsPrefix","GlobalVue","global","use"],"version":3,"file":"spinal-env-viewer-room-manager.0524211d.js.map"}