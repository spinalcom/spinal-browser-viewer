{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A;ACAA;;;;;;;;;;;;;;;;;;;;;;CAsBG,G,I,kB,A,I,I,I,C,e,I,C,O,M,G,S,C,E,C,E,C,E,E;I,I,O,W,K;I,I,O,O,wB,C,G;I,I,C,Q,C,S,O,C,E,U,G,K,Q,I,K,Y,A,G,O;Q,Y;Q,K;Y,O,C,C,E;Q;I;I,O,c,C,G,I;A,I,S,C,E,C,E,C,E,E;I,I,O,W,K;I,C,C,G,G,C,C,E;A,C;A,I,e,A,I,I,I,C,Y,I,S,C,E,Q;I,I,I,K,E,I,M,a,C,O,S,C,c,C,I,C,U,I,gB,U,G;A;A,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,O,c,C,S,c;I,O;A;AAIH,MAAA,YAAA,QAAA;AACA,MAAA,iBAAA,QAAA;AAeA,MAAA,iBAAA,QAAA;AAMA,aAAA,QAAA,qBAAA;AACA,aAAA,QAAA,qBAAA;AAEA;;;;;;CAMG,GACH,SAAe,mBACb,UAAyB,EACzB,aAA4B,EAC5B,WAAmB;I,O,U,I,E,K,G,K,G;QAEnB,MAAM,UAAyB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY,WAAW,EAAE,CAAC,GAAG;QAC5D,MAAM,SAAqB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY,cAAc,EAAE,CAAC,GAAG;QAC3D,MAAM,OAAO,MAAM,AAAA,CAAA,GAAA,eAAA,kBAAoB,AAApB,EAAqB,SAAS,QAAQ;QACzD,CAAA,GAAA,eAAA,mBAAmB,AAAnB,EAAoB;QACpB,OAAO,AAAA,CAAA,GAAA,eAAA,mBAAmB,AAAnB,EAAoB,KAAK,IAAI,CAAC,EAAE,CAAC,GAAG;IAC7C;AAAC;AAED;;;;CAIG,GACH,SAAe,YACb,SAAiB,EACjB,QAAgB,EAChB,YAAoB;I,O,U,I,E,K,G,K,G;QAEpB,MAAM,UAAyB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QAC3C,MAAM,SAAqB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QACvC,MAAM,OAAO,MAAM,AAAA,CAAA,GAAA,eAAA,WAAa,AAAb,EAAc,SAAS,QAAQ;QAClD,CAAA,GAAA,eAAA,mBAAmB,AAAnB,EAAoB;QACpB,OAAO;IACT;AAAC;AAED;;;;CAIG,GACH,SAAe,SACb,SAAiB,EACjB,QAAgB,EAChB,SAAiB;I,O,U,I,E,K,G,K,G;QAEjB,MAAM,UAAyB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QAC3C,MAAM,SAAqB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QACvC,MAAM,OAAO,MAAM,AAAA,CAAA,GAAA,eAAA,QAAU,AAAV,EAAW,SAAS,QAAQ;QAC/C,CAAA,GAAA,eAAA,mBAAmB,AAAnB,EAAoB;QACpB,OAAO;IACT;AAAC;AAED;;;;CAIG,GACH,SAAe,QACb,SAAiB,EACjB,QAAgB,EAChB,QAAgB;I,O,U,I,E,K,G,K,G;QAEhB,MAAM,UAAyB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QAC3C,MAAM,SAAqB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QACvC,MAAM,OAAO,MAAM,AAAA,CAAA,GAAA,eAAA,OAAS,AAAT,EAAU,SAAS,QAAQ;QAC9C,CAAA,GAAA,eAAA,mBAAmB,AAAnB,EAAoB;QACpB,OAAO;IACT;AAAC;AAED;;;;CAIG,GACH,SAAe,QACb,SAAiB,EACjB,QAAgB,EAChB,QAAgB;I,O,U,I,E,K,G,K,G;QAEhB,MAAM,UAAyB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QAC3C,MAAM,SAAqB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QACvC,MAAM,OAAO,MAAM,AAAA,CAAA,GAAA,eAAA,OAAS,AAAT,EAAU,SAAS,QAAQ;QAC9C,CAAA,GAAA,eAAA,mBAAmB,AAAnB,EAAoB;QACpB,OAAO;IACT;AAAC;AAED;;;;CAIG,GACH,SAAe,QACb,SAAiB,EACjB,QAAgB,EAChB,QAAgB;I,O,U,I,E,K,G,K,G;QAEhB,MAAM,UAAyB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QAC3C,MAAM,SAAqB,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QACvC,MAAM,OAAO,MAAM,AAAA,CAAA,GAAA,eAAA,OAAS,AAAT,EAAU,SAAS,QAAQ;QAC9C,CAAA,GAAA,eAAA,mBAAmB,AAAnB,EAAoB;QACpB,OAAO;IACT;AAAC;AAED;;;;;;;CAOG,GACH,SAAS,cACP,UAAyB,EACzB,SAAwB,EACxB,QAAmD,EACnD,KAAU;IAEV,IAAI,UAAU,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY,WAAW,EAAE,CAAC,GAAG;IAC3C,IAAI,SAAS,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY,UAAU,EAAE,CAAC,GAAG;IACzC,OAAO,AAAA,CAAA,GAAA,eAAA,aAAe,AAAf,EAAgB,SAAS,QAAQ,UAAU;AACpD;AAEA,SAAS,yBAAyB,MAAc;IAI9C,IAAI,OAAO,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;IACvB,OAAO,AAAA,CAAA,GAAA,eAAA,wBAA0B,AAA1B,EAA2B,KAAK,IAAI,CAAC,IAAI,CAAC,GAAG;AACtD;AAEA;;;CAGG,GACH,SAAe,sBAAsB,MAAc;I,O,U,I,E,K,G,K,G;QACjD,IAAI,OAAO,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;QACvB,OAAO,AAAA,CAAA,GAAA,eAAA,qBAAuB,AAAvB,EAAwB;IACjC;AAAC;AAED;;;CAGG,GACH,SAAS,sBAAsB,SAAiB;IAC9C,IAAI,UAAU,AAAA,CAAA,GAAA,eAAA,WAAW,AAAX,EAAY;IAC1B,OAAO,AAAA,CAAA,GAAA,eAAA,qBAAuB,AAAvB,EAAwB;AACjC;AAEA,MAAM,oBAAoB;IACxB;IACA,cAAA,eAAA,YAAY;IACZ,eAAA,eAAA,aAAa;IACb;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACD;AAED,QAAA,OAAA,GAAe;;;A;A,I,Y,A,I,I,I,C,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,I,U,A,I,I,I,C,O,I,S,C;I,O,I,Y,U,C,I,C,C,G,G,I,A,I,I,Q;A;A,I,mB,A,I,I,I,C,gB,I,S,O,E,U,E,S;I,I,C,O,a,E,M,I,U;I,I,I,U,K,C,S,c,E,G,G,I,E;I,O,I,C,G,K,S,K,U,K,W,C,C,O,a,C,G;Q,O,I;I,G;I,S,K,C;Q,I,C,C,E,E,C,C,E,G,S,C;Y,O,I,Q,S,C,E,C;gB,E,I,C;oB;oB;oB;oB;iB,I,K,O,G;Y;Q;I;I,S,O,C,E,C;Q,I;Y,K,C,C,E,C;Q,E,O,G;Y,O,C,C,E,C,E,E;Q;I;I,S,K,C;Q,E,K,Y,U,Q,O,C,E,K,C,C,E,I,C,S,U,O,C,C,E,C,E,E;I;I,S,Q,K;Q,O,Q;I;I,S,O,K;Q,O,S;I;I,S,O,C,E,C;Q,I,E,I,E,K,I,E,M,E,O,C,C,E,C,E,E,C,C,E,C,E;I;A;A,O,c,C,S,c;I,O;A;A,Q,qB,G,Q,qB,G,Q,mC,G,Q,qB,G,Q,wB,G,Q,a,G,Q,O,G,Q,O,G,Q,O,G,Q,Q,G,Q,W,G,Q,kB,G,Q,a,G,Q,Y,G,K;AExNf;;;;;;;;;;;;;;;;;;;;;;CAsBG,GACH,MAAA,uBAAA,QAAA;AAKA,MAAA,cAAA,QAAA;AAqBA,MAAA,iBAAA,QAAA;AAEA,MAAM,iBAAiB,IAAI;AAK3B;;;;CAIG,GACH,SAAgB,aAAa,UAAkB;IAC7C,IAAI,kBAAkB,YAAA,sBAAsB,CAAC,OAAO,CAAC;IACrD,IAAI,oBAAoB,IACtB,OAAO;IAET,OAAO,YAAA,sBAAsB,CAAC,kBAAkB,EAAE;AACpD;AANA,QAAA,YAAA,GAAA;AAOA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","sources":["node_modules/spinal-env-viewer-context-geographic-service/build/index.js","node_modules/spinal-env-viewer-context-geographic-service/src/index.ts","node_modules/spinal-env-viewer-context-geographic-service/build/geoServiceV2.js","node_modules/spinal-env-viewer-context-geographic-service/src/geoServiceV2.ts","node_modules/spinal-env-viewer-context-geographic-service/build/graphservice.js","node_modules/spinal-env-viewer-context-geographic-service/src/graphservice.ts"],"sourcesContent":["\"use strict\";\n/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants = require(\"./constants\");\nconst geoServiceV2_1 = require(\"./geoServiceV2\");\nconst graphservice_1 = require(\"./graphservice\");\n__exportStar(require(\"./constants\"), exports);\n__exportStar(require(\"./geoServiceV2\"), exports);\n/**\n * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;\n * @param {SpinalNodeRef} contextRef - The Context geographic\n * @param {SpinalNodeRef} parentNodeRef - The parent Node\n * @param {string} elementName - The AbstactElement Name\n * @returns {Promise<SpinalNode>}\n */\nfunction addAbstractElement(contextRef, parentNodeRef, elementName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextRef.id.get());\n        const parent = (0, graphservice_1.getRealNode)(parentNodeRef.id.get());\n        const node = yield (0, geoServiceV2_1.addAbstractElement)(context, parent, elementName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return (0, graphservice_1.getInfoGraphService)(node.info.id.get());\n    });\n}\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} buildingName - Building Name\n */\nfunction addBuilding(contextId, parentId, buildingName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addBuilding)(context, parent, buildingName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} floorName - the floor Name\n */\nfunction addFloor(contextId, parentId, floorName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addFloor)(context, parent, floorName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} siteName - the site Name\n */\nfunction addSite(contextId, parentId, siteName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addSite)(context, parent, siteName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} zoneName - Zone name\n */\nfunction addZone(contextId, parentId, zoneName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addZone)(context, parent, zoneName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * @param {string} contextId - The Context geographic\n * @param {string} parentId - The parent Node\n * @param {string} roomName - Room Name\n */\nfunction addRoom(contextId, parentId, roomName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (0, graphservice_1.getRealNode)(contextId);\n        const parent = (0, graphservice_1.getRealNode)(parentId);\n        const node = yield (0, geoServiceV2_1.addRoom)(context, parent, roomName);\n        (0, graphservice_1.addNodeGraphService)(node);\n        return node;\n    });\n}\n/**\n * it uses bimObject service to add all dbIds passed as parameters.\n * the parameter elements can be a simple or an array of the following element interface.\n * `{ dbId: number, name: string }`\n * @param {SpinalNodeRef} contextRef - The Context geographic\n * @param {SpinalNodeRef} parentRef - The parent Node\n * @param {TAddBimElementItem | TAddBimElementItem[]} elements\n */\nfunction addBimElement(contextRef, parentRef, elements, model) {\n    let context = (0, graphservice_1.getRealNode)(contextRef.id.get());\n    let parent = (0, graphservice_1.getRealNode)(parentRef.id.get());\n    return (0, geoServiceV2_1.addBimElement)(context, parent, elements, model);\n}\nfunction _getReferenceContextName(nodeId) {\n    let node = (0, graphservice_1.getRealNode)(nodeId);\n    return (0, geoServiceV2_1._getReferenceContextName)(node.info.type.get());\n}\n/**\n *\n * @param {string} nodeId\n */\nfunction addToReferenceContext(nodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let node = (0, graphservice_1.getRealNode)(nodeId);\n        return (0, geoServiceV2_1.addToReferenceContext)(node);\n    });\n}\n/**\n *\n * @param {string} contextId\n */\nfunction addContextToReference(contextId) {\n    let context = (0, graphservice_1.getRealNode)(contextId);\n    return (0, geoServiceV2_1.addContextToReference)(context);\n}\nconst GeographicContext = {\n    constants,\n    getChildType: geoServiceV2_1.getChildType,\n    createContext: geoServiceV2_1.createContext,\n    addAbstractElement,\n    addBuilding,\n    addFloor,\n    addSite,\n    addZone,\n    addRoom,\n    addBimElement,\n    _getReferenceContextName,\n    addToReferenceContext,\n    addContextToReference,\n};\nexports.default = GeographicContext;\n//# sourceMappingURL=index.js.map","/*\n * Copyright 2020 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\n\nimport type { SpinalNodeRef } from 'spinal-env-viewer-graph-service';\nimport type { SpinalContext, SpinalNode } from 'spinal-model-graph';\nimport * as constants from './constants';\nimport {\n  getChildType,\n  createContext,\n  addAbstractElement as addAbstractElementv2,\n  addBuilding as addBuildingv2,\n  addFloor as addFloorv2,\n  addSite as addSitev2,\n  addZone as addZonev2,\n  addRoom as addRoomv2,\n  addBimElement as addBimElementv2,\n  _getReferenceContextName as _getReferenceContextNamev2,\n  addToReferenceContext as addToReferenceContextv2,\n  addContextToReference as addContextToReferencev2,\n  TAddBimElementItem,\n} from './geoServiceV2';\nimport {\n  addNodeGraphService,\n  getInfoGraphService,\n  getRealNode,\n} from './graphservice';\n\nexport * from './constants';\nexport * from './geoServiceV2';\n\n/**\n * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;\n * @param {SpinalNodeRef} contextRef - The Context geographic\n * @param {SpinalNodeRef} parentNodeRef - The parent Node\n * @param {string} elementName - The AbstactElement Name\n * @returns {Promise<SpinalNode>}\n */\nasync function addAbstractElement(\n  contextRef: SpinalNodeRef,\n  parentNodeRef: SpinalNodeRef,\n  elementName: string\n): Promise<SpinalNodeRef> {\n  const context: SpinalContext = getRealNode(contextRef.id.get());\n  const parent: SpinalNode = getRealNode(parentNodeRef.id.get());\n  const node = await addAbstractElementv2(context, parent, elementName);\n  addNodeGraphService(node);\n  return getInfoGraphService(node.info.id.get());\n}\n\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} buildingName - Building Name\n */\nasync function addBuilding(\n  contextId: string,\n  parentId: string,\n  buildingName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addBuildingv2(context, parent, buildingName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} floorName - the floor Name\n */\nasync function addFloor(\n  contextId: string,\n  parentId: string,\n  floorName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addFloorv2(context, parent, floorName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} siteName - the site Name\n */\nasync function addSite(\n  contextId: string,\n  parentId: string,\n  siteName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addSitev2(context, parent, siteName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * @param {string} contextId - The Context geographic Id\n * @param {string} parentId - The parent Node Id\n * @param {string} zoneName - Zone name\n */\nasync function addZone(\n  contextId: string,\n  parentId: string,\n  zoneName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addZonev2(context, parent, zoneName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * @param {string} contextId - The Context geographic\n * @param {string} parentId - The parent Node\n * @param {string} roomName - Room Name\n */\nasync function addRoom(\n  contextId: string,\n  parentId: string,\n  roomName: string\n): Promise<SpinalNode> {\n  const context: SpinalContext = getRealNode(contextId);\n  const parent: SpinalNode = getRealNode(parentId);\n  const node = await addRoomv2(context, parent, roomName);\n  addNodeGraphService(node);\n  return node;\n}\n\n/**\n * it uses bimObject service to add all dbIds passed as parameters.\n * the parameter elements can be a simple or an array of the following element interface.\n * `{ dbId: number, name: string }`\n * @param {SpinalNodeRef} contextRef - The Context geographic\n * @param {SpinalNodeRef} parentRef - The parent Node\n * @param {TAddBimElementItem | TAddBimElementItem[]} elements\n */\nfunction addBimElement(\n  contextRef: SpinalNodeRef,\n  parentRef: SpinalNodeRef,\n  elements: TAddBimElementItem | TAddBimElementItem[],\n  model: any\n): Promise<unknown[]> {\n  let context = getRealNode(contextRef.id.get());\n  let parent = getRealNode(parentRef.id.get());\n  return addBimElementv2(context, parent, elements, model);\n}\n\nfunction _getReferenceContextName(nodeId: string): {\n  name: string;\n  relation: string;\n} {\n  let node = getRealNode(nodeId);\n  return _getReferenceContextNamev2(node.info.type.get());\n}\n\n/**\n *\n * @param {string} nodeId\n */\nasync function addToReferenceContext(nodeId: string): Promise<void> {\n  let node = getRealNode(nodeId);\n  return addToReferenceContextv2(node);\n}\n\n/**\n *\n * @param {string} contextId\n */\nfunction addContextToReference(contextId: string): Promise<void> {\n  let context = getRealNode(contextId);\n  return addContextToReferencev2(context);\n}\n\nconst GeographicContext = {\n  constants,\n  getChildType,\n  createContext,\n  addAbstractElement,\n  addBuilding,\n  addFloor,\n  addSite,\n  addZone,\n  addRoom,\n  addBimElement,\n  _getReferenceContextName,\n  addToReferenceContext,\n  addContextToReference,\n};\n\nexport default GeographicContext;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addContextToReference = exports.getOrCreateRefContext = exports.getOrCreateElemFromReferenceContext = exports.addToReferenceContext = exports._getReferenceContextName = exports.addBimElement = exports.addRoom = exports.addZone = exports.addSite = exports.addFloor = exports.addBuilding = exports.addAbstractElement = exports.createContext = exports.getChildType = void 0;\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_model_graph_1 = require(\"spinal-model-graph\");\nconst constants_1 = require(\"./constants\");\nconst graphservice_1 = require(\"./graphservice\");\nconst dicoContextRef = new Map();\n/**\n * Returns the child type of the type given as parameter.\n * @param {string} parentType\n * @return {string} Child type\n */\nfunction getChildType(parentType) {\n    let parentTypeIndex = constants_1.GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);\n    if (parentTypeIndex === -1) {\n        return '';\n    }\n    return constants_1.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];\n}\nexports.getChildType = getChildType;\nfunction createContext(contextName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof contextName !== 'string') {\n            throw Error('contextName must be a string');\n        }\n        const graph = (0, graphservice_1.getGraph)();\n        const context = yield graph.getContext(contextName);\n        if (typeof context !== 'undefined')\n            return Promise.resolve(context);\n        const contextRes = new spinal_model_graph_1.SpinalContext(contextName, constants_1.CONTEXT_TYPE);\n        yield graph.addContext(contextRes);\n        (0, graphservice_1.addNodeGraphService)(contextRes);\n        return contextRes;\n    });\n}\nexports.createContext = createContext;\nfunction addAbstractElement(context, parent, elementName, id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const parentType = parent.info.type.get();\n        const childType = getChildType(parentType);\n        if (!childType) {\n            throw Error(`${parentType} is not a valid type in geographic context`);\n        }\n        return getOrCreateElemFromReferenceContext(childType, context, parent, elementName, id);\n    });\n}\nexports.addAbstractElement = addAbstractElement;\nfunction addBuilding(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.BUILDING_TYPE, context, parent, elementName, id);\n}\nexports.addBuilding = addBuilding;\nfunction addFloor(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.FLOOR_TYPE, context, parent, elementName, id);\n}\nexports.addFloor = addFloor;\nfunction addSite(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.SITE_TYPE, context, parent, elementName, id);\n}\nexports.addSite = addSite;\nfunction addZone(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.ZONE_TYPE, context, parent, elementName, id);\n}\nexports.addZone = addZone;\nfunction addRoom(context, parent, elementName, id) {\n    return getOrCreateElemFromReferenceContext(constants_1.ROOM_TYPE, context, parent, elementName, id);\n}\nexports.addRoom = addRoom;\nfunction addBimElement(context, parent, elements, model) {\n    const elems = Array.isArray(elements) ? elements : [elements];\n    let contextId = context.info.id.get();\n    let parentId = parent.info.id.get();\n    (0, graphservice_1.addNodeGraphService)(context);\n    (0, graphservice_1.addNodeGraphService)(parent);\n    return Promise.all(elems.map((element) => {\n        return window.spinal.BimObjectService.addBIMObject(contextId, parentId, element.dbId, element.name, model);\n    }));\n}\nexports.addBimElement = addBimElement;\nfunction _getReferenceContextName(nodeType) {\n    switch (nodeType) {\n        case constants_1.SITE_TYPE:\n            return {\n                name: constants_1.SITE_REFERENCE_CONTEXT,\n                relation: constants_1.SITE_RELATION,\n            };\n        case constants_1.BUILDING_TYPE:\n            return {\n                name: constants_1.BUILDING_REFERENCE_CONTEXT,\n                relation: constants_1.BUILDING_RELATION,\n            };\n        case constants_1.FLOOR_TYPE:\n            return {\n                name: constants_1.FLOOR_REFERENCE_CONTEXT,\n                relation: constants_1.FLOOR_RELATION,\n            };\n        case constants_1.ZONE_TYPE:\n            return {\n                name: constants_1.ZONE_REFERENCE_CONTEXT,\n                relation: constants_1.ZONE_RELATION,\n            };\n        case constants_1.ROOM_TYPE:\n            return {\n                name: constants_1.ROOM_REFERENCE_CONTEXT,\n                relation: constants_1.ROOM_RELATION,\n            };\n        default:\n            return undefined;\n    }\n}\nexports._getReferenceContextName = _getReferenceContextName;\nfunction addToReferenceContext(node) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const obj = _getReferenceContextName(node.info.type.get());\n        if (typeof obj !== 'undefined') {\n            let context = yield getOrCreateRefContext(obj.name);\n            yield context.addChild(node, obj.relation, spinal_model_graph_1.SPINAL_RELATION_PTR_LST_TYPE);\n        }\n    });\n}\nexports.addToReferenceContext = addToReferenceContext;\nfunction getOrCreateElemFromReferenceContext(nodeType, context, parent, elementName, id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const obj = _getReferenceContextName(nodeType);\n        if (typeof obj === 'undefined')\n            throw new Error(`error unknonw node type : ${nodeType}`);\n        const refContext = yield getOrCreateRefContext(obj.name);\n        let node;\n        if (typeof id !== 'undefined') {\n            const refNodes = yield refContext.getChildren(obj.relation);\n            node = refNodes.find((itm) => itm.info.id.get() === id);\n        }\n        if (!node) {\n            node = new spinal_model_graph_1.SpinalNode(elementName, nodeType);\n            if (typeof id !== 'undefined')\n                node.info.id.set(id);\n            yield refContext.addChild(node, obj.relation, spinal_model_graph_1.SPINAL_RELATION_PTR_LST_TYPE);\n        }\n        yield parent.addChildInContext(node, obj.relation, spinal_model_graph_1.SPINAL_RELATION_PTR_LST_TYPE, context);\n        return node;\n    });\n}\nexports.getOrCreateElemFromReferenceContext = getOrCreateElemFromReferenceContext;\nfunction _getOrCreateRefContext(contextName) {\n    return __asyncGenerator(this, arguments, function* _getOrCreateRefContext_1() {\n        const graph = (0, graphservice_1.getGraph)();\n        let context = yield __await(graph.getContext(contextName));\n        if (!context) {\n            context = new spinal_model_graph_1.SpinalContext(contextName, contextName.replace('.', ''));\n            yield __await(graph.addContext(context));\n        }\n        (0, graphservice_1.addNodeGraphService)(context);\n        while (true)\n            yield yield __await(context);\n    });\n}\nfunction getOrCreateRefContext(contextName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!dicoContextRef.has(contextName)) {\n            const gen = _getOrCreateRefContext(contextName);\n            dicoContextRef.set(contextName, gen);\n        }\n        return (yield dicoContextRef.get(contextName).next()).value;\n    });\n}\nexports.getOrCreateRefContext = getOrCreateRefContext;\nfunction addContextToReference(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof context !== 'undefined') {\n            yield context.map(constants_1.GEOGRAPHIC_RELATIONS, (node) => {\n                (0, graphservice_1.addNodeGraphService)(node);\n                return addToReferenceContext(node);\n            });\n        }\n    });\n}\nexports.addContextToReference = addContextToReference;\n//# sourceMappingURL=geoServiceV2.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport {\n  SpinalContext,\n  SpinalNode,\n  SPINAL_RELATION_PTR_LST_TYPE,\n} from 'spinal-model-graph';\nimport {\n  GEOGRAPHIC_TYPES_ORDER,\n  GEOGRAPHIC_RELATIONS,\n  MAP_TYPE_RELATION,\n  SITE_RELATION,\n  BUILDING_RELATION,\n  FLOOR_RELATION,\n  ZONE_RELATION,\n  ROOM_RELATION,\n  CONTEXT_TYPE,\n  SITE_TYPE,\n  BUILDING_TYPE,\n  FLOOR_TYPE,\n  ZONE_TYPE,\n  ROOM_TYPE,\n  SITE_REFERENCE_CONTEXT,\n  BUILDING_REFERENCE_CONTEXT,\n  FLOOR_REFERENCE_CONTEXT,\n  ZONE_REFERENCE_CONTEXT,\n  ROOM_REFERENCE_CONTEXT,\n} from './constants';\nimport { addNodeGraphService, getGraph } from './graphservice';\n\nconst dicoContextRef = new Map<\n  string,\n  AsyncGenerator<SpinalNode, never, never>\n>();\n\n/**\n * Returns the child type of the type given as parameter.\n * @param {string} parentType\n * @return {string} Child type\n */\nexport function getChildType(parentType: string): string {\n  let parentTypeIndex = GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);\n  if (parentTypeIndex === -1) {\n    return '';\n  }\n  return GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];\n}\nexport async function createContext(\n  contextName: string\n): Promise<SpinalContext> {\n  if (typeof contextName !== 'string') {\n    throw Error('contextName must be a string');\n  }\n  const graph = getGraph();\n  const context = await graph.getContext(contextName);\n  if (typeof context !== 'undefined') return Promise.resolve(context);\n  const contextRes = new SpinalContext(contextName, CONTEXT_TYPE);\n  await graph.addContext(contextRes);\n  addNodeGraphService(contextRes);\n  return contextRes;\n}\nexport async function addAbstractElement(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n): Promise<SpinalNode> {\n  const parentType = parent.info.type.get();\n  const childType = getChildType(parentType);\n  if (!childType) {\n    throw Error(`${parentType} is not a valid type in geographic context`);\n  }\n  return getOrCreateElemFromReferenceContext(\n    childType,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addBuilding(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    BUILDING_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addFloor(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    FLOOR_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addSite(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    SITE_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addZone(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    ZONE_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\nexport function addRoom(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n) {\n  return getOrCreateElemFromReferenceContext(\n    ROOM_TYPE,\n    context,\n    parent,\n    elementName,\n    id\n  );\n}\n\nexport type TAddBimElementItem = {\n  dbId: number;\n  name: string;\n};\nexport function addBimElement(\n  context: SpinalContext,\n  parent: SpinalNode,\n  elements: TAddBimElementItem | TAddBimElementItem[],\n  model: any\n): Promise<unknown[]> {\n  const elems = Array.isArray(elements) ? elements : [elements];\n  let contextId = context.info.id.get();\n  let parentId = parent.info.id.get();\n  addNodeGraphService(context);\n  addNodeGraphService(parent);\n  return Promise.all(\n    elems.map((element) => {\n      return window.spinal.BimObjectService.addBIMObject(\n        contextId,\n        parentId,\n        element.dbId,\n        element.name,\n        model\n      );\n    })\n  );\n}\nexport function _getReferenceContextName(nodeType: string): {\n  name: string;\n  relation: string;\n} {\n  switch (nodeType) {\n    case SITE_TYPE:\n      return {\n        name: SITE_REFERENCE_CONTEXT,\n        relation: SITE_RELATION,\n      };\n    case BUILDING_TYPE:\n      return {\n        name: BUILDING_REFERENCE_CONTEXT,\n        relation: BUILDING_RELATION,\n      };\n\n    case FLOOR_TYPE:\n      return {\n        name: FLOOR_REFERENCE_CONTEXT,\n        relation: FLOOR_RELATION,\n      };\n\n    case ZONE_TYPE:\n      return {\n        name: ZONE_REFERENCE_CONTEXT,\n        relation: ZONE_RELATION,\n      };\n\n    case ROOM_TYPE:\n      return {\n        name: ROOM_REFERENCE_CONTEXT,\n        relation: ROOM_RELATION,\n      };\n\n    default:\n      return undefined;\n  }\n}\n\nexport async function addToReferenceContext(node: SpinalNode): Promise<void> {\n  const obj = _getReferenceContextName(node.info.type.get());\n\n  if (typeof obj !== 'undefined') {\n    let context = await getOrCreateRefContext(obj.name);\n    await context.addChild(node, obj.relation, SPINAL_RELATION_PTR_LST_TYPE);\n  }\n}\n\nexport async function getOrCreateElemFromReferenceContext(\n  nodeType: string,\n  context: SpinalContext,\n  parent: SpinalNode,\n  elementName: string,\n  id?: string\n): Promise<SpinalNode> {\n  const obj = _getReferenceContextName(nodeType);\n  if (typeof obj === 'undefined')\n    throw new Error(`error unknonw node type : ${nodeType}`);\n\n  const refContext = await getOrCreateRefContext(obj.name);\n  let node;\n  if (typeof id !== 'undefined') {\n    const refNodes = await refContext.getChildren(obj.relation);\n    node = refNodes.find((itm) => itm.info.id.get() === id);\n  }\n  if (!node) {\n    node = new SpinalNode(elementName, nodeType);\n    if (typeof id !== 'undefined') node.info.id.set(id);\n    await refContext.addChild(node, obj.relation, SPINAL_RELATION_PTR_LST_TYPE);\n  }\n  await parent.addChildInContext(\n    node,\n    obj.relation,\n    SPINAL_RELATION_PTR_LST_TYPE,\n    context\n  );\n  return node;\n}\n\nasync function* _getOrCreateRefContext(\n  contextName: string\n): AsyncGenerator<SpinalNode<any>, never, never> {\n  const graph = getGraph();\n  let context = await graph.getContext(contextName);\n  if (!context) {\n    context = new SpinalContext(contextName, contextName.replace('.', ''));\n    await graph.addContext(context);\n  }\n  addNodeGraphService(context);\n  while (true) yield context;\n}\n\nexport async function getOrCreateRefContext(\n  contextName: string\n): Promise<SpinalNode> {\n  if (!dicoContextRef.has(contextName)) {\n    const gen = _getOrCreateRefContext(contextName);\n    dicoContextRef.set(contextName, gen);\n  }\n  return (await dicoContextRef.get(contextName)!.next()).value;\n}\n\nexport async function addContextToReference(\n  context: SpinalContext\n): Promise<void> {\n  if (typeof context !== 'undefined') {\n    await context.map(GEOGRAPHIC_RELATIONS, (node) => {\n      addNodeGraphService(node);\n      return addToReferenceContext(node);\n    });\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getInfoGraphService = exports.getRealNode = exports.getGraph = exports.addNodeGraphService = void 0;\n/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nconst spinal_env_viewer_graph_service_1 = require(\"spinal-env-viewer-graph-service\");\nfunction addNodeGraphService(node) {\n    // @ts-ignore\n    spinal_env_viewer_graph_service_1.SpinalGraphService._addNode(node);\n}\nexports.addNodeGraphService = addNodeGraphService;\nfunction getGraph() {\n    return spinal_env_viewer_graph_service_1.SpinalGraphService.getGraph();\n}\nexports.getGraph = getGraph;\nfunction getRealNode(nodeId) {\n    return spinal_env_viewer_graph_service_1.SpinalGraphService.getRealNode(nodeId);\n}\nexports.getRealNode = getRealNode;\nfunction getInfoGraphService(nodeId) {\n    return spinal_env_viewer_graph_service_1.SpinalGraphService.getInfo(nodeId);\n}\nexports.getInfoGraphService = getInfoGraphService;\n//# sourceMappingURL=graphservice.js.map","/*\n * Copyright 2023 SpinalCom - www.spinalcom.com\n *\n * This file is part of SpinalCore.\n *\n * Please read all of the following terms and conditions\n * of the Free Software license Agreement (\"Agreement\")\n * carefully.\n *\n * This Agreement is a legally binding contract between\n * the Licensee (as defined below) and SpinalCom that\n * sets forth the terms and conditions that govern your\n * use of the Program. By installing and/or using the\n * Program, you agree to abide by all the terms and\n * conditions stated or referenced herein.\n *\n * If you do not agree to abide by these terms and\n * conditions, do not demonstrate your acceptance and do\n * not install or use the Program.\n * You should have received a copy of the license along\n * with this file. If not, see\n * <http://resources.spinalcom.com/licenses.pdf>.\n */\nimport {\n  SpinalGraphService,\n  SpinalNodeRef,\n} from 'spinal-env-viewer-graph-service';\nimport { SpinalGraph, SpinalNode } from 'spinal-model-graph';\n\nexport function addNodeGraphService(node: SpinalNode): void {\n  // @ts-ignore\n  SpinalGraphService._addNode(node);\n}\n\nexport function getGraph(): SpinalGraph {\n  return SpinalGraphService.getGraph();\n}\n\nexport function getRealNode(nodeId: string): SpinalNode {\n  return SpinalGraphService.getRealNode(nodeId);\n}\n\nexport function getInfoGraphService(nodeId: string): SpinalNodeRef {\n  return SpinalGraphService.getInfo(nodeId);\n}\n"],"names":[],"version":3,"file":"spinal-env-viewer-context-geographic.ab074ff9.js.map"}